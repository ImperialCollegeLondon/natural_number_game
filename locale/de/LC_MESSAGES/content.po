# 
msgid ""
msgstr ""
"Project-Id-Version: 1.3.3\n"
"POT-Creation-Date: 2021-11-25 21:10:12.701878\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"

#: game_config
msgid "Natural number game"
msgstr "Die Natürlichen Zahlen - Das Spiel"

#: intro
msgid ""
"# The Natural Number Game, version 1.3.3\n"
"\n"
"## By Kevin Buzzard and Mohammad Pedramfar. \n"
"\n"
"# What is this game?\n"
"\n"
"Welcome to the natural number game -- a part-book part-game which shows the "
"power of induction.\n"
"Blue nodes on the graph are ones that you are ready to enter. Grey nodes you "
"should stay away\n"
"from -- a grey node turns blue when *all* nodes above it are complete. Green "
"nodes are completed.\n"
"(Actually you can try any level at any time, but you might not know enough "
"to complete it if it's grey).\n"
"\n"
"In this game, you get own version of the natural numbers, called `mynat`, in "
"an interactive\n"
"theorem prover called Lean. Your version of the natural numbers satisfies "
"something called\n"
"the principle of mathematical induction, and a couple of other things too "
"(Peano's axioms).\n"
"Unfortunately, nobody has proved any theorems about these\n"
"natural numbers yet! For example, addition will be defined for you,\n"
"but nobody has proved that `x + y = y + x` yet. This is your job. You're "
"going to\n"
"prove mathematical theorems using the Lean theorem prover. In other words, "
"you're going to solve\n"
"levels in a computer game.\n"
"\n"
"You're going to prove these theorems using *tactics*. The introductory "
"world, Tutorial World,\n"
"will take you through some of these tactics. During your proofs, your \"goal"
"\" (i.e. what you're\n"
"supposed to be proving) will be displayed with  a `⊢` symbol in front of it. "
"If the top\n"
"right hand box reports \"Theorem Proved!\", you have closed all the goals in "
"the level\n"
"and can move on to the next level in the world you're in. When you've "
"finished a world,\n"
"hit \"main menu\" in the top left to get back here.\n"
"\n"
"For more info, see the <a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/"
"natural_number_game/FAQ.html\" target=\"blank\">FAQ</a>.\n"
"\n"
"# What's new in v1.3?\n"
"\n"
"The game now saves your progress! Thanks to everyone who asked for it,\n"
"and to Mohammad for making it happen :-)\n"
"\n"
"Cute little clipboard to copy your solutions.\n"
"\n"
"# Thanks\n"
"\n"
"Special thanks to Rob Lewis for tactic hackery, Bryan Gin-Ge Chen for\n"
"javascript hackery, Patrick Massot for his\n"
"<a href=\"https://github.com/leanprover-community/format_lean\" target="
"\"blank\">Lean to html formatter</a>,\n"
"Sian Carey for Power World,\n"
"and, last but not least, all the people who fed back comments, including\n"
"the 2019-20 Imperial College 1st year maths beta tester students, Marie-"
"Amélie Lawn,\n"
"Toby Gee, Joseph Myers, and all the people who have been in touch\n"
"via the <a href=\"https://leanprover.zulipchat.com/\" target=\"blank\">Lean "
"Zulip chat</a>\n"
" or the <a href=\"https://xenaproject.wordpress.com/\" target=\"blank\">Xena "
"Project blog</a>\n"
" or via <a href=\"https://twitter.com/XenaProject\" target=\"blank"
"\">Twitter</a>.\n"
"The natural number game is brought to you by the Xena project, a project "
"based at Imperial College London\n"
"whose aim is to get mathematics undergraduates using computer theorem "
"provers.\n"
"Lean is a computer theorem prover being developed at Microsoft Research.\n"
"\n"
"Prove a theorem. Write a function. <a href=\"https://twitter.com/XenaProject"
"\" target=\"blank\">@XenaProject</a>.\n"
msgstr ""
"# Die Natürlichen Zahlen - Das Spiel \n"
" \n"
"## Von Kevin Buzzard und Mohammad Pedramfar. \n"
"\n"
"# Worum geht es in diesem Spiel?\n"
"\n"
"Willkommen zum Spiel rund um natürliche Zahlen -- teilweise Buch und "
"teilweise Spiel, das die Stärke der Induktion zeigt \n"
"Blaue Knoten auf dem Graphen können direkt betreten werden. Graue Knoten "
"solltennoch nicht betreten werden \n"
"Ein grauer Knoten wird blau, wenn *alle* Knoten über ihm bearbeitet wurden."
"Grüne Knoten sind fertig bearbeitet(Eigentlich kann jedes beliebige Level zu "
"jeder Zeit bearbeitet werden,aber solange es grau ist, reichen deine "
"Kenntnisse möglicherweisenoch nicht aus, um es zu schaffen!)\n"
"\n"
"In diesem Spiel baust du deine eigene Version der Natürlichen Zahlen, die "
"'mynat'genannt werden, in einem interaktiven \n"
"Programm für das Schreiben mathematischer Beweise, das Lean genannt wird. \n"
"Deine Version der natürlichen Zahlen gehorcht dem Prinzip der vollständigen "
"Induktion, \n"
"wie auch einige anderen grundlegenden Dingen (Die Axiome von Peano) \n"
"Unglücklicherweise hat bisher niemand irgendwelche Sätze für diese "
"natürlichen Zahlen bewiesen! \n"
"Beispielsweise ist die Addition bereits definiert, aber niemand hat "
"bewiesen, dass gilt: 'x+y=y+x \n"
"Das ist deine Aufgabe! Du wirst mathematische Sätze mit Lean beweisen. \n"
"Mit anderen Worten: \n"
"Du wirst 'Rätsel' in Levels \n"
"eines Computerspiel lösen! \n"
"\n"
"Um diese Sätze zu beweisen, wirst du *Taktiken* verwenden.In der "
"einleitenden Tutorial-Welt wirst du einige dieser Taktiken lernen \n"
"Während deiner Beweise wird deine \"Ziel\" (also das, was du beweist) hinter "
"dem Symbol `⊢` stehen. \n"
"Wenn die Box\n"
"in der rechten oberen Ecke \"Satz bewiesen!\" anzeigt, hast du alle Ziele in "
"diesem Level erreicht \n"
"und kannst zum nächsten Level in deiner derzeitigen Welt weiter. \n"
"Wenn du eine Welt geschafft hast, kannst du über \"Hauptmenü\"in der oberen "
"linken Ecke hierher zurückkehren. \n"
"If the top\n"
"\n"
"Für weitere Informationen (auf Englisch) <a href=\"http://wwwf.imperial.ac."
"uk/~buzzard/xena/natural_number_game/FAQ.html\" target=\"blank\">FAQ</a>.\n"
"\n"
"# Was ist neu in der Version 1.3.2? \n"
"\n"
"Das Spiel kann jetzt deinen Fortschritt speichern. Vielen Dank an alle, die "
"danach gefragt haben\n"
" und an Mohammad, der es realisiert hat! :-)\n"
"# Dank\n"
"\n"
"Ein spezieller Dank gilt Rob Lewis für Taktik-Zauber, Bryan Gine-Ge Chen "
"für \n"
"javascript-Zauber, Patrick Massot für: \n"
"<a href=\"https://github.com/leanprover-community/format_lean\" target="
"\"blank\">Lean zu html Formattierer</a>,\n"
"Sian Carey für die Potenz Welt, \n"
"und natürlich allen Leuten, die das Spiel durch Rückmeldungen verbessert "
"haben, \n"
"insbesondere die 2019-20 Imperal College Ersti Mathematik Studenten Beta-"
"Tester: \n"
"Marie-Amélie Lawn, Toby Gee, Joseph Myers, aber auch überden <a href="
"\"https://leanprover.zulipchat.com/\" target=\"blank\">Lean Zulip chat</a>,\n"
"oder den <a href=\"https://xenaproject.wordpress.com/\" target=\"blank"
"\">Xena Projekt blog</a>\n"
" oder über <a href=\"https://twitter.com/XenaProject\" target=\"blank"
"\">Twitter</a>.\n"
"Die Natürlichen Zahlen - Das Spiel, wird dir vom Xena Projekt präsentiert, \n"
"ein Projekt, dass auf dem Imperial College London entstnaden ist. \n"
"Das Ziel dieses Projekts ist es, Studenten die Arbeit mit Programmen \n"
"zur mathematischen Beweisführung näherzubringen. \n"
"Lean ist so ein Program, dass von Microsoft Research entwickelt wurde. \n"
"\n"
"Beweise einen Satz. Schreibe eine Funktion! <a href=\"https://twitter.com/"
"XenaProject\" target=\"blank\">@XenaProject</a>.\n"

#: world_config
msgid "Tutorial world"
msgstr "Tutorial Welt"

#: Tutorial world level 1
msgid "import mynat.definition -- imports the natural numbers {0,1,2,3,4,...}."
msgstr ""
"import mynat.definition -- importiert die natürlichen Zahlen {0,1,2,3,4,...}."

#: Tutorial world level 1
msgid ""
"import mynat.add -- imports definition of addition on the natural numbers."
msgstr ""
"import mynat.add -- import die Definition der Addition auf den natürlichen "
"Zahlen."

#: Tutorial world level 1
msgid ""
"import mynat.mul -- imports definition of multiplication on the natural "
"numbers."
msgstr ""
"import mynat.mul -- importiert die Definition der Multiplikation auf den "
"natürlichen Zahlen"

#: Tutorial world level 1
msgid ""
"# Tutorial World\n"
"\n"
"## Level 1: the `refl` tactic.\n"
"\n"
"Let's learn some tactics! Let's start with the `refl` tactic. `refl` stands "
"for \"reflexivity\", which is a fancy\n"
"way of saying that it will prove any goal of the form `A = A`. It doesn't "
"matter how\n"
"complicated `A` is, all that matters is that the left hand side is *exactly "
"equal* to the\n"
"right hand side (a computer scientist would say \"definitionally equal\"). I "
"really mean\n"
"\"press the same buttons on your computer in the same order\" equal.\n"
"For example, `x * y + z = x * y + z` can be proved by `refl`, but `x + y = y "
"+ x` cannot.\n"
"\n"
"Each level in this game involves proving a theorem or a lemma (a lemma is "
"just a baby theorem).\n"
"The goal of the theorem will be a mathematical statement with a `⊢` just "
"before it.\n"
"We will use tactics to manipulate and ultimately close (i.e. prove) these "
"goals.\n"
"\n"
"Let's see `refl` in action! At the bottom of the text in this box, there's a "
"lemma,\n"
"which says that if $x$, $y$ and $z$ are natural numbers then $xy + z = xy + z"
"$.\n"
"Locate this lemma (if you can't see the lemma and these instructions at the "
"same time, make this box wider\n"
"by dragging the sides). Let's supply the proof. Click on the word `sorry` "
"and then delete it.\n"
"When the system finishes being busy, you'll be able to see your goal -- the "
"objective\n"
"of this level -- in the box on the top right. [NB if your system never "
"finishes being busy, then\n"
"your computer is not running the javascript Lean which powers everything "
"behind the scenes. \n"
"Try Chrome? Try not using private browsing?] \n"
"\n"
"Remember that the goal is\n"
"the thing with the weird `⊢` thing just before it. The goal in this case is "
"`x * y + z = x * y + z`,\n"
"where `x`, `y` and `z` are some of your very own natural numbers.\n"
"That's a pretty easy goal to prove -- you can just prove it with the `refl` "
"tactic.\n"
"Where it used to say `sorry`, write\n"
"\n"
"`refl,`\n"
"\n"
"**and don't forget the comma**. Then hit enter to go onto the next line.\n"
"If all is well, Lean should tell you \"Proof complete!\" in the top right "
"box, and there\n"
"should be no errors in the bottom right box. You just did the first\n"
"level of the tutorial! And you also learnt how to avoid by *far* the most\n"
"common mistake that beginner users make -- **every line must end with a "
"comma**.\n"
"If things go weird and you don't understand why the top right box is empty,\n"
"check for missing commas. Also check you've spelt `refl` correctly: it's "
"REFL\n"
"for \"reflexivity\".\n"
"\n"
"For each level, the idea is to get Lean into this state: with the top right\n"
"box saying \"Proof complete!\" and the bottom right box empty (i.e. with no "
"errors in).\n"
"\n"
"If you want to be reminded about the `refl` tactic, you can click on the "
"\"Tactics\" drop\n"
"down menu on the left. Resize the window if it's too small. \n"
"\n"
"Now click on \"next level\" in the top right of your browser to go onto the "
"second level of\n"
"tutorial world, where we'll learn about the `rw` tactic.\n"
msgstr ""
"# Tutorial Welt \n"
"\n"
"## Level 1: Die `refl` Taktik.\n"
"\n"
"Fangen wir mit Taktiken an! Wir starten mit der 'refl' Taktik.'refl' steht "
"für \"Reflexivität\", was nur eine schlaue Art ist zu sagen, \n"
"dass jedes Ziel der Form `A = A` erfüllt wird. \n"
"Es spielt dabei keine Rolle, wie kompliziert 'A' ist. Das Einzige was zählt "
"ist, \n"
"dass die linke Seite und die rechte Seite *exakt* gleich sind! (Ein "
"Informatiker würde sagen \"nach Definition gleich\") \n"
"Ich meine wirklich: \"Drücke die gleichen Knöpfe auf deinem PC in der "
"gleichen Reihenfolge \" - gleich. \n"
"Zum Beispiel: `x * y + z = x * y + z` kann mit 'refl' bewiesen werden, aber "
"`x + y = y + x` funktioniert nicht. \n"
"\n"
"In jedem Level dieses Spiels muss ein Satz oder ein Lemma bewiesen "
"werden(ein Lemma ist nur ein Mini-Satz) \n"
"Das Ziel jedes Satzes wird ein mathematischer Ausdruck mit einem `⊢` davor "
"sein. \n"
"Wer werden Taktiken verwenden, um die Ziele zu verändern und am Ende zu "
"beweisen \n"
"\n"
"Sehen wir uns 'refl' in Aktion an! Unter diesem Text ist eine Box mit einem "
"Lemma. \n"
"Dieses Lemma behauptet: Wenn $x$, $y$ und $z$ natürliche Zahlen sind, dann "
"ist $xy + z = xy + z$. \n"
"Finde das Lemma (wenn du das Lemma und die Anweisungen nicht zur selben Zeit "
"sehen kannst, vergrößere die Box, \n"
" indem du an den Seiten ziehst). Lass uns den Beweis schreiben.Klicke auf "
"das Wort 'sorry' und lösche es. \n"
"Wenn Lean nicht mehr beschäftigt ist, wirst du dein Ziel für dieses Level in "
"der Box in der oberen rechten Ecke finden. \n"
"[Wenn das Ziel nie erscheint, dann funktioniert das javascript Lean, das "
"alles hinter den Kulissen betreibt. Versuche es mit Chrome, schalte 'private "
"browsing' aus.] \n"
"\n"
"Zur Erinnerung: Das Ziel ist das Zeug hinter dem komischen `⊢` Symbol. \n"
"In unserem Fall: `x * y + z = x * y + z`,\n"
"wobei 'x', 'y' und 'z' drei deiner eigenen natürlichen Zahlen sind. \n"
"Dieses Ziel ist recht leicht zu beweisen, du kannst es einfach mit 'refl' "
"zeigen. \n"
"Schreibe \n"
"`refl,`\n"
"\n"
"an die Stelle, an der vorher 'sorry' stand. \n"
"**vergiss nicht das Komma!** Drücke auf enter und spring zur nächsten "
"Zeile. \n"
"Wenn alles funktioniert hat, sollte Lean \"Satz bewiesen\" anzeigen. \n"
"Außerdem sollte kein Fehler mehr in der unteren rechten Box angezeigt "
"werden. \n"
"Du hast gerade dein erstes Level des Tutorials geschafft! Außerdem hast du "
"den \n"
"*mit Abstand* häufigsten Anfängerfehler kennengelernt: \n"
" **Jede Zeile muss mit einem Komma enden!** \n"
" Falls merkwürdige Dinge passieren und dir nicht klar ist, warum die Box "
"oben rechts plötzlich leer ist: sieh nach den Kommas! \n"
"Beachte außerdem, dass 'refl' richtig geschrieben ist. Es ist REFL\n"
"für \"Reflexivität\".\n"
"\n"
"Die zentrale Idee ist es, in jedem Level Lean in diesen Zustand zu "
"bringen: \n"
"Die Box oben rechts zeigt \"Satz bewiesen\" und die Box unten links ist leer "
"(also keine Fehler mehr!) \n"
"\n"
"Wenn du noch einmal an 'refl' erinnert werden möchtest, kannst du auf das "
"\"Taktik\" Menü links klicken. \n"
" Vergrößere das Fenster, wenn es zu klein ist. \n"
"\n"
"Klicke jetzt auf \"nächstes Level\" in der oberen rechten Ecke deines "
"Browsers, um zum zweiten Level der Tutorial Welt zu gelangen. \n"
"Dort werden wir die 'rw' Taktik kennenlernen.Now click on \"next level\" in "
"the top right of your browser to go onto the "

#: Tutorial world level 1
msgid "For all natural numbers $x$, $y$ and $z$, we have $xy + z = xy + z$.\n"
msgstr "Für alle natürlichen Zahlen $x$, $y$ und $z$ gilt: $xy + z=xy +z$. \n"

#: Tutorial world level 1
msgid ""
"\n"
"## Summary\n"
"\n"
"`refl` proves goals of the form `X = X`.\n"
"\n"
"## Details\n"
"\n"
"The `refl` tactic will close any goal of the form `A = B`\n"
"where `A` and `B` are *exactly the same thing*.\n"
"\n"
"### Example:\n"
"If it looks like this in the top right hand box:\n"
"```\n"
"a b c d : mynat\n"
"⊢ (a + b) * (c + d) = (a + b) * (c + d)\n"
"```\n"
"\n"
"then\n"
"\n"
"`refl,`\n"
"\n"
"will close the goal and solve the level. Don't forget the comma.\n"
"\n"
msgstr ""
"\n"
"## Zusammenfassung\n"
"\n"
"`refl` beweist Ziele der Form `X = X`.\n"
"\n"
"## Details\n"
"\n"
"Die`refl` Taktik wird alle Ziele der Form `A = B abschließen, `\n"
"wenn `A` und `B` *exakt gleich* sind.\n"
"\n"
"### Beispiel:\n"
"Wenn die Box oben rechts so aussieht: \n"
"```\n"
"a b c d : mynat\n"
"⊢ (a + b) * (c + d) = (a + b) * (c + d)\n"
"```\n"
"\n"
"dann wird\n"
"\n"
"`refl,`\n"
"\n"
"das Ziel erfüllen und das Level lösen. Vergiss das Komma nicht! \n"
"\n"

#: Tutorial world level 2
msgid ""
"# Tutorial world\n"
"\n"
"## level 2: The rewrite (`rw`) tactic.\n"
"\n"
"The rewrite tactic is the way to \"substitute in\" the value\n"
"of a variable. In general, if you have a hypothesis of the form `A = B`, and "
"your\n"
"goal mentions the left hand side `A` somewhere, then\n"
"the `rewrite` tactic will replace the `A` in your goal with a `B`.\n"
"Below is a theorem which cannot be\n"
"proved using `refl` -- you need a rewrite first.\n"
"\n"
"Delete the sorry and take a look in the top right box at what we have.\n"
"The variables $x$ and $y$ are natural numbers, and we have\n"
"a proof `h` that $y = x + 7$. Our goal\n"
"is to prove that $2y=2(x+7)$. This goal is obvious -- we just\n"
"substitute in $y = x+7$ and we're done. In Lean, we do\n"
"this substitution using the `rw` tactic. So start your proof with \n"
"\n"
"`rw h,`\n"
"\n"
"and then hit enter. **Don't forget the comma.**\n"
"Did you see what happened to the goal? The goal doesn't close,\n"
"but it *changes* from `⊢ 2 * y = 2 * (x + 7)` to `⊢ 2 * (x + 7) = 2 * (x + "
"7)`.\n"
"We can just close this goal with\n"
"\n"
"`refl,`\n"
"\n"
"by writing it on the line after `rw h,`. Don't forget the comma, hit\n"
"enter, and enjoy seeing the \"Proof complete!\" message in the\n"
"top right window. The other reason you'll know you're\n"
"done is that the bottom right window (the error window)\n"
"becomes empty. When you've finished reading the comments below\n"
"the proof, click \"Next Level\" in the top right to proceed to the next\n"
"level in this world.\n"
"\n"
msgstr ""
"# Tutorial Welt\n"
"\n"
"## Level 2: Die Umschreiben (`rw`) Taktik (von 'rewrite').\n"
"\n"
"Mit dem Umschreiben kann der Wert einer Variablen \"ersetzt\" werden. \n"
"Grundlegend gilt: wenn du eine Hypothese der Form 'A = B' hast und dein "
"Ziel\n"
"erwähnt auf der linken Seite irgendwo 'A', dann wird 'rw' das 'A' in deinem "
"Ziel mit einem 'B' ersetzen. \n"
"Unter diesem Text ist ein Satz, der nicht mit 'refl' bewiesen werden kann. \n"
"Du musst es zuerst umschreiben. \n"
"\n"
"Lösche das 'sorry' und sieh dir zuerst die Box oben rechts an. \n"
"Die Variablen $x$ und $y$ sind natürlichen Zahlen und wir sehen einen Beweis "
"'h', der  $y = x + 7$ zeigt. \n"
"Unser Ziel ist es zu zeigen, dass gilt: $2y=2(x+7)$ \n"
"Das Ziel ist klar, wir müssen nur $y = x+7$ einsetzen (also y ersetzen) und "
"wir sind fertig. \n"
"In Lean erreichen wir das, indem wir 'rw' verwenden. Beginne also mit \n"
"is to prove that $2y=2(x+7)$. This goal is obvious -- we just\n"
"\n"
"`rw h,`\n"
"\n"
"und drücke auf enter. **Vergiss das Komma nicht.**\n"
"Hast du gesehen, was mit dem Ziel passiert ist? Es ist nicht erfüllt, \n"
"aber es hat sich *verändert*, von `⊢ 2 * y = 2 * (x + 7)` zu `⊢ 2 * (x + 7) "
"= 2 * (x + 7)` \n"
"Dieses Ziel können wir aber leicht mit \n"
"\n"
"`refl,`\n"
"\n"
"erfüllen, indem wir es in die nächste Zeile nach 'rw h' schreiben. \n"
"Vergiss das Komma nicht und bestätige, dann kannst du die Nachricht \n"
"\"Satz bewiesen \" oben rechts genießen. \n"
"Ein zweiter Hinweis, dass du fertig bist ist, dass die Fehlerbox unten links "
"leer ist. \n"
"Wenn du die Kommentare unter dem Beweis gelesen hast, dann klicke auf "
"\"Nächstes Level\" oben rechts, \n"
"um zum nächsten Level dieser Welt weiterzugehen.\n"

#: Tutorial world level 2
msgid ""
"If $x$ and $y$ are natural numbers, \n"
"and $y=x+7$, then $2y=2(x+7)$. \n"
msgstr ""
"Sind $x$ und $y$ natürliche Zahlen und gilt:  \n"
"$y=x+7$, dann ist $2y = 2(x+7)$. \n"

#: Tutorial world level 2
msgid ""
"\n"
"## Summary\n"
"\n"
"If `h` is a proof of `X = Y`, then `rw h,` will change\n"
"all `X`s in the goal to `Y`s. Variants: `rw ← h` (changes\n"
"`Y` to `X`) and\n"
"`rw h at h2` (changes `X` to `Y` in hypothesis `h2` instead\n"
"of the goal).\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do \"substituting in\". There\n"
"are two distinct situations where use this tactics.\n"
"\n"
"1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\n"
"in your local context (the box in the top right)\n"
"and if your goal contains one or more `A`s, then `rw h`\n"
"will change them all to `B`'s. \n"
"\n"
"2) The `rw` tactic will also work with proofs of theorems\n"
"which are equalities (look for them in the drop down\n"
"menu on the left, within Theorem Statements).\n"
"For example, in world 1 level 4\n"
"we learn about `add_zero x : x + 0 = x`, and `rw add_zero`\n"
"will change `x + 0` into `x` in your goal (or fail with\n"
"an error if Lean cannot find `x + 0` in the goal).\n"
"\n"
"Important note: if `h` is not a proof of the form `A = B`\n"
"or `A ↔ B` (for example if `h` is a function, an implication,\n"
"or perhaps even a proposition itself rather than its proof),\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw (P = Q)` is never correct: `P = Q` is the true-false\n"
"statement itself, not the proof.\n"
"If `h : P = Q` is its proof, then `rw h` will work.\n"
"\n"
"Pro tip 1: If `h : A = B` and you want to change\n"
"`B`s to `A`s instead, try `rw ←h` (get the arrow with `\\l` and\n"
"note that this is a small letter L, not a number 1).\n"
"\n"
"### Example:\n"
"If it looks like this in the top right hand box:\n"
"```\n"
"x y : mynat\n"
"h : x = y + y\n"
"⊢ succ (x + 0) = succ (y + y)\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw add_zero,`\n"
"\n"
"will change the goal into `⊢ succ x = succ (y + y)`, and then\n"
"\n"
"`rw h,`\n"
"\n"
"will change the goal into `⊢ succ (y + y) = succ (y + y)`, which\n"
"can be solved with `refl,`.\n"
"\n"
"### Example: \n"
"You can use `rw` to change a hypothesis as well. \n"
"For example, if your local context looks like this:\n"
"```\n"
"x y : mynat\n"
"h1 : x = y + 3\n"
"h2 : 2 * y = x\n"
"⊢ y = 3\n"
"```\n"
"then `rw h1 at h2` will turn `h2` into `h2 : 2 * y = y + 3`.\n"
msgstr ""
"\n"
"## Zusammenfassung\n"
"\n"
"Wenn 'h' ein Beweis für 'X = Y' ist, dann wird 'rw h' alle 'X'e im Ziel zu "
"'Y' umschreiben. \n"
"Varianten: `rw ← h` (schreibt 'Y' zu 'X' um). \n"
"'rw h at h2 (schreibt 'X' zu 'Y' in Hypothese 'h2' an Stelle desZiels um) \n"
"\n"
"## Details\n"
"\n"
"Die 'rw' Taktik ist ein weg, um etwas zu \"ersetzen \". Es gibt \n"
"zwei verschiedenen Situationen, um sie einzusetzen. \n"
"\n"
"1) Wenn 'h: A = B' eine Hypothese in deinem Kontext ist \n"
"(zum Beispiel ein Beweis für 'A = B' oben rechts) \n"
"und eines deiner Ziele eines oder mehr 'A's enthält, \n"
"dann wird 'rw h' sie alle zu 'B' umschreiben. \n"
"\n"
"2) 'rw' funktioniert auch bei Beweisen von Sätzen, \n"
"die Gleichungen sind (sie sind im Dropdown Menü \n"
"auf der linken Seite zu finden). \n"
"Zum Beispiel lernen wir in Welt 1, Level 4 \n"
"`add_zero x : x + 0 = x` und 'rw add_zero' \n"
"ersetzt im Ziel 'x + 0' mit 'x' (oder geht \n"
"in einen Fehlerzustand um, wenn Lean kein \n"
"'x + 0' im Ziel findet). \n"
"\n"
"Wichtig: wenn 'h' kein Beweis der Form 'A = B' oder \n"
"`A ↔ B` ist (zum Beispiel könnte 'h' eine Funktion, eine Implikation oder "
"vielleicht eine Aussage und nicht \n"
"ihr Beweis sein), dann sollte 'rw' nicht verwendet werden. \n"
"Zum Beispiel ist 'rw (P = Q)' ist niemals richtig: \n"
"'P = Q' ist selbst eine Wahr-Falsch-Aussage, \n"
"nicht der Beweis. \n"
"Wenn 'h : P = Q' der zugehörige Beweis ist, dann \n"
"funktioniert es. \n"
"\n"
"Profi Tipp 1: Wenn gilt: 'h : A = B' und du \n"
"'B's zu 'A's ersetzen willst, versuche es mit \n"
"`rw ←h` (der Pfeil kann mit '\\l' geschrieben werden, \n"
"es ist ein kleines L und keine 1). \n"
"\n"
"### Beispiel:\n"
"Wenn die Box oben rechts so aussieht: \n"
"```\n"
"x y : mynat\n"
"h : x = y + y\n"
"⊢ succ (x + 0) = succ (y + y)\n"
"```\n"
"\n"
"dann wird\n"
"\n"
"`rw add_zero,`\n"
"\n"
"das Ziel zu `⊢ succ x = succ (y + y)` umschreiben \n"
"und dann wird\n"
"\n"
"`rw h,`\n"
"\n"
"das Ziel zu `⊢ succ (y + y) = succ (y + y)` umschreiben, \n"
" was mit 'refl' bewiesen werden kann. \n"
"\n"
"### Beispiel: \n"
"'rw' kann auch für Hypothesen verwendet werden. \n"
"Sieht die Box oben rechts so aus: \n"
"```\n"
"x y : mynat\n"
"h1 : x = y + 3\n"
"h2 : 2 * y = x\n"
"⊢ y = 3\n"
"```\n"
"Dann wird `rw h1 at h2``h2` zu \n"
"`h2 : 2 * y = y + 3` umschreiben.\n"

#: Tutorial world level 2
msgid ""
"\n"
"## Exploring your proof.\n"
"\n"
"Click on `refl,` and then use the arrow keys to move\n"
"your cursor around the proof. Go up and down and note that\n"
"the goal changes -- indeed you can inspect Lean's \"state\" at each\n"
"line of the proof (the hypotheses, and the goal).\n"
"Try to figure out the exact place where the goal changes.\n"
"The comma tells Lean \"I've finished writing this tactic now,\n"
"please process it.\" Lean ignores newlines, but pays great\n"
"attention to commas.\n"
"\n"
"## The tactic index\n"
"\n"
"The documentation for `rw` just appeared in the list of tactics\n"
"in the box on the left. Play around with the menus on the left\n"
"and see what is there currently. More information will appear as you "
"progress.\n"
"\n"
"## Bewildered?\n"
"\n"
"Doesn't work? Weird error that won't go away? You can check out\n"
"the \n"
"<a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/"
"master/SOLUTIONS.md\"\n"
"  target=\"blank\">solutions</a> (github.com, opens in new window).\n"
"  Solutions to every level are here.\n"
msgstr ""
"\n"
"## Erkunde deinen Beweis!\n"
"\n"
"Klicke auf 'refl' und benutze die Pfeiltasten, um den Cursor \n"
"durch den Beweis zu bewegen. Gehe auf und ab und du wirst \n"
"feststellen, dass sich das Ziel verändert. \n"
"Du kannst Leans \"Zustand\" in jeder Zeile des Beweises \n"
"(der Hypothese und dem Ziel) untersuchen. \n"
"Versuche genau herauszufinden, wo das Ziel sich verändert. \n"
"Das Komma erklärt Lean \"Ich habe diese Taktik fertig angewendet, \n"
"bitte wende sie jetzt an. \". Lean ignoriert Leerzeilen, \n"
"aber es passt sehr genau auf Kommas auf. \n"
"\n"
"## Die Taktik Liste\n"
"\n"
"Die Dokumentation für 'rw' ist gerade in der Liste der Taktiken auf der \n"
"linken Seite erschienen. Teste die Menüs und erkunde ihren derzeitigen "
"Inhalt.\n"
"Der Inhalt wird ergänzt, sobald du Fortschritte machst. \n"
"\n"
"## Verwirrt?\n"
"\n"
"Es funktioniert nicht? Seltsamer Fehler, der nicht weggeht? \n"
"Du findest hier \n"
"<a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/"
"master/SOLUTIONS.md\"\n"
"  target=\"blank\">Lösungen</a> (github.com, opens in new window).\n"
"  Lösungen für jedes Level.\n"

#: Tutorial world level 3
msgid ""
"We just restarted Lean behind the scenes,\n"
"so let's re-import the natural numbers, but this time without\n"
"addition and multiplication.\n"
msgstr ""
"Wir haben gerade Lean im Hintergrund neu gestartet, \n"
"lass uns also die natürlichen Zahlen neu importiert, aber dieses Mal \n"
"ohne Addition und Multiplikation."

#: Tutorial world level 3
msgid ""
"import mynat.definition -- import Peano's definition of the natural numbers "
"{0,1,2,3,4,...}"
msgstr ""
"import mynat.definition -- importiert die Definition nach den Peano Axiomen."

#: Tutorial world level 3
msgid ""
"\n"
"# Tutorial world\n"
"\n"
"## Level 3: Peano's axioms.\n"
"\n"
"The import above gives us the type `mynat` of natural numbers. But it\n"
"also gives us some other things, which we'll take a look at now:\n"
"\n"
"  * a term `0 : mynat`, interpreted as the number zero.\n"
"  * a function `succ : mynat → mynat`, with `succ n` interpreted as \"the "
"number after $n$\".\n"
"  * The principle of mathematical induction.\n"
"\n"
"These axioms are essentially the axioms isolated by Peano which uniquely "
"characterise\n"
"the natural numbers (we also need recursion, but we can ignore it for now).\n"
"The first axiom says that $0$ is a natural number. The second says that "
"there\n"
"is a `succ` function which eats a number and spits out the number after it,\n"
"so $\\operatorname{succ}(0)=1$, $\\operatorname{succ}(1)=2$ and so on.\n"
"\n"
"Peano's last axiom is the principle of mathematical induction. This is a "
"deeper\n"
"fact. It says that if we have infinitely many true/false statements $P(0)$, "
"$P(1)$,\n"
"$P(2)$ and so on, and if $P(0)$ is true, and if for every natural number $d"
"$\n"
"we know that $P(d)$ implies $P(\\operatorname{succ}(d))$, then $P(n)$ must "
"be true for every\n"
"natural number $n$. It's like saying that if you have a long line of "
"dominoes, and if\n"
"you knock the first one down, and if you know that if a domino falls down "
"then the one\n"
"after it will fall down too, then you can deduce that all the dominos will "
"fall down.\n"
"One can also think of it as saying that every natural number\n"
"can be built by starting at `0` and then applying `succ` a finite number of "
"times.\n"
"\n"
"Peano's insights were firstly that these axioms completely characterise\n"
"the natural numbers, and secondly that these axioms alone can be used to "
"build\n"
"a whole bunch of other structure on the natural numbers, for example\n"
"addition, multiplication and so on.\n"
"\n"
"This game is all about seeing how far these axioms of Peano can take us.\n"
"\n"
"Let's practice our use of the `rw` tactic in the following example.\n"
"Our hypothesis `h` is a proof that `succ(a) = b` and we want to prove that\n"
"`succ(succ(a))=succ(b)`. In words, we're going to prove that if\n"
"`b` is the number after `a` then `succ(b)` is the number after `succ(a)`. \n"
"Now here's a tricky question. If our goal is `⊢ succ (succ a) = succ b`,\n"
"and our hypothesis is `h : succ a = b`, then what will the goal change\n"
"to when we type\n"
"\n"
"`rw h,`\n"
"\n"
"and hit enter whilst not forgetting the comma? Remember that `rw h` will\n"
"look for the *left* hand side of `h` in the goal, and will replace it with\n"
"the *right* hand side. Try and figure out how the goal will change, and\n"
"then try it.\n"
"\n"
"The answer: Lean changed `succ a` into `b`, so the goal became `succ b = "
"succ b`.\n"
"That goal is of the form `X = X`, so you can prove this new goal with\n"
"\n"
"`refl,`\n"
"\n"
"on the line after `rw h,`. Don't forget the commas!\n"
"\n"
"**Important note** : the tactic `rw` expects\n"
"a proof afterwards (e.g. `rw h1`). But `refl` is just `refl`.\n"
"Note also that the system sometimes drops brackets when they're not\n"
"necessary, and `succ b` just means `succ(b)`. \n"
"\n"
"You may be wondering whether we could have just substituted in the "
"definition of `b`\n"
"and proved the goal that way. To do that, we would want to replace the right "
"hand\n"
"side of `h` with the left hand side. You do this in Lean by writing `rw ← "
"h`. You get the\n"
"left-arrow by typing `\\l` and then a space; note that this is a small "
"letter L,\n"
"not a number 1. You can just edit your proof and try it. \n"
"\n"
"You may also be wondering why we keep writing `succ(b)` instead of `b+1`. "
"This\n"
"is because we haven't defined addition yet! On the next level, the final "
"level\n"
"of Tutorial World, we will introduce addition, and then\n"
"we'll be ready to enter Addition World.\n"
msgstr ""
"\n"
"# Tutorial Welt\n"
"\n"
"## Level 3: Die Axiome von Peano.\n"
"\n"
"Der obige Import gibt uns den Typ 'mynat' der natürlichen Zahlen. \n"
"Wir bekommen dadurch aber auch einige andere Dinge, die wir jetzt ansehen: \n"
"\n"
" * einen Term '0 : mynat', interpretierbar als die Zahl 0. \n"
" * eine Funktion 'succ : mynat → mynat', die 'succ n' als \"die Zahl nach $n$"
"\" interpretiert. \n"
"  (von 'successor') * Die Technik der vollständigen induktion. \n"
"\n"
"Diese Axiome sind im Wesentlichen die Axiome von Peano, die eindeutig  die "
"natürlichen Zahlen \n"
" charakterisieren (Wir brauchen auch Rekursion, aber das ignorieren wir erst "
"einmal).\n"
"Das erste Axiom bestimmt, dass $0$ eine natürliche Zahl ist. Das zweite "
"Axiom legt fest,\n"
"dass es eine Funktion 'succ' gibt, die eine natürliche Zahl frisst und die "
"nächste \n"
"Zahl ausspuckt, also ist $\\operatorname{succ}(0)=1$, $\\operatorname{succ}"
"(1)=2$ und so weiter.\n"
"\n"
"Das letzte Axiom von Peano ist das Prinzip der vollständigen Induktion. \n"
"Bei diesem Axiom handelt es sich um tiefgreifendere Tatsache. Es geht "
"darum, \n"
"dass wir unendlich viele Aussagen $P(0)$, $P(1)$, usw. haben, \n"
"wahr oder falsch sein können. Wenn $P(0)$ wahr ist und wir gleichzeitig \n"
"für jede natürliche Zahl $d$ wissen, dass $P(d)$ $P(\\operatorname{succ}"
"(d))$ impliziert,\n"
"dann muss $P(n)$ für jede natürliche Zahl $n$ wahr sein. \n"
"Die Argumentation entspricht etwa dem Folgenden: \n"
"Wir haben eine lange Reihe von Dominosteinen und wissen, dass der erste "
"Stein fällt. \n"
"Außerdem wissen wir, dass aus dem Fall eines Dominosteins, der Fall des "
"nächsten folgt. \n"
"Daraus können wir folgern, dass alle Steine fallen werden. \n"
"Man könnte es auch so sehen: Wir können jede beliebige natürliche Zahl "
"bauen, \n"
"indem wir bei der '0' anfangen und dann endlich oft 'succ' anwenden. \n"
"\n"
"Peano erkannte erstens, dass die natürlichen Zahlen durch die Axiome völlig "
"beschrieben werden. \n"
"Zweitens, dass diese Axiome allein schon ausreichen, um viele andere "
"Strukturen \n"
"auf den natürlichen Zahlen zu definieren, zum Beispiel die Addition, die "
"Multiplikation, etc. \n"
"\n"
"In diesem Spiel geht es darum zu sehen, wie weit wir mit Peanos Axiomen "
"kommen. \n"
"\n"
"Üben wir die Verwendung von 'rw' mit einem Beispiel. \n"
"Unsere Hypothese 'h' ist der Beweis dafür, dass gilt: 'succ(a)=b'. \n"
" Wir wollen jetzt 'succ(succ(a))=succ(b)' zeigen. In Worten bedeutet dies: \n"
" \"Wenn 'b' die Zahl nach 'a' ist, dann ist 'succ(b)' die Zahl nach "
"'succ(a)'. \n"
"Jetzt eine spannende Frage - wenn unser Ziel `⊢ succ (succ a) = succ b` "
"und \n"
"unsere Hypothese `h : succ a = b` ist, wie wird unser Ziel aussehen, wenn "
"wir \n"
"\n"
"`rw h,`\n"
"\n"
"eingeben und auf Enter drücken (sofer wir das Komma nicht vergessen "
"haben)? \n"
" Zur Erinnerung: 'rw h' wird die *linken' Seite von 'h' im Ziel suchen und \n"
"sie mit der *rechten* Seite ersetzen. Versuche zuerst, die Veränderung "
"vorherzusehen \n"
"und probiere es dann einfach aus. \n"
"\n"
"Die Antwort: Lean hat 'succ a' zu 'b' umgeschrieben, also ist das neue "
"Ziel'succ b = succ b'. \n"
"Dieses Ziel hat die Form `X = X`, kann also mit \n"
"`refl,`\n"
"\n"
" in der Zeile nach `rw h,` bewiesen werde. Vergiss die Kommas nicht!\n"
"\n"
"**Wichtig**: um die Taktik `rw`anwenden zu können, muss ein Beweis folgen (z."
"B. 'rw h1'). Aber `refl`bleibt einfach `refl`. \n"
"Außerdem wird Lean manchmal Klammern schreiben, die nicht notwendig sind. "
"`succ b`bedeutet einfach `succ(b)`. \n"
"\n"
"Du fragst dich vielleicht, ob wir nicht einfach die Definition von `b` "
"einsetzen hätten können \n"
"und so das Ziel beweisen. Um das zu schaffen, könnten wir die rechte Seite \n"
"von `h`mit der linken Seite ersetzen. Das können wir mit `rw ←h` \n"
"Der Pfeil nach links kann durch `\\l` geschrieben werden. Der Buchstabe "
"ist \n"
"ein kleines L und keine 1. Ändere deinen Beweis und versuche es. \n"
"\n"
"Du könntest dich auch fragen, warum wir `succ(b)* anstelle von `b"
"+1`schreiben. \n"
"Das liegt daran, dass wir Addition noch nicht definiert haben! \n"
"Im nächsten Level, dem Bosslevel der Tutorial Welt, werden wir Addition "
"einführen. \n"
"Anschließend sind wir bereit uns in die Welt der Addition zu stürzen. \n"

#: Tutorial world level 3
msgid ""
"If $\\operatorname{succ}(a) = b$, then\n"
"$$\\operatorname{succ}(\\operatorname{succ}(a)) = \\operatorname{succ}(b).$"
"$\n"
msgstr ""
"Wenn $\\operatorname{succ}(a) = b$ gilt, dann folgt \n"
"$$\\operatorname{succ}(\\operatorname{succ}(a)) = \\operatorname{succ}(b).$"
"$\n"

#: Tutorial world level 4
msgid "import mynat.add -- definition of addition"
msgstr "import mynat.add -- Definition der Addition"

#: Tutorial world level 4
msgid ""
"# Tutorial world\n"
"\n"
"## Level 4: addition\n"
"\n"
"We have a new import -- the definition of addition.\n"
"\n"
"Peano defined addition `a + b` by induction on `b`, or,\n"
"more precisely, by *recursion* on `b`. He first explained how to add 0 to a "
"number:\n"
"this is the base case.\n"
"\n"
"* `add_zero (a : mynat) : a + 0 = a`\n"
"\n"
"We will call this theorem `add_zero`. More precisely, `add_zero` is the "
"name\n"
"of the *proof* of the theorem. **Note the name of this proof**.\n"
"Mathematicians sometimes call it \"Lemma 2.1\" or \"Hypothesis P6\" or "
"something. But\n"
"computer scientists call it `add_zero` because it tells you\n"
"what the answer to \"$x$ add zero\" is. It's a *much* better name than "
"\"Lemma 2.1\".\n"
"Even better, we can use the rewrite tactic with `add_zero`.\n"
"If you ever see `x + 0` in your goal, `rw add_zero` should simplify it to "
"`x`.\n"
"This is because `add_zero` is a proof that `x + 0 = x` (more precisely,\n"
"`add_zero x` is a proof that `x + 0 = x` but Lean can figure out the `x` "
"from the context).\n"
"\n"
"Now here's the inductive step. If you know how to add `d` to `a`, then\n"
"Peano tells you how to add `succ(d)` to `a`. It looks like this:\n"
"\n"
"* `add_succ (a d : mynat) : a + succ(d) = succ (a + d)`\n"
"\n"
"What's going on here is that we assume `a + d` is already\n"
"defined, and we define `a + succ(d)` to be the number after it.\n"
"**Note the name of this proof too** -- `add_succ` tells you\n"
"how to add a successor to something. If you ever see `... + succ ...`\n"
"in your goal, you should be able to use `rw add_succ,` to make\n"
"progress. Here is a simple example where we shall see both. Let's prove\n"
"that $x$ add the number after $0$ is the number after $x$.\n"
"\n"
"Delete `sorry` (don't forget you can widen this box if you can't see the "
"sorry).\n"
"Observe that the goal mentions `... + succ ...`. So type\n"
"\n"
"`rw add_succ,`\n"
"\n"
"and hit enter; see the goal change. **Don't forget the commma**.\n"
"Do you see that the goal now mentions ` ... + 0 ...`? So type\n"
"\n"
"`rw add_zero,`\n"
"\n"
"and then observe that you can close the goal with\n"
"\n"
"`refl,`\n"
"\n"
"and you're done. You have finished tutorial world! There are important "
"things\n"
"written below the lemma, including what to do next.\n"
"\n"
msgstr ""
"# Tutorial Welt\n"
"\n"
"## Level 4: Addition\n"
"\n"
"Wir haben einen neuen Import - die Definition der Addition. \n"
"\n"
"Peano definiert die Addition `a + b` durch vollständige Induktion über "
"`b`, \n"
"oder etwas genauer gesagt, durch *Rekursion* über `b`. \n"
"Er erklärt zuerst, wie man 0 zu einer Zahl addiert: \n"
"Dies ist unser Basisfall (auch Induktionsanfang genannt). \n"
"\n"
"* `add_zero (a : mynat) : a + 0 = a`\n"
"\n"
"Wir nennen diesen Satz `add_zero`. Genauer gesagt, `add_zero` ist der Name \n"
"des *Beweises* des Satzes. **Notiere dir den Namen dieses Beweises**. \n"
"Mathematiker nennen ihn manchmal \"Lemma 2.1\" oder \"Hypothese P6\" oder "
"etwas Ähnliches. \n"
"Aber Informatiker nennen es `add_zero`, weil dieser Name dir sagt, was die "
"Antwort auf die Frage \"$x$ addiere Null\" ist. \n"
"Es ist ein wesentlich *besserer* Name als \"Lemma 2.1\". \n"
"Noch besser ist, wir können `rw`mit `add_zero` verwenden. \n"
"Wenn du jemals `x + 0` im Ziel siehst wird `rw add_zero` das zu `x` "
"vereinfachen. \n"
"Das liegt daran, dass `add_zero` ein Beweis für `x + 0 = x`` ist \n"
"(Genauer gesagt ist `add_zero x` der Beweis für `x + 0 = x`, aber Lean kann "
"`x`aus dem Kontext erschließen). \n"
"\n"
"Jetzt kommen wir zum Induktionsschritt. Wenn bekannt ist, wie man `d` zu `a` "
"addiert, \n"
"dann weiß sagt uns Peano, wie man `succ(d)` zu `a` addiert, das sieht so "
"aus: \n"
"\n"
"* `add_succ (a d : mynat) : a + succ(d) = succ (a + d)`\n"
"\n"
"Wir nehmen an, `a + d` ist schon definiert und definieren weiterhin \n"
"`a + succ(d)` als die Zahl danach. \n"
"** Beachte auch den Namen dieses Beweises** -- `ad_succ` verrät dir, \n"
"wie man einen Nachfolger zu etwas addiert. Wenn du jemals etwas wie `... + "
"succ ...` \n"
"in deinem Ziel siehst, solltest du 'rw add_succ' verwenden können, um "
"Fortschritte zu machen. \n"
"Es folgt ein einfaches Beispiel, um beides zu demonstrieren. Wir beweisen: \n"
"Wenn wir zu $x$ den Nachfolger von $0$ addieren, ergibt sich der Nachfolger "
"von $x$. \n"
"\n"
"Lösche das `sorry` (Vergiss nicht: du kannst diese Box vergrößeren, wenn du "
"es nicht siehst). \n"
"Du kannst sehen, dass das Ziel `... + succ ... ` enthält. Gib \n"
"`rw add_succ,`\n"
"\n"
"ein und drücke auf enter, du wirst sehen, dass sich das Ziel verändert. \n"
"**Vergiss das Komma nicht!** \n"
"Siehst du, dass das Ziel jetzt `... + 0 ...` enthält? Wir schreiben \n"
"\n"
"`rw add_zero,`\n"
"\n"
"und sofort kann man sehen, dass man das Ziel mit \n"
"\n"
"`refl,`\n"
"\n"
"erfüllen kann. Wir sind fertig! Du hast die Tutorial Welt abgeschlossen! \n"
"Unter diesem Lemma findest du einige wichtige Dinge, insbesondere wie es "
"weiter geht.\n"

#: Tutorial world level 4
msgid ""
"For all natural numbers $a$, we have\n"
"$$a + \\operatorname{succ}(0) = \\operatorname{succ}(a).$$\n"
msgstr ""
"Für alle natürlichen Zahlen $a$ gilt: $$a + \\operatorname{succ}(0) = "
"\\operatorname{succ}(a).$$\n"

#: Tutorial world level 4
msgid ""
"## Examining proofs.\n"
"\n"
"You might want to review this proof now; at\n"
"three lines long it is our current record. Click on a line in the proof\n"
"and use the L/R arrow keys to put your cursor as far left as it will go.\n"
"Then use the U/D arrow keys to move your cursor\n"
"up and down from line to line, and you can see what\n"
"Lean is thinking on each line of the proof.\n"
"\n"
"## No problems?\n"
"\n"
"When you're happy, let's move onto Addition World, and\n"
"learn about proof by induction. Go back to the main menu and select addition "
"world.\n"
"\n"
"## Problems?\n"
"\n"
"Question: why has the top right hand box gone blank?\n"
"\n"
"Answer: Maybe you tried a tactic which didn't work. Or maybe you're\n"
"in the middle of typing a tactic. Try deleting up to the last\n"
"comma, *or adding a comma at the end of your code*. Look at the\n"
"error message. What line is the first error on? Perhaps\n"
"Lean thinks you're in the middle of writing a tactic command that you\n"
"think you finished. If Lean is still attempting to process a tactic\n"
"command it won't display anything. You can get it to stop processing by\n"
"adding a comma. \n"
"\n"
"If the worst comes to the worst, just delete what you wrote. Most people\n"
"with problems have written random stuff in the proof box. The only thing\n"
"you're supposed to be writing is lines like\n"
"\n"
"`rw add_zero,`\n"
"`rw h,`\n"
"`refl,`\n"
"\n"
"One line of code with a comma at the end. Nothing else at all goes in the "
"box.\n"
"\n"
"If you cannot see what you have done wrong, you can always\n"
"<a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/"
"master/SOLUTIONS.md\"\n"
"  target=\"blank\">take a look at the solutions</a> (github.com, opens in "
"new window).\n"
msgstr ""
"## Beweise überprüfen.\n"
"\n"
"Vielleicht möchtest du diesen Beweis jetzt noch einmal ansehen. \n"
"Mit drei Zeilen ist er unser bisheriger Rekordhalter. Klicke auf eine Zeile "
"im Beweis \n"
"und verwende die Pfeiltasten, um den Cursor so weit wie möglich nach links "
"zu schieben. \n"
"Wenn du dann nach oben und unten von Zeile zu Zeile navigierst \n"
"kannst du sehen, was Lean über jede Zeile des Beweises denkt. \n"
"\n"
"## Keine Probleme?\n"
"\n"
"Wenn du glücklich mit allem bist geht es weiter zur Welt der Addition. \n"
"Dort lernen wir mehr über das Beweisen mit Hilfe der Induktion. \n"
"Geh zurück zum Hauptmenü und wähle die 'Welt der Addition'. \n"
"\n"
"## Probleme?\n"
"\n"
"Frage: warum ist die Box oben rechts leer? \n"
"\n"
"Antwort: vielleicht hast du eine Taktik verwendet, die nicht funktioniert. \n"
"Oder vielleicht hast du eine Taktik noch nicht abgeschlossen. Versuche "
"alles \n"
"bis zum letzten Komma zu löschen *oder füge ein Komma am Ende deines Codes "
"hinzu!* \n"
"Sieh dir die Fehlermeldung an. In welcher Zeile ist der erste Fehler? \n"
"Vielleicht denkt Lean du bist noch in einer Taktik, von der du denkst, \n"
"du hättest sie bereits abgeschlossen. Wenn Lean immer noch versucht, \n"
"einen Befehl auszuführen, dann wird es nichts anzeigen. \n"
"Du kannst Lean dazu zwingen, aufzuhören, indem du ein Komma hinzufügst. \n"
"\n"
"Wenn es zum Schlimmsten kommt: lösche, was du geschrieben hast. Die "
"meisten \n"
"Leute mit Problemen haben irgendetwas unpassendes in die Beweisbox "
"geschrieben. \n"
"Das Einzige, was in die Box gehört sind Zeilen wie: \n"
"\n"
"`rw add_zero,`\n"
"`rw h,`\n"
"`refl,`\n"
"\n"
"Jede Zeile endet mit einem Komma. Nichts anderes kommt in die Box! \n"
"\n"
"Wenn du nicht verstehst, was falsch ist, kannst du immer noch \n"
"<a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/"
"master/SOLUTIONS.md\"\n"
"  target=\"blank\">die Lösungen ansehen. </a> (github.com, öffnet in  einem "
"neuen Fenster).\n"

#: world_config
msgid "Addition world"
msgstr "Welt der Addition"

#: Addition world level 1
msgid "import mynat.definition -- Imports the natural numbers."
msgstr "import mynat.definition -- importiert die natürlichen Zahlen."

#: Addition world level 1
msgid "import mynat.add -- imports addition."
msgstr "import mynat.add -- import die Addition."

#: Addition world level 1
msgid ""
"\n"
"## Summary\n"
"\n"
"if `n : mynat` is in our assumptions, then `induction n with d hd`\n"
"attempts to prove the goal by induction on `n`, with the inductive\n"
"assumption in the `succ` case being `hd`.\n"
"\n"
"## Details\n"
"\n"
"If you have a natural number `n : mynat` in your context\n"
"(above the `⊢`) then `induction n with d hd` turns your\n"
"goal into two goals, a base case with `n = 0` and\n"
"an inductive step where `hd` is a proof of the `n = d`\n"
"case and your goal is the `n = succ(d)` case.\n"
"\n"
"### Example:\n"
"If this is our local context:\n"
"```\n"
"n : mynat\n"
"⊢ 2 * n = n + n\n"
"```\n"
"\n"
"then\n"
"\n"
"`induction n with d hd`\n"
"\n"
"will give us two goals:\n"
"\n"
"```\n"
"⊢ 2 * 0 = 0 + 0\n"
"```\n"
"\n"
"and\n"
"```\n"
"d : mynat,\n"
"hd : 2 * d = d + d\n"
"⊢ 2 * succ d = succ d + succ d\n"
"```\n"
"\n"
msgstr ""
"\n"
"## Zusammenfassung\n"
"\n"
"Wenn unsere Annahme `n : mynat` ist, dann wird  `induction n with d hd` \n"
"versuchen das Ziel mit Induktion über `n`zu lösen, wobei die Annahme der "
"Induktion \n"
"im Fall von `succ` mit `hd` bezeichnet wird. \n"
"\n"
"## Details\n"
"\n"
"Wenn eine natürliche Zahl `n : mynat` in deinem Kontext steht \n"
"(über dem `⊢`), dann wird `induction n with d hd` dein Ziel in zwei Ziele \n"
"aufteilen. In einen Basisfall mit `n = 0` und einen Induktionsschritt, \n"
"in dem das Ziel der Fall `n = succ(d) ist.\n"
"### Beispiel:\n"
"Wenn das unser aktueller Kontext ist:\n"
"```\n"
"n : mynat\n"
"⊢ 2 * n = n + n\n"
"```\n"
"\n"
"dann wird \n"
"\n"
"`induction n with d hd`\n"
"\n"
"uns zwei Ziele erzeugen:\n"
"\n"
"```\n"
"⊢ 2 * 0 = 0 + 0\n"
"```\n"
"\n"
"und \n"
"```\n"
"d : mynat,\n"
"hd : 2 * d = d + d\n"
"⊢ 2 * succ d = succ d + succ d\n"
"```\n"
"\n"

#: Addition world level 1
msgid ""
"# Addition World. \n"
"\n"
"Welcome to Addition World. If you've done all four levels in tutorial world\n"
"and know about `rw` and `refl`, then you're in the right place. Here's\n"
"a reminder of the things you're now equipped with which we'll need in this "
"world.\n"
"\n"
"## Data:\n"
"\n"
"  * a type called `mynat`\n"
"  * a term `0 : mynat`, interpreted as the number zero.\n"
"  * a function `succ : mynat → mynat`, with `succ n` interpreted as \"the "
"number after `n`\".\n"
"  * Usual numerical notation 0,1,2 etc (although 2 onwards will be of no use "
"to us until much later ;-) ).\n"
"  * Addition (with notation `a + b`).\n"
"\n"
"## Theorems:\n"
"\n"
"  * `add_zero (a : mynat) : a + 0 = a`. Use with `rw add_zero`.\n"
"  * `add_succ (a b : mynat) : a + succ(b) = succ(a + b)`. Use with `rw "
"add_succ`.\n"
"  * The principle of mathematical induction. Use with `induction` (see "
"below)\n"
"  \n"
"\n"
"## Tactics:\n"
"\n"
"  * `refl` :  proves goals of the form `X = X`\n"
"  * `rw h` : if h is a proof of `A = B`, changes all A's in the goal to "
"B's.\n"
"  * `induction n with d hd` : we're going to learn this right now.\n"
"\n"
"# Important thing: \n"
"\n"
"This is a *really* good time to check you understand about the box on the "
"left with the drop down\n"
"menus. All the theorems and all the tactics above are documented there. You "
"can find\n"
"all you need to know about what theorems you have collected in Theorem "
"statements -> Addition world.\n"
"Have a click around and check that you can find statements of the theorems "
"above, and explanations of\n"
"the tactics above. As we go through the game, these lists will grow. The box "
"on the left\n"
"will prove invaluable as the number of theorems we prove gets bigger. On the "
"other hand,\n"
"we only need to learn one more tactic to really start going places, so let's "
"learn about\n"
"that tactic right now.\n"
"\n"
"## Level 1: the `induction` tactic.\n"
"\n"
"OK so let's see induction in action. We're going to prove\n"
"\n"
"  `zero_add (n : mynat) : 0 + n = n`. \n"
"\n"
"That is: for all natural numbers $n$, $0+n=n$. Wait $-$ what is going on "
"here?\n"
"Didn't we already prove that adding zero to $n$ gave us $n$?\n"
"No we didn't! We proved $n + 0 = n$, and that proof was called `add_zero`. "
"We're now\n"
"trying to establish `zero_add`, the proof that $0 + n = n$. But aren't these "
"two theorems\n"
"the same? No they're not! It is *true* that `x + y = y + x`, but we haven't\n"
"*proved* it yet, and in fact we will need both `add_zero` and `zero_add` in "
"order\n"
"to prove this. In fact `x + y = y + x` is the boss level for addition "
"world,\n"
"and `induction` is the only other tactic you'll need to beat it.\n"
"\n"
"Now `add_zero` is one of Peano's axioms, so we don't need to prove it, we "
"already have it\n"
"(indeed, if you've opened the Addition World theorem statements on the left, "
"you can even see it).\n"
"To prove `0 + n = n` we need to use induction on $n$. While we're here,\n"
"  note that `zero_add` is about zero add something, and `add_zero` is about "
"something add zero.\n"
"  The names of the proofs tell you what the theorems are. Anyway, let's "
"prove `0 + n = n`.\n"
"\n"
"  Delete `sorry` and replace it with `induction n with d hd,`\n"
"and **don't forget the comma**. Hit enter, wait for Lean to finish "
"thinking,\n"
"and let's see what we have.\n"
"\n"
"When Lean has finished thinking, we see that we now have *two goals*! The\n"
"induction tactic has generated for us a base case with `n = 0` (the goal at "
"the top)\n"
"and an inductive step (the goal underneath). The golden rule: **Tactics "
"operate on the first goal** --\n"
"the goal at the top. So let's just worry about that top goal now, the base "
"case `⊢ 0 + 0 = 0`.\n"
"\n"
"Remember that `add_zero` (the proof we have already) is the proof of `x + 0 "
"= x`\n"
"(for any $x$) so we can try\n"
"\n"
"`rw add_zero,`\n"
"\n"
". What do you think the goal will\n"
"change to? Remember to just keep\n"
"focussing on the top goal, ignore the other one for now, it's not changing\n"
"and we're not working on it. You should be able to solve the top goal "
"yourself\n"
"now with `refl`.\n"
"\n"
"When you solved this base case goal, we are now be back down\n"
"to one goal -- the inductive step. Take a look at the\n"
"text below the lemma to see an explanation of this goal.\n"
msgstr ""
"# Welt der Addition. \n"
"\n"
"Herzlich Willkommen in der Welt der Addition. Wenn du alle vier Tutorial "
"Levels \n"
"gespielt hast und über `rw`und `refl` Bescheid weißt, bist du hier "
"richtig. \n"
"Hier eine kleine Erinnerung für alles, was du für diese Welt jetzt "
"brauchst. \n"
"\n"
"## Daten:\n"
"\n"
"  * einen Typ, der `mynat`genannt wird \n"
"  * ein Term `0 : mynat `, der als die Zahl Null interpretiert wird. \n"
"  * eine Funktion `succ : mynat → mynat`, wobei `succ n` als \" der "
"Nachfolger von  `n` \" interpretiert wird. \n"
"  * Die übliche arithmetische Notation 0,1,2, usw. (auch wenn wir Zahlen "
"größer als 1  erst sehr viel später brauchen werden ;-)). \n"
"  * Die Addition (mit der Schreibweise `a + b`). \n"
")\n"
"## Sätze:\n"
"\n"
"  * `add_zero (a : mynat) : a + 0 = a`. Verwendung: `rw add_zero`.\n"
"  * `add_succ (a b : mynat) : a + succ(b) = succ(a + b)`. Verwendung `rw "
"add_succ`.\n"
"  * Das Prinzip der vollständigen Induktion. Zu verwenden mit `induction` "
"(siehe unten)\n"
"  \n"
"\n"
"## Taktiken:\n"
"\n"
"  * `refl` :  beweist Ziele der Form `X = X`\n"
"  * `rw h` : wenn h ein Beweis für `A = B`ist, werden all A's im Ziel mit "
"B's ersetzt. \n"
"  * `induction n with d hd` : das lernen wir genau jetzt!.\n"
"\n"
"# Wichtig: \n"
"\n"
"Jetzt wäre eine *wirklich* gute Gelegenheit zu überprüfen, ob du die Box auf "
"der linken Seite mit dem Menü verstehst. \n"
"Alle Sätze und Taktiken sind dort dokumentiert. Du kannst alles, was du über "
"Sätze wissen musst im Abschnitt 'Sätze' -> Welt der Addition finden. \n"
"Sieh dich ein wenig um und überprüfe, dass du die Aussagen der Sätze und "
"Taktiken und deren Erklärungen von oben findest. \n"
"Während du das Spiel erkundest, wird diese Liste wachsen. Die Box links \n"
"wird von unschätzbarem Wert sein, sobald die Anzahl der Sätze größer wird. \n"
"Auf der anderen Seite werden wir nur noch eine Taktik lernen müssen, "
"umwirklich vorwärts zu kommen. Also los geht's. \n"
"\n"
"## Level 1: die `induction` Taktik.\n"
"\n"
"Ok, sehen wir uns die Induktion in Aktion an. Wir werden folgendes "
"beweisen:\n"
"  `zero_add (n : mynat) : 0 + n = n`. \n"
"\n"
"Für alle natürlichen Zahlen $n$ gilt $0 + n = n$. Moment $-$ was ist hier "
"los? \n"
"Haben wir nicht schon bewiesen, dass die Addition von Null und $n$ wieder $n"
"$ ergibt? \n"
"Nein, das haben wir nicht! Wir haben nur $n + 0 = n$ gezeigt und dieser "
"Beweis hieß `add_zero`. \n"
"Wir werden jetzt versuchen `zero_add` einzuführen, den Beweis dafür, dass $0 "
"+ n = n$ \n"
"Aber sind diese zwei Sätze nicht dasselbe? Nein, sind sie nicht! \n"
"Es ist *wahr*, dass `x + y = y + x`gilt, aber wir haben es noch nicht "
"*bewiesen*. \n"
"Wir werden tatsächlich sowohl `add_zero` als auch `zero_add` für diesen "
"Beweis brauchen. \n"
"Tatsächlich ist `x + y ? y + x`das Boss Level für diese Welt der Addition. \n"
"Die vollständige Induktion ist die einzige andere Taktik, die wir dafür "
"brauchen werden. \n"
"\n"
"`add_zero` ist eines von Peanos Axiomen, also müssen wir es nicht beweisen, "
"wir haben es schon zur Verfügung \n"
"(tatsächlich, wenn du die Sätze links im Menü geöffnet hast, kannst du es "
"sehen). \n"
"Um `0 + n = n`zu beweisen brauchen wir die Induktion über $n$. Während wir "
"dabei sind, \n"
"der Satz `zero_add` handelt von Null und etwas anderem und `add_zero` "
"handelt von einer anderen Zahl und Null. \n"
"Die Namen der Beweise beinhalten also die Aussagen der Sätze. \n"
"Wie auch immer, auf zum Beweis von `0 + n = n`.\n"
"\n"
"Lösche das `sorry`und ersetze es mit `induction n with d hd,`\n"
" und **vergiss das Komma nicht**. Drücke auf enter und warte darauf, "
"dassLean aufhört zu denken. \n"
" Dann sehen wir uns an, was wir haben. \n"
"\n"
"Sobald Lean fertig gedacht hat können wir erkennen, dass wir jetzt *zwei "
"Ziele* haben! \n"
"Die Induktionstaktik hat uns einen Basisfall für `n = 0` erzeugt (das obere "
"Ziel), \n"
"wie auch einen Induktionsschritt (das Ziel darunter). Die goldene Regel: \n"
"**Taktiken operieren auf dem ersten Ziel** -- also dem oberen Ziel. \n"
"Beschäftigen wir uns also erstmal nur mit diesem Ziel, dem Basisfall `⊢ 0 + "
"0 = 0`.\n"
"Denk daran, dass `add_zero`(diesen Beweis haben wir schon) der Beweis für `x "
"+ 0 = x` ist. \n"
"(für ein beliebiges $x$!) Wir können also folgendes versuchen: \n"
"\n"
"`rw add_zero,`\n"
"\n"
"Was glaubst du, wie das das Ziel verändern wird? \n"
"Denk daran, wir konzentrieren uns zuerst nur auf das obere Ziel und "
"ignorieren das andere bisher. \n"
"Es wird sich nicht verändern und wir arbeiten nicht daran. \n"
"Du solltest das obere Ziel jetzt selbst mit `refl` lösen können. \n"
"\n"
"Wenn du den basisfall gelöst hast haben wir nur noch ein Ziel - den "
"Induktionsschritt. \n"
"Sieh dir den Text unter dem Lemma an, um die Erklärung für dieses Ziel zu "
"lesen. \n"

#: Addition world level 1
msgid ""
"For all natural numbers $n$, we have\n"
"$$0 + n = n.$$\n"
msgstr "Für alle natürlichen Zahlen $n$ gilt: $$0 + n = n.$$\n"

#: Addition world level 1
msgid ""
"We're in the successor case, and your top right box should look\n"
"something like this:\n"
"\n"
"```\n"
"case mynat.succ\n"
"d : mynat,\n"
"hd : 0 + d = d\n"
"⊢ 0 + succ d = succ d\n"
"```\n"
"\n"
"*Important:* make sure that you only have one goal at this point. You\n"
"should have proved `0 + 0 = 0` by now. Tactics only operate on the top "
"goal.\n"
"\n"
"The first line just reminds us we're doing the inductive step.\n"
"We have a fixed natural number `d`, and the inductive hypothesis `hd : 0 + d "
"= d`\n"
"saying that we have a proof of `0 + d = d`.  \n"
"Our goal is to prove `0 + succ d = succ d`. In words, we're showing that\n"
"if the lemma is true for `d`, then it's also true for the number after `d`.\n"
"That's the inductive step. Once we've proved this inductive step, we will "
"have proved\n"
"`zero_add` by the principle of mathematical induction.\n"
"\n"
"To prove our goal, we need to use `add_succ`. We know that `add_succ 0 d`\n"
"is the result that `0 + succ d = succ (0 + d)`, so the first thing\n"
"we need to do is to replace the left hand side `0 + succ d` of our\n"
"goal with the right hand side. We do this with the `rw` command. You can "
"write\n"
"\n"
"`rw add_succ,`\n"
"\n"
"(or even `rw add_succ 0 d,` if you want to give Lean all the inputs instead "
"of making it\n"
"figure them out itself). Don't forget the comma though. Hit enter. The goal "
"should change to\n"
"\n"
"`⊢ succ (0 + d) = succ d`\n"
"\n"
"Now remember our inductive hypothesis `hd : 0 + d = d`. We need\n"
"to rewrite this too! Type \n"
"\n"
"`rw hd,`\n"
"\n"
"(don't forget the comma). The goal will now change to\n"
"\n"
"`⊢ succ d = succ d`\n"
"\n"
"This goal can be solved with the `refl` tactic. After you apply it,\n"
"Lean will inform you that there are no goals left. You are done!\n"
"\n"
"## Now venture off on your own.\n"
"\n"
"Those three tactics -- \n"
"\n"
"* `induction n with d hd,` \n"
"* `rw h,`\n"
"* `refl,`\n"
"\n"
"will get you quite a long way through this game. Using only these tactics\n"
"you can beat Addition World level 4 (the boss level of Addition World),\n"
"all of Multiplication World including the boss level `a * b = b * a`,\n"
"and even all of Power World including the fiendish final boss. This route "
"will\n"
"give you a good grounding in these three basic tactics; after that, if you\n"
"are still interested, there are other worlds to master, where you can learn\n"
"more tactics.\n"
"\n"
"But we're getting ahead of ourselves, you still have to beat the rest of "
"Addition World. \n"
"We're going to stop explaining stuff carefully now. If you get stuck or "
"want\n"
"to know more about Lean (e.g. how to do much harder maths in Lean),\n"
"ask in `#new members` at\n"
"<a href=\"https://leanprover.zulipchat.com\" target=\"blank\">the Lean chat</"
"a>\n"
"(login required, real name preferred). Kevin or Mohammad or one of the "
"other\n"
"people there might be able to help.\n"
"\n"
"Good luck! Click on \"next level\" to solve some levels on your own.\n"
"\n"
msgstr ""
"Wir sind im Nachfolger-Fall und die Box rechts oben sollte etwa so "
"aussehen: \n"
"\n"
"```\n"
"case mynat.succ\n"
"d : mynat,\n"
"hd : 0 + d = d\n"
"⊢ 0 + succ d = succ d\n"
"```\n"
"\n"
"*Wichtig:* gehe sicher, dass du im Moment nur noch ein Ziel hast. Du "
"solltest \n"
"`0 + 0 = 0` inzwischen bewiesen haben. Taktiken funktionieren nur für das "
"oberste Ziel.\n"
"\n"
"Die erste Zeile erinnert uns nur daran, dass wir beim Induktionsschritt "
"sind. \n"
"Wir wählen eine natürliche Zahl `d` beliebig, aber fest und betrachten die \n"
"Induktionsvoraussetzung `hd : 0 + d = d`, die uns mitteilt, dass wir einen "
"Beweis \n"
"für `0 + d = d` haben. \n"
"Unser Ziel ist es, zu beweisen, dass `0 + succ d = succ d` gilt. In "
"Worten: \n"
"Wenn das Lemma für `d` wahr ist, dann ist es auch für alle Zahlen nach `d` "
"wahr. \n"
"Das entspricht dem Induktionsschritt. Sobald wir diesen bewiesen haben, \n"
"haben wir `zero_add` mit Hilfe der vollständigen Induktion bewiesen. \n"
"Um das Ziel zu erreichen müssen wir `add_succ` verwenden. Wir wissen, \n"
"dass `add_succ 0 d` das Ergebnis ist, das `0 + succ d = succ (0 + d)` "
"gilt. \n"
" Unser erste Schritt ist es also, die linke Seite `0 + succ d` unseres "
"Ziels \n"
"mit der rechten Seite zu ersetzen. Wir erreichen das mit dem `rw` Befehl. "
"Man schreibt:  \n"
"\n"
"`rw add_succ,`\n"
"\n"
"(oder sogar `rw add_succ 0 d,` wenn du es Lean genau sagen willst, anstatt "
"ihm \n"
"das Denken zu überlassen). Vergiss das Komma nicht und drücke auf Enter. \n"
" Das Ziel sollte jetzt so aussehen: \n"
"`⊢ succ (0 + d) = succ d`\n"
"\n"
"Jetzt müssen wir uns an die Induktionsvoraussetzung `hd : 0 + d = d` "
"erinnern. \n"
"Wir müssen diese auch mit `rw` einsetzen!\n"
"`rw hd,`\n"
"\n"
"(Vergiss das Komma nicht!). Das Ziel wird jetzt zu:  to\n"
"\n"
"`⊢ succ d = succ d`\n"
"\n"
"Dieses Ziel können wir mit `refl` beweisen. Nachdem du es angewandt hast, \n"
"wird Lean dich wissen lassen, dass keine Ziele mehr übrig sind. Du bist "
"fertig! \n"
"\n"
"## Ab hier gehst du alleine auf deine Reise.\n"
"\n"
"Die folgenden drei Taktiken -- \n"
"\n"
"* `induction n with d hd,` \n"
"* `rw h,`\n"
"* `refl,`\n"
"\n"
"werden dich sehr weit durch dieses Spiel tragen. Mit nur diesen drei "
"Taktiken \n"
"kannst du das vierte Level dieser Welt (das Boss level der Welt der "
"Addition), \n"
"die gesamte Welt der Multiplikation mit ihrem Bosslevel `a * b = b * a`,\n"
"und sogar die gesamte Welt der Potenzen mit ihrem teuflischen Endboss "
"lösen. \n"
"Dieser Weg wird dir eine gute Grundlage in den drei grundlegenden Taktiken "
"geben. \n"
"Wenn du danach immer noch interessiert bist, gibt es andere Welten zu "
"meistern, \n"
"dort kannst du noch mehr Taktiken lernen. \n"
"\n"
"Aber eins nach dem anderen, du musst zunächst den Rest dieser Welt lösen! \n"
"Ab sofort wird nicht mehr alles so genau erklärt, wie bisher. Wenn du \n"
"feststeckst oder mehr über Lean wissen willst (z.B. wie man viel schwerere \n"
"Mathematik in Lean schreibt), frage einfach in `#new members`unter \n"
"<a href=\"https://leanprover.zulipchat.com\" target=\"blank\">der Lean chat</"
"a>\n"
"nach. (Ein login wird benötigt, ein echter Name wird bevorzugt). Kevin or "
"Mohammad oder einer \n"
"der anderen dort sollte dir helfen können. \n"
"\n"
"Viel Glück! Klicke auf \"Nächstes Level\", um mehr Levels alleine zu lösen.\n"

#: Addition world level 2
msgid ""
"# Addition world\n"
"\n"
"Don't forget to use the drop down boxes on the left to see your tactics and\n"
"what you have proved so far.\n"
"\n"
"## Level 2: `add_assoc` -- associativity of addition.\n"
"\n"
"It's well-known that (1 + 2) + 3 = 1 + (2 + 3) -- if we have three numbers\n"
"to add up, it doesn't matter which of the additions we do first. This fact\n"
"is called *associativity of addition* by mathematicians, and it is *not*\n"
"obvious. For example, subtraction really is not associative: $(6 - 2) - 1$\n"
"is really not equal to $6 - (2 - 1)$. We are going to have to prove\n"
"that addition, as defined the way we've defined it, is associative. \n"
" \n"
"See if you can prove associativity of addition. Hint: because addition was "
"defined\n"
"by recursion on the right-most variable, use induction on the right-most\n"
"variable (try other variables at your peril!). Note that when Lean writes `a "
"+ b + c`,\n"
"it means `(a + b) + c`. If it wants to talk about `a + (b + c)` it will put "
"the brackets\n"
"in explictly.\n"
"\n"
"Reminder: you are done when you see \"Proof complete!\" in the top right, "
"and an empty\n"
"box (no errors) in the bottom right. You can move between levels and worlds "
"(i.e. you\n"
"can go back and review old stuff) without losing anything.\n"
"\n"
"Once you're done with associativity (sub-boss), we can move on to "
"commutativity (boss).\n"
msgstr ""
"# Welt der Addition\n"
"\n"
"Vergiss nicht das dropdown Menü auf der linken Seite zu verwenden, um \n"
"die Taktiken und alles, was du bisher bewiesen hast, zu sehen. \n"
"\n"
"## Level 2: `add_assoc` -- Die Assoziativität der Addition \n"
"\n"
"Es ist allgemein bekannt, dass (1 + 2) + 3 = 1 + (2 + 3) gilt -- wenn wir "
"drei Zahlen addieren, \n"
"spielt es keine Rolle, welche der Additionen wir zuerst ausführen. Diese "
"Tatsache \n"
"wird von Mathematikern *Assoziativität der Addition* genannt und ist *nicht* "
"offensichtlich. \n"
"Zum Beispiel ist die Subtraktion nicht assoziativ: $(6 - 2) - 1$ ist nicht "
"dasselbe \n"
"wie $6 - (2 - 1)$. Wir müssen beweisen, dass die Addition -- so wie wir sie "
"definiert \n"
"haben -- assoziativ ist. \n"
" \n"
"Versuche jetzt zu beweisen, dass die Addition assoziativ ist. \n"
"Hinweis: da die Addition durch Rekursion auf der Variable ganz rechts "
"definiert wurde, \n"
"solltest du die Induktion auf dieser durchführen (verwende andere Variablen "
"auf eigene Gefahr. Beachte außerdem, dass Lean `a + b + c` als `(a + b) + c` "
"interpretiert. \n"
"Wenn es `a + (b + c)` meint, wird es die Klammern explizit anzeigen. \n"
"\n"
"Erinnerung: du bist fertig, wenn du \" Satz bewiesen!\" oben rechts und "
"eine \n"
"leere Fehlerbox unten rechts siehst. Du kannst dich zwischen levels und "
"Welten bewegen \n"
"(also zurückgehen, um altes noch einmal zu sehen) ohne etwas zu verlieren. \n"
"\n"
"Sobald du mit der Assoziativität (Zwischenboss) fertig bist kannst du zur \n"
"Kommutativität vordrignen (Endboss). \n"

#: Addition world level 2
msgid ""
"On the set of natural numbers, addition is associative.\n"
"In other words, for all natural numbers $a, b$ and $c$, we have\n"
"$$ (a + b) + c = a + (b + c). $$\n"
msgstr ""
"Die Addition von natürlichen Zahlen ist assoziativ. \n"
"Mit anderen Worten, für alle natürlichen Zahlen $a, b$ und $c$ gilt: \n"
"$$ (a + b) + c = a + (b + c). $$\n"

#: Addition world level 3
msgid ""
"# Addition World\n"
"\n"
"## Level 3: `succ_add`\n"
"\n"
"Oh no! On the way to `add_comm`, a wild `succ_add` appears. `succ_add`\n"
"is the proof that `succ(a) + b = succ(a + b)` for `a` and `b` in your\n"
"natural number type. We need to prove this now, because we will need\n"
"to use this result in our proof that `a + b = b + a` in the next level.\n"
"\n"
"NB: think about why computer scientists called this result `succ_add` .\n"
"There is a logic to all the names.\n"
"\n"
"Note that if you want to be more precise about exactly where you want\n"
"to rewrite something like `add_succ` (the proof you already have),\n"
"you can do things like `rw add_succ (succ a)` or\n"
"`rw add_succ (succ a) d`, telling Lean explicitly what to use for\n"
"the input variables for the function `add_succ`. Indeed, `add_succ`\n"
"is a function -- it takes as input two variables `a` and `b` and outputs a "
"proof\n"
"that `a + succ(b) = succ(a + b)`. The tactic `rw add_succ` just says to Lean "
"\"guess\n"
"what the variables are\". \n"
msgstr ""
"# Welt der Addition\n"
"\n"
"## Level 3: `succ_add`\n"
"\n"
"Oh nein! Auf dem Weg zu `add_comm` ist ein wildes `succ_add` erschienen. \n"
"`succ_add` ist der Beweis dafür, dass für zwei natürlichen Zahlen `a` und "
"`b` \n"
"gilt: `succ(a) + b = succ(a + b)`. Wir werden dies jetzt beweisen, da wir \n"
"dieses Ergebnis für unseren Beweis für `a + b = b + a` im nächsten Level "
"brauchen. \n"
"\n"
"Nebenbei: denk darüber nach, warum Informatiker dieses Ergebnis `succ_add` "
"nennen. \n"
"Alle Namen folgen derselben Logik. \n"
"\n"
"Beachte, dass du Lean genauer sagen kannst, was du umschreiben willst, wenn "
"du \n"
"`add_succ` (den Beweis, den du schon hast) anwenden willst. Du kannst zum "
"Beispiel schreiben: \n"
"`rw add_succ (succ a)` oder `rw add_succ (succ a) d`. Mit diesen Befehlen "
"sagst du Lean genau, \n"
"welche Eingabevariable du für die Funktion `add_succ` haben möchtest. \n"
"Tatsächlich ist `add_succ` eine Funktion -- es nimmt als Eingabe zwei "
"Variablen `a` und `b` und \n"
"macht daraus einen Beweis., dass gilt: `a + succ(b) = succ(a + b)`. Die "
"Taktik `rw add_succ` \n"
"sagt Lean nur: \"Rate, was die Variablen sind.\" \n"

#: Addition world level 3
msgid ""
"For all natural numbers $a, b$, we have\n"
"$$ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b). $$\n"
msgstr ""
"Für alle natürlichen Zahlen $a, b$ gilt: \n"
"$$ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b). $$\n"

#: Addition world level 4
msgid ""
"# Addition World\n"
"\n"
"## Level 4: `add_comm` (boss level)\n"
"\n"
"[boss battle music]\n"
"\n"
"Look in Theorem statements -> Addition world to see the proofs you have.\n"
"These should be enough.\n"
msgstr ""
"# Welt der Addition \n"
"\n"
"## Level 4: `add_comm` (Bosslevel)\n"
"[Bossmusik] \n"
"\n"
"Sieh in die Sätze auf der linken Seite (Welt der Addition), um zu sehen, \n"
"welche Beweise du hast. Sie sollten ausreichen."

#: Addition world level 4
msgid ""
"On the set of natural numbers, addition is commutative.\n"
"In other words, for all natural numbers $a$ and $b$, we have\n"
"$$ a + b = b + a. $$\n"
msgstr ""
"Die Addition auf den natürlichen Zahlen ist kommutativ, oder: \n"
"Für alle natürlichen Zahlen $a$ und $b$ gilt: \n"
"$$ a + b = b + a. $$\n"

#: Addition world level 4
msgid ""
"\n"
"If you got this far -- nice! You're nearly ready to make a choice:\n"
"Multiplication World or Function World. But there are just a couple\n"
"more useful lemmas in Addition World which you should prove first.\n"
"Press on to level 5.\n"
"\n"
msgstr ""
"\n"
"Wenn du soweit gekommen bist -- sehr schön! Du bist fast soweit, dich zu "
"entscheiden: \n"
"Die Welt der Multiplikation, oder die Welt der Funktionen. Aber es gibt noch "
"einige \n"
"weitere nützliche Lemmas in der Welt der Addition, die du zuerst beweisen "
"solltest. \n"
"Also auf zu Level 5. \n"
"\n"

#: Addition world level 5
msgid ""
"\n"
"# Addition World\n"
"\n"
"## Level 5: `succ_eq_add_one`\n"
"\n"
"I've just added `one_eq_succ_zero` (a proof of `1 = succ(0)`) to your list "
"of theorems; this is true\n"
"by definition of $1$, but we didn't need it until now.\n"
"\n"
"Levels 5 and 6 are the two last levels in Addition World.\n"
"Level 5 involves the number $1$. When you see a $1$ in your goal,\n"
"you can write `rw one_eq_succ_zero` to get back\n"
"to something which only mentions `0`. This is a good move because $0$ is "
"easier for us to\n"
"manipulate than $1$ right now, because we have\n"
"some theorems about $0$ (`zero_add`, `add_zero`), but, other than `1 = "
"succ(0)`,\n"
"no theorems at all which mention $1$. Let's prove one now.\n"
msgstr ""
"\n"
"# Welt der Addition\n"
"\n"
"## Level 5: `succ_eq_add_one`\n"
"Ich habe gerade `one_eq_succ_zero` (einen Bweis für '1 = succ(0)` zu deiner "
"Liste von Beweisen hinzugefügt. \n"
"Das gilt für die Definition von $1$, aber wir haben es bisher nicht "
"gebraucht. \n"
"\n"
"Die Levels 5 und 6 sind die letzten beiden Level in der Welt der Addition. \n"
"Das fünfte Level behandelt die Zahl $1$, wenn du eine $1$ in deinem Ziel "
"siehst, \n"
"kannst du `rw one_eq_succ_zero` schreiben, um wieder zu etwas mit $0$ "
"zurückzukommen. \n"
"Das ist eine gute Strategie, weil $0$ für uns einfacher zu verändern ist als "
"$1$. \n"
"Wir haben nämlich viele Sätze über die $0$ (`zero_add`, `add_zero`), aber "
"abgesehen \n"
"von `1 = succ(0)` haben wir keine Sätze, die $1$ erwähnen. Beweisen wir "
"jetzt einen!\n"

#: Addition world level 5
msgid ""
"For any natural number $n$, we have\n"
"$$ \\operatorname{succ}(n) = n+1. $$\n"
msgstr ""
"Für eine beliebige natürliche Zahl $n$ gilt: \n"
"$$ \\operatorname{succ}(n) = n+1. $$\n"

#: Addition world level 6
msgid ""
"\n"
"# Addition World\n"
"\n"
"## Level 6: `add_right_comm`\n"
"\n"
"Lean sometimes writes `a + b + c`. What does it mean? The convention is\n"
"that if there are no brackets displayed in an addition formula, the "
"brackets\n"
"are around the left most `+` (Lean's addition is \"left associative\"). \n"
"So the goal in this level is `(a + b) + c = (a + c) + b`. This isn't\n"
"quite `add_assoc` or `add_comm`, it's something you'll have to prove\n"
"by putting these two theorems together.\n"
"\n"
"If you hadn't picked up on this already, `rw add_assoc` will\n"
"change `(x + y) + z` to `x + (y + z)`, but to change it back\n"
"you will need `rw ← add_assoc`. Get the left arrow by typing `\\l`\n"
"then the space bar (note that this is L for left, not a number 1).\n"
"Similarly, if `h : a = b` then `rw h` will change `a`'s to `b`'s\n"
"and `rw ← h` will change `b`'s to `a`'s.\n"
"\n"
"Also, you can be (and will need to be, in this level) more precise\n"
"about where to rewrite theorems. `rw add_comm,` will just find the\n"
"first `? + ?` it sees and swap it around. You can target more specific\n"
"additions like this: `rw add_comm a` will swap around\n"
"additions of the form `a + ?`, and `rw add_comm a b,` will only\n"
"swap additions of the form `a + b`.\n"
"\n"
"## Where next?\n"
"\n"
"There are thirteen more levels about addition after this one, but before\n"
"you can attempt them you need to learn some more tactics. So after this\n"
"level you have a choice -- either move on to Multiplication World (which you "
"can\n"
"solve with the tactics you know) or try Function World (and learn some new "
"ones).\n"
"After solving this level, click \"Main Menu\" in the top left to take you "
"back\n"
"to the overworld, and make your choice. Other things, perhaps of interest\n"
"to some players, are mentioned below the lemma. \n"
msgstr ""
"\n"
"# Welt der Addition\n"
"\n"
"## Level 6: `add_right_comm`\n"
"\n"
"Lean schreibt manchmal `a + b + c`. Was meint es damit? Nach Konvention "
"steht \n"
"die Klammer immer um die Zahlen beim linken `+`, wenn keine Klammern "
"geschrieben sind. \n"
"Dies bedeutetm dass Leans Addition \"Links - assoziativ\" ist. \n"
"Das Ziel dieses Level ist es also `(a + b) + c = (a + c) + b` zu beweisen. \n"
"Das ist nicht ganz `add_assoc` oder `add_comm`, es ist etwas anderes, dass \n"
"du durch Kombination dieser beiden Sätze beweisen kannst. \n"
"\n"
"Wenn du es nicht ohnehin schon weißt: `rw add_assoc` wird  `(x + y) + z` \n"
"zu `x + (y + z)` umschreiben. Um es aber zurückzuschreiben, wirst du \n"
"`rw ← add_assoc` brauchen. (Den Pfeil nach links erhältst du mit `\\l`,\n"
"der Buchstabe ist ein kleines L, nicht eine 1). \n"
"Ähnlich funktioniert auch: Gilt `h : a = b`, dann wird `rw h` \n"
"alle `a`s in `b`s umschreiben und `rw ← h` alle `b`s zu `a`s. \n"
"\n"
"Außerdem kannst du genauer damit sein, wo die Sätze umgeschrieben werden "
"sollen. \n"
"Du wirst das in diesem Level auf jeden Fall brauchen. `rw add_comm` wird \n"
"nur die erste Stelle `? + ?` finden und umdrehen. Du kannst dies "
"präzisieren: \n"
"`rw add_comm a,` wird nur Additionen der Form `a + ?` tauschen und \n"
"`rw add_comm a b,` wird nur Additionen der Form `a + b` tauschen. \n"
"\n"
"## Wie geht es weiter?\n"
"\n"
"Es gibt noch dreizehn weitere Levels zur Addition, aber bevor du diese lösen "
"kannst, \n"
"musst du noch mehr Taktiken lernen. Nach dieser Welt hast du also eine "
"Wahl. \n"
"Entweder gehst du zur Welt der Multiplikation (die kannst du mit den "
"bisherigen Taktiken lösen), \n"
"oder du versuchst dich an der Welt der Funktionen und lernst neue Taktiken "
"kennen. \n"
"Wenn du mit diesem Level fertig bist, kehre ins Hauptmenü zurück und "
"entscheide dich. \n"
"Ein paar weitere interessante Dinge stehen unter dem Lemma. \n"

#: Addition world level 6
msgid ""
"For all natural numbers $a, b$ and $c$, we have\n"
"$$ a + b + c = a + c + b. $$\n"
msgstr ""
"Für alle natürlichen Zahlen $a, b$ und $c$ gilt: \n"
"$$ a + b + c = a + c + b. $$\n"

#: Addition world level 6
msgid ""
"If you have got this far, then you have become very good at\n"
"manipulating equalities in Lean. You can also now collect\n"
"four collectibles (or `instance`s, as Lean calls them)\n"
"\n"
"```\n"
"mynat.add_semigroup -- (after level 2)\n"
"mynat.add_monoid -- (after level 2)\n"
"mynat.add_comm_semigroup mynat (after level 4)\n"
"mynat.add_comm_monoid -- (after level 4)\n"
"```\n"
"\n"
"In Multiplication World you will be able to collect such\n"
"advanced collectibles as `mynat.comm_semiring` and\n"
"`mynat.distrib`, and then move on to power world and\n"
"the famous collectible at the end of it.\n"
"\n"
"One last thing -- didn't you think that solving this level\n"
"`add_right_comm` was boring? Check out this AI that can do it for us.\n"
"\n"
"First we have to get the `add_comm_monoid` collectible,\n"
"which we do by saying the magic words which make Lean's type class "
"inference\n"
"system give it to us.\n"
msgstr ""
"Wenn du soweit gekommen bist, dann bist du wirklich gut darin geworden, \n"
"Gleichungen in Lean zu manimpulieren. Du kannst jetzt auf vier "
"\"Sammlerstücke\" \n"
"zugreifen (oder `Instanzen`, wie Lean sie nennt). \n"
"\n"
"```\n"
"mynat.add_semigroup -- (nach Level 2)\n"
"mynat.add_monoid -- (nach Level 2)\n"
"mynat.add_comm_semigroup mynat (nach Level 4)\n"
"mynat.add_comm_monoid -- (nach Level 4)\n"
"```\n"
"\n"
"In der Welt der Multiplikation wirst du fortgeschrittene Sammlerstücke \n"
"wie `mynat.comm_semiring`oder `mynat.distrib` finden. \n"
"Danach kannst du weiter zur Welt der Potenzen und das berühmte "
"Sammlerstück \n"
"an ihrem Ende einsammeln. \n"
"\n"
"Eine letzte Sache noch -- hast du nicht gedacht, dass das Lösen dieses "
"Levels \n"
"`add_right_comm` eher langweilig war? Dann solltest du dir diese AI "
"ansehen, \n"
"die das für uns erledigen kann. Zuerst brauchen wir `add_comm_monoid`, \n"
"was wir mit den magischen Worten erhalten können, die Leans Typklassen \n"
"Inferenzmaschine uns zur Verfügung stellt. \n"

#: Addition world level 6
msgid ""
"Now the `simp` AI becomes accessible (it's just an advanced\n"
"tactic really), and can nail some really tedious-for-a-human-to-solve\n"
"goals. For example check out this one-line proof:\n"
msgstr ""
"Die `simp`AI ist jetzt verfügbar (es ist eigentlich nur eine \n"
"fortgeschrittene Taktik) und kann einige wirklich lästige Ziele\n"
"(zumindest für Menschen) lösen. Sieh dir zum Beispiel diesen Einzeiler an: \n"

#: Addition world level 6
msgid ""
"Imagine having to do that one by hand! The AI closes the goal\n"
"because it knows how to use associativity and commutativity\n"
"sensibly in a commutative monoid.\n"
"\n"
"You are now done with addition world. Go back to the main menu (top left)\n"
"and decide whether to press on with multiplication world and power world\n"
"(which can be solved with `rw`, `refl` and `induction`), or to go on\n"
"to Function World where you can learn the tactics needed to prove\n"
"goals of the form $P\\implies Q$, thus enabling you to solve more\n"
"advanced addition world levels such as $a+t=b+t\\implies a=b$. Note that\n"
"Function World is more challenging mathematically; but if you can do "
"Addition\n"
"World you can surely do Multiplication World and Power World.\n"
msgstr ""
"Stell dir vor, du müsstest das händisch machen! Die AI löst alle Ziele, \n"
"weil es die Assoziativitäts- und Kommutativitätsbeweise in einem \n"
"kommutativen Monoid verwenden kann.\n"
"\n"
"Du bist jetzt mit der Welt der Addition fertig. Geh zurück ins Hauptmenü "
"(oben links) \n"
"und entscheide dich, ob du mit der Welt der Multiplikation und der Welt der "
"Potenzen \n"
"weitermachen willst (die mit `rw`, `refl`und `Induktion` beweisen kannst), \n"
"oder du gehst weiter zur Welt der Funktionen, wo du Taktiken lernen wirst, "
"um \n"
"Ziele der Form $P\\implies Q$ zu lösen. Dadurch kannst du fortgeschrittenere "
"Levels \n"
"für die Addition lösen, wie zum Beispiel $a+t=b+t\\implies a=b$. \n"
"Beachte, dass die Welt der Funktionen mathematisch gesehen anspruchsvoller "
"ist; \n"
"aber wenn du die Welt der Addition geschafft hast, ist die Welt der "
"Multiplikation und \n"
"der Potenzen kein Problem für dich. \n"

#: Addition world level 6
msgid ""
"\n"
"## Summary\n"
"\n"
"The `simp` tactic is a high-level tactic which tries\n"
"to prove equalities using facts in its database (such\n"
"as `add_assoc` and `add_comm`).\n"
"\n"
"## Details\n"
"\n"
"The `simp` tactic does basic automation. By level 6 of\n"
"Addition World you\n"
"have proved enough about addition for `simp` to be able\n"
"to solve all equalities whose proofs involve a tedious number\n"
"of rewrites of `add_assoc` and `add_comm`, and by\n"
"level 9 of Multiplication World the same is true of `mul_assoc` and "
"`mul_comm`.\n"
"\n"
"### Example:\n"
"If our goal is this:\n"
"```\n"
"⊢ a + b + c + d + e = c + (b + e + a) + d\n"
"```\n"
"\n"
"and you have completed addition world, then you've proved\n"
"enough about addition to solve this level with `simp`. \n"
"Note however that you can't prove `add_assoc` with `simp`,\n"
"because `add_assoc` is an ingredient to get `simp` working.\n"
"\n"
"### Example:\n"
"If our goal is this:\n"
"```\n"
"⊢ a * b * c = c * b * a\n"
"```\n"
"then as long as you've completed Multiplication World, `simp` will close "
"this\n"
"goal.\n"
msgstr ""
"\n"
"## Zusammenfassung\n"
"\n"
"Die `simp`Taktik ist eine fortgeschrittene Taktik, die Gleichungen \n"
"mit den Sätzen in ihrer Datenbank (wie `add_assoc`und `add_comm`) löst. \n"
"\n"
"## Details\n"
"\n"
"Die `simp` Taktik automatisiert auf einem simplen Level. Von Level 6 an \n"
"hast du genug über die Addition bewiesen, sodass `simp` es schafft, \n"
"alle Beweise zu bewältigen, die eine enervierende Anzahl an `rw` Operationen "
"wie \n"
"`rw add_assoc`und `rw add_comm`benötigt. Ab dem neunten Level der Welt \n"
"der Multiplikation gilt dasselbe für `mul_assoc`und `mul_comm`.\n"
"\n"
"### Beispiel:\n"
"Wenn unser Ziel:\n"
"```\n"
"⊢ a + b + c + d + e = c + (b + e + a) + d\n"
"```\n"
"\n"
"ist und du die Welt der Addition geschafft hast, dann kannst du \n"
"obiges Ziel mit `simp` lösen. Du kannst allerdings nicht `add_assoc` \n"
"mit `simp` beweisen, weil `add_assoc` eine \"Zutat\" für `simp`ist. \n"
"\n"
"### Beispiel:\n"
"Wenn unser Ziel:\n"
"```\n"
"⊢ a * b * c = c * b * a\n"
"```\n"
"ist, dann wird `simp` dieses Ziel erfüllen, wenn du die Welt der "
"Multiplikation \n"
"abgeschlossen hast. \n"

#: world_config
msgid "Multiplication world"
msgstr "Welt der Multiplikation"

#: Multiplication world level 1
msgid "import mynat.mul -- import the definition of multiplication on mynat"
msgstr ""
"import mynat.mul -- importiert die Definition der Multiplikation für mynat"

#: Multiplication world level 1
msgid ""
"\n"
"# Multiplication World\n"
"\n"
"A new import! This import gives you the definition of multiplication on "
"your\n"
"natural numbers. It is defined by recursion, just like addition.\n"
"Here are the two new axioms:\n"
"\n"
"  * `mul_zero (a : mynat) : a * 0 = 0`\n"
"  * `mul_succ (a b : mynat) : a * succ(b) = a * b + a`\n"
"\n"
"In words, we define multiplication by \"induction on the second variable\",\n"
"with `a * 0` defined to be `0` and, if we know `a * b`, then `a` times\n"
"the number after `b` is defined to be `a * b + a`. \n"
"\n"
"You can keep all the theorems you proved about addition, but \n"
"for multiplication, those two results above are you've got right now.\n"
"I would recommend that you sort out the bar on the left. Fold up "
"everything,\n"
"and then unfold just Theorem Statements -> Multiplication World. This will\n"
"remind you of your two new theorems, both of which are true by definition.\n"
"If you want to be reminded of the theorems you have proved about addition,\n"
"you can just open up the Addition World theorem statements and take a "
"look. \n"
"If you don't want to keep opening and closing these menus, why not think\n"
"a bit about the logic behind the naming of the proofs? After a while you\n"
"might find that you can guess the name of the proof you want.\n"
"\n"
"Anyway, what's going on in multiplication world? Like addition, we need to "
"go\n"
"for the proofs that multiplication\n"
"is commutative and associative, but as well as that we will\n"
"need to prove facts about the relationship between multiplication\n"
"and addition, for example `a * (b + c) = a * b + a * c`, so now\n"
"there is a lot more to do. Good luck! \n"
"\n"
"We are given `mul_zero`, and the first thing to prove is `zero_mul`.\n"
"Like `zero_add`, we of course prove it by induction.\n"
"\n"
"## Level 1: `zero_mul`\n"
msgstr ""
"\n"
"# Welt der Multiplikation\n"
"\n"
"Ein neuer Import! Dieser Import definiert uns die Multiplikation auf "
"unseren \n"
"natürlichen Zahlen. Sie ist rekursiv definiert, genauso wie die Addition. \n"
"Hier sind die zwei neue Axiome: \n"
"\n"
"  * `mul_zero (a : mynat) : a * 0 = 0`\n"
"  * `mul_succ (a b : mynat) : a * succ(b) = a * b + a`\n"
"\n"
"In anderen Worten, wir definieren die Multiplikation durch \"Induktion über "
"die \n"
"zweite Variable \", wobei `a * 0` als `0`definiert ist. Wenn wir `a * b` "
"wissen, \n"
"dann ist `a`mal der Nachfolger von `b` definiert als `a * b + a`. \n"
"\n"
"Du kannst weiterhin alle Sätze verwenden, die du für die Addition bewiesen "
"hast, \n"
"aber für die Multiplikation ist das, was oben steht, erstmal alles. \n"
"Ich würde dir empfehlen, dass du die Box auf der linken Seite ordest bzw. \n"
"zuklappst. Aktuell brauchen wir nur die Sätze der Multiplikation unter \n"
"Sätze -> Welt der Multiplikation. Das wird dich an die beiden neuen Sätze "
"erinnern. \n"
"Wenn du an die Sätze aus der Welt der Addition erinnert werden willst, "
"klappe das \n"
"entsprechende Menü einfach wieder aus. \n"
"Wenn du nicht immer die Menüs auf- und zuklappen willst, kannst du auch noch "
"ein wenig \n"
"über die Logik der Beweisnamen nachdenken. Nach einer Weile kannst du sicher "
"die Namen \n"
"des Beweises, den du brauchst, raten. \n"
"\n"
"Was passiert jetzt in der Welt der Multiplikation? Wie bei der Addition "
"müssen wir \n"
"für die Multiplikation nachweisen, dass sie kommutativ und assoziativ ist. \n"
"Außerdem müssen wir aber einige Dinge über die Beziehung zwischen "
"Multiplikation \n"
"und Addition beweisen, zum Beispiel: `a * (b + c) = a * b + a * c`. \n"
"Es ist also sehr viel mehr zu tun. Viel Glück! \n"
"\n"
"Wir haben `mul_zero`gegeben und das Erste, was wir beweisen müssen, ist "
"`zero_mul`.\n"
"Wie `zero_add` können wir es natürlich mit Induktion beweisen. \n"
"\n"
"## Level 1: `zero_mul`\n"

#: Multiplication world level 1
msgid ""
"For all natural numbers $m$, we have\n"
"$$ 0 \\times m = 0. $$\n"
msgstr ""
"Für alle natürlichen Zahlen $m$ gilt: \n"
"$$ 0 \\times m = 0. $$\n"

#: Multiplication world level 2
msgid ""
"# Multiplication World\n"
"\n"
"## Level 2: `mul_one`\n"
"\n"
"Remember that you can see everything you have proved so far about "
"multiplication in\n"
"the drop-down box on the left (and that this list will grow as we proceed).\n"
"\n"
"In this level we'll need to use\n"
"\n"
"* `one_eq_succ_zero : 1 = succ(0)`\n"
"\n"
"which was mentioned back in Addition World and\n"
"which will be a useful thing to rewrite right now, as we\n"
"begin to prove a couple of lemmas about how `1` behaves\n"
"with respect to multiplication.\n"
msgstr ""
"# Welt der Multiplikation \n"
"\n"
"## Level 2: `mul_one`\n"
"\n"
"Denk daran, dass du alles, was du bisher über die Multiplikation bewiesen "
"hast, \n"
"links in der dropw-down Box sehen kannst (diese Liste wird noch wachsen). \n"
"In diesem Level werden wir \n"
"* `one_eq_succ_zero : 1 = succ(0)`\n"
"\n"
"verwenden, was zum ersten Mal in der Welt der Addition vorkam. Es wird \n"
"jetzt zum zweiten Mal für das Umschreiben nützlich werden, da wir jetzt \n"
"einige Lemmas über das Verhalten der `1` bei Multiplikation beweisen. \n"
" "

#: Multiplication world level 2
msgid ""
"For any natural number $m$, we have\n"
"$$ m \\times 1 = m. $$\n"
msgstr ""
"Für alle natürlichen Zahlen $m$ gilt: \n"
"$$ m \\times 1 = m. $$\n"

#: Multiplication world level 3
msgid ""
"# Multiplication World\n"
"\n"
"## Level 3: `one_mul`\n"
"\n"
"These proofs from addition world might be useful here:\n"
"\n"
"* `one_eq_succ_zero : 1 = succ(0)`\n"
"* `succ_eq_add_one a : succ(a) = a + 1` \n"
"\n"
"We just proved `mul_one`, now let's prove `one_mul`. \n"
"Then we will have proved, in fancy terms,\n"
"that 1 is a \"left and right identity\"\n"
"for multiplication (just like we showed that\n"
"0 is a left and right identity for addition\n"
"with `add_zero` and `zero_add`).\n"
msgstr ""
"# Welt der Multiplikation \n"
"\n"
"## Level 3: `one_mul`\n"
"Die folgenden Beweis aus der Welt der Addition könnten hier nützlich sein: \n"
"\n"
"* `one_eq_succ_zero : 1 = succ(0)`\n"
"* `succ_eq_add_one a : succ(a) = a + 1` \n"
"\n"
"Wir haben gerade `mul_one`bewiesen, jetzt geht es an `one_mul`.\n"
"Wenn wir damit fertig sind haben wir, in schlauen Worten, bewiesen, \n"
"dass für die Multiplikation die 1 ein \"links- und rechtsneutrales\" Element "
"ist. \n"
"(Das haben wir auch schon für die 0 für die Addition gezeigt, mit `add_zero` "
"und `zero_add) \n"

#: Multiplication world level 3
msgid ""
"For any natural number $m$, we have\n"
"$$ 1 \\times m = m. $$\n"
msgstr ""
"Für alle natürlichen Zahlen $m$ gilt: \n"
"$$ 1 \\times m = m. $$\n"

#: Multiplication world level 4
msgid ""
"# Multiplication World\n"
"\n"
"## Level 4: `mul_add`\n"
"\n"
"Where are we going? Well we want to prove `mul_comm`\n"
"and `mul_assoc`, i.e. that `a * b = b * a` and\n"
"`(a * b) * c = a * (b * c)`. But we *also* want to\n"
"establish the way multiplication interacts with addition,\n"
"i.e. we want to prove that we can \"expand out the brackets\"\n"
"and show `a * (b + c) = (a * b) + (a * c)`.\n"
"The technical term for this is \"left distributivity of\n"
"multiplication over addition\" (there is also right distributivity,\n"
"which we'll get to later).\n"
"\n"
"Note the name of this proof -- `mul_add`. And note the left\n"
"hand side -- `a * (b + c)`, a multiplication and then an addition.\n"
"I think `mul_add` is much easier to remember than \"left_distrib\",\n"
"an alternative name for the proof of this lemma.\n"
msgstr ""
"# Welt der Multiplikation \n"
"## Level 4: `mul_add`\n"
"\n"
"Wo geht der Weg hin? Wir wollen `mul_comm` und `mul_assoc` beweisen, also \n"
"`a * b = b * a` und `(a * b) * c = a * (b * c)`. Aber wir wollen *auch* \n"
"festlegen, wie die Multiplikation mit der Addition interagiert, zum "
"Beispiel \n"
"wollen wir zeigen, wie man \"ausklammert\" und `a * (b + c) = (a * b) + (a * "
"c)`zeigen.\n"
"Der technische Name für diese Tatsache ist die \"Links-Distributitvität\" \n"
"von Multiplikation und Addition (es gibt auch die Rechts-Distributivität, \n"
"aber dazu kommen wir später noch). \n"
"Beachte auch diesmal wieder den Namen des Beweises -- `mul_add` und die \n"
"linke Seite -- `a * (b + c)`. Zuerst eine Multiplikation und dann eine "
"Addition. \n"
"Ich denke `mul_add` ist deutlich einfacher zu merken als \"left_distrib\", \n"
"ein alternativer Name für den Beweis dieses Lemma. \n"

#: Multiplication world level 4
msgid ""
"Multiplication is distributive over addition.\n"
"In other words, for all natural numbers $a$, $b$ and $t$, we have\n"
"$$ t(a + b) = ta + tb. $$\n"
msgstr ""
"Die Multiplikation ist distributiv bezüglich der Addition. \n"
"Anders gesagt, für alle natürlichen Zahllen $a$, $b$ und $t$ gilt: \n"
"$$ t(a + b) = ta + tb. $$\n"

#: Multiplication world level 4
msgid "def left_distrib := mul_add -- the \"proper\" name for this lemma"
msgstr ""
"def left_distrib := mul_add -- der \"vernünftige\" Name für dieses Lemma"

#: Multiplication world level 5
msgid ""
"# Multiplication World\n"
"\n"
"## Level 5: `mul_assoc`\n"
"\n"
"We now have enough to prove that multiplication is associative.\n"
"\n"
"## Random tactic hints\n"
"\n"
"1) Did you know you can do `repeat {rw mul_succ}`?\n"
"\n"
"2) Did you know you can do `rwa [hd, mul_add]`?\n"
"I learnt that trick from Ken Lee. Ken spotted that\n"
"`rwa` will do the rewrites and will then check to\n"
"see if the goal can be proved by `refl`, and if it\n"
"can, it will close it! [It will also close goals which\n"
"are exactly equal to hypotheses, which will be helpful later on.]\n"
msgstr ""
"# Welt der Multiplikation \n"
"\n"
"## Level 5: `mul_assoc`\n"
"\n"
"Wir haben jetzt genug Material, um zu zeigen, dass die Multiplikation "
"assoziativ ist. \n"
"\n"
"## Taktik Hinweise \n"
"\n"
"1) Wusstest du, dass du `repeat {rw mul_succ}` schreiben kannst? \n"
"\n"
"2) Hast du gewusst, dass du `rwa [hd, mul_add]`schreiben kannst? \n"
"Ich habe diesen Trick von ken Lee. Ken hat herausgefunden, dass \n"
"`rwa` das Ziel umschreiben wird und dann überprüft, ob es mit \n"
"`refl` bewiesen werden kann. Wenn es so ist, dann wird es automatisch \n"
"geschlossen! [Es werden auch Ziele geschlossen, die äquivalent zur \n"
"Hypothese sind, was später nützlich sein wird.] \n"

#: Multiplication world level 5
msgid ""
"Multiplication is associative.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$$ (ab)c = a(bc). $$\n"
msgstr ""
"Die Multiplikation ist assoziativ. \n"
"Mit anderen Worten, für alle natürlichen Zahlen $a$, $b$ und $c$ gilt: \n"
"$$ (ab)c = a(bc). $$\n"

#: Multiplication world level 5
msgid ""
"A mathematician could now remark that you have proved that the natural\n"
"numbers form a monoid under multiplication.\n"
msgstr ""
"Ein mathematiker würde jetzt sagen, dass du bewiesen hast, dass die \n"
"natürlichen Zahlen mit der Multiplikation einen Monoid bilden. \n"

#: Multiplication world level 6
msgid ""
"# Multiplication World\n"
"\n"
"## Level 6: `succ_mul`\n"
"\n"
"We now begin our journey to `mul_comm`, the proof that `a * b = b * a`. \n"
"We'll get there in level 8. Until we're there, it is frustrating\n"
"but true that we cannot assume commutativity. We have `mul_succ`\n"
"but we're going to need `succ_mul` (guess what it says -- maybe you\n"
"are getting the hang of Lean's naming conventions). \n"
"\n"
"Remember also that we have tools like\n"
"\n"
"* `add_right_comm a b c : a + b + c = a + c + b` \n"
"\n"
"These things are the tools we need to slowly build up the results\n"
"which we will need to do mathematics \"normally\". \n"
"We also now have access to Lean's `simp` tactic,\n"
"which will solve any goal which just needs a bunch\n"
"of rewrites of `add_assoc` and `add_comm`. Use if\n"
"you're getting lazy!\n"
msgstr ""
"# Welt der Multiplikation \n"
"\n"
"## Level 6: `succ_mul`\n"
"\n"
"Wir beginnen jetzt unsere Reise zu `mul_comm`, also dem Beweis, dass \n"
"`a * b = b * a` gilt. Wir werden das in Level 8 beweisen. Bis wir soweit "
"sind, \n"
"ist es frustrierend, aber leider wahr, dass wir die Kommutativität nicht "
"einfach annehmen können. \n"
"Wir haben `mul_succ`, werden aber auch `succ_mul` brauchen (rate doch mal "
"was \n"
"es aussagt -- ich bin sicher du hast Leans Benennungen inzwischen "
"verstanden). \n"
"\n"
"Denk auch an Werkzeuge wie \n"
"\n"
"* `add_right_comm a b c : a + b + c = a + c + b` \n"
"\n"
"Diese Werkzeuge sind das, was wir brauchen werden, um langsam aber sicher \n"
"die Ergebnisse aufzubauen, die es uns erlauben werden, Mathematik \"normal"
"\" \n"
"zu betreiben. Wir haben außerdem Zugriff auf Leans `simp` Taktik, \n"
"die jedes Ziel beweist, dass nur ein paar mal das Umschreiben mit \n"
"`add_assoc`oder `add_comm` erfordern. Benutze es, wenn du faul wirst! \n"

#: Multiplication world level 6
msgid ""
"For all natural numbers $a$ and $b$, we have\n"
"$$ \\operatorname{succ}(a) \\times b = ab + b. $$\n"
msgstr ""
"Für alle natürlichen Zahlen $a$ und $b$ gilt: \n"
"$$ \\operatorname{succ}(a) \\times b = ab + b. $$\n"

#: Multiplication world level 7
msgid ""
"# Multiplication World\n"
"\n"
"## Level 7: `add_mul`\n"
"\n"
"We proved `mul_add` already, but because we don't have commutativity yet\n"
"we also need to prove `add_mul`. We have a bunch of tools now, so this "
"won't\n"
"be too hard. You know what -- you can do this one by induction on any of\n"
"the variables. Try them all! Which works best? If you can't face\n"
"doing all the commutativity and associativity, remember the high-powered\n"
"`simp` tactic mentioned at the bottom of Addition World level 6,\n"
"which will solve any puzzle which needs only commutativity\n"
"and associativity. If your goal looks like `a+(b+c)=c+b+a` or something,\n"
"don't mess around doing it explicitly with `add_comm` and `add_assoc`,\n"
"just try `simp`.\n"
msgstr ""
"# Welt der Multiplikation \n"
"\n"
"## Level 7: `add_mul`\n"
"\n"
"Wir haben schon `mul_add` bewiesen, aber da wir noch keine Kommutativität "
"haben, \n"
"müssen wir `add_mul`auch beweisen. Wir haben bereits jede Menge Werkzeuge, "
"es wird \n"
"also nicht allzu schwer werden. Weißt du was -- du kannst diesen Beweis "
"durch Induktion \n"
"über eine beliebige Variable führen. Versuche sie alle! Welche funktioniert "
"am Besten? \n"
"Wenn du die ganzen Kommutativitäts- und Assoziativitätsbeweise selbst "
"schreiben willst, \n"
"denk auch an die mächtige `simp` Taktik, die in der Welt der Addition (Level "
"6) steht. \n"
"Wenn dein Ziel wie `a+(b+c)=c+b+a` oder etwas Ähnliches aussieht, versuche "
"es nicht \n"
"mit `add_comm` oder `add_assoc`, sondern verwende einfach `simp`. \n"

#: Multiplication world level 7
msgid ""
"Addition is distributive over multiplication.\n"
"In other words, for all natural numbers $a$, $b$ and $t$, we have\n"
"$$ (a + b) \\times t = at + bt. $$\n"
msgstr ""
"Die Addition ist ditributiv bezüglich der Multiplikation. \n"
"Mit anderen Worten, für alle natürlichen Zahlen $a$, $b$ und $t$ gilt: \n"
"$$ (a + b) \\times t = at + bt. $$\n"

#: Multiplication world level 7
msgid ""
"A mathematician would now say that you have proved that the natural\n"
"numbers are a semiring. This sounds like a respectable result.\n"
msgstr ""
"Eine Mathematiker würde jetzt sagen, dass wir bewiesen haben, dass die \n"
"natürlichen Zahlen ein Halbring ist. Das klingt wie ein respektables "
"Ergebnis. \n"

#: Multiplication world level 7
msgid "def right_distrib := add_mul -- alternative name"
msgstr "def right_distrib := add_mul -- ein alternativer Name"

#: Multiplication world level 7
msgid ""
"Lean would add that you have also proved that they are a `distrib`. \n"
"However this concept has no mathematical name at all -- this says something\n"
"about the regard with which mathematicians hold this collectible.\n"
"This is an artefact of the set-up of collectibles in Lean. You consider "
"politely\n"
"declining Lean's offer of a `distrib` collectible.\n"
"You are dreaming of the big collectible at the end of power world.\n"
msgstr ""
"Lean würde hinzufügen, dass du auch bewiesen hast, das sie `distrib` sind. \n"
"Dieses Konzept hat aber keinen mathematischen Namen -- es sagt etwas über\n"
" den Wert den Mathematiker diesem Sammlerstück zuweisen. \n"
"Es ist ein Relikt aus der Liste der Sammlerstücke von Lean. Du wirst \n"
"Leans Angebot für ein `distrib`Sammlerstück höflich ablehnen. \n"
"Du träumst ohnehin vom großen Sammlerstück am Ende der Welt der Potenzen. \n"

#: Multiplication world level 7
msgid "instance : distrib mynat := by structure_helper -- "
msgstr "instance : distrib mynat := by structure_helper --"

#: Multiplication world level 8
msgid ""
"# Multiplication World\n"
"\n"
"## Level 8: `mul_comm`\n"
"\n"
"Finally, the boss level of multiplication world. But (assuming you\n"
"didn't cheat) you are well-prepared for it -- you have `zero_mul`\n"
"and `mul_zero`, as well as `succ_mul` and `mul_succ`. After this\n"
"level you can of course throw away one of each pair if you like,\n"
"but I would recommend you hold on to them, sometimes it's convenient\n"
"to have exactly the right tools to do a job.\n"
msgstr ""
"# Welt der Multiplikation \n"
"\n"
"## Level 8: `mul_comm`\n"
"\n"
"Endlich, dass Bosslevel der Welt der Multiplikation. Aber (wenn man "
"annimmt, \n"
"dass du nicht geschummelt hast) du bist gut vorbereitet -- du hast "
"`zero_mul`\n"
"und `mul_zero`, genauso wie `succ_mul`und `mul_succ`. Nach diesem Level \n"
"kannst du natürlich jeweils eins von beiden wegwerfen, wenn du willst. \n"
"Aber ich würde empfehlen sie zu behalten, denn manchmal ist es praktisch, \n"
"genau das richtige Werkzeug zu haben, um einen Job zu erledigen. \n"

#: Multiplication world level 8
msgid "Multiplication is commutative.\n"
msgstr "Die Multiplikation ist kommutativ. \n"

#: Multiplication world level 8
msgid ""
"You've now proved that the natural numbers are a commutative semiring!\n"
"That's the last collectible in Multiplication World. \n"
msgstr ""
"Du hast jetzt bewiesen, dass die natürlichen Zahlen ein kommutativer "
"Halbring sind! \n"
"Das ist das letzte Sammlerstück in der Welt der Multiplikation. \n"

#: Multiplication world level 8
msgid ""
"But don't leave multiplication just yet -- prove `mul_left_comm`, the last\n"
"level of the world, and then we can beef up the power of `simp`. \n"
msgstr ""
"Verlasse die Welt der Multiplikation aber noch nicht -- beweise "
"`mul_left_comm`, \n"
"das letzte Level dieser Welt. Damit können wir `simp` sogar noch stärker "
"machen. \n"

#: Multiplication world level 9
msgid ""
"# Multiplication World\n"
"\n"
"## Level 9: `mul_left_comm`\n"
"\n"
"You are equipped with\n"
"\n"
"* `mul_assoc (a b c : mynat) : (a * b) * c = a * (b * c)`\n"
"* `mul_comm (a b : mynat) : a * b = b * a`\n"
"\n"
"Re-read the docs for `rw` so you know all the tricks.\n"
"You can see them in the \"tactics\" drop-down menu on the left.\n"
msgstr ""
"# Welt der Multiplikation \n"
"\n"
"Du bist mit \n"
"\n"
"* `mul_assoc (a b c : mynat) : (a * b) * c = a * (b * c)`\n"
"* `mul_comm (a b : mynat) : a * b = b * a`\n"
"\n"
"ausgestattet. Lies dir die Dokumentation für `rw` durch, damit du alle "
"Tricks kennst. \n"
"Du kannst sie im \"Taktiken\" Menü links nachsehen. \n"

#: Multiplication world level 9
msgid ""
"For all natural numbers $a$ $b$ and $c$, we have\n"
"$$a(bc)=b(ac)$$\n"
msgstr ""
"Für alle natürlichen Zahlen $a$, $b$ und $c$ gilt: \n"
"$$a(bc)=b(ac)$$\n"

#: Multiplication world level 9
msgid "And now I whisper a magic incantation\n"
msgstr "Ich flüstere jetzt eine magische Beschwörung \n"

#: Multiplication world level 9
msgid ""
"and all of a sudden Lean can automatically do levels which are\n"
"very boring for a human, for example\n"
msgstr ""
"und plötzlich kann Lean ganz automatisch Levels lösen, die für einen \n"
"Menschen sehr sehr langweilig sind, zum Beispiel: \n"

#: Multiplication world level 9
msgid ""
"If you feel like attempting Advanced Multiplication world\n"
"you'll have to do Function World and the Proposition Worlds first.\n"
"These worlds assume a certain amount of mathematical maturity\n"
"(perhaps 1st year undergraduate level). \n"
"Your other possibility is Power World, with the \"final boss\".\n"
msgstr ""
"Wenn du dich in die Welt der fortgeschrittenen Multiplikation stürzen "
"willst, \n"
"wirst du zuerst die Welt der Funktionen und die Welt der Aussagen lösen "
"müssen. \n"
"Diese Welten benötigen ein gewisses Maß an mathematischer Vorbildung \n"
"(vielleicht etwa erstes Jahr Grundstudium). \n"
"Dein anderer Weg ist die Welt der Potenzen, mit dem \"Endboss\". \n"

#: world_config
msgid "Power world"
msgstr "Welt der Potenzen"

#: Power world level 1
msgid "import mynat.pow -- new import"
msgstr "mport mynat.pow -- neuer Import"

#: Power world level 1
msgid ""
"\n"
"# Power World\n"
"\n"
"A new world with seven levels. And a new import!\n"
"This import gives you the power to make powers of your\n"
"natural numbers. It is defined by recursion, just like addition and "
"multiplication.\n"
"Here are the two new axioms:\n"
"\n"
"  * `pow_zero (a : mynat) : a ^ 0 = 1`\n"
"  * `pow_succ (a b : mynat) : a ^ succ(b) = a ^ b * a`\n"
"\n"
"The power function has various relations to addition and multiplication.\n"
"If you have gone through levels 1--6 of addition world and levels 1--9 of\n"
"multiplication world, you should have no trouble with this world:\n"
"The usual tactics `induction`, `rw` and `refl` should see you through.\n"
"You might want to fiddle with the\n"
"drop-down menus on the left so you can see which theorems of Power World\n"
"you have proved at any given time. Addition and multiplication -- we\n"
"have a solid API for them now, i.e. if you need something about addition\n"
"or multiplication, it's probably already in the library we have built.\n"
"Collectibles are indication that we are proving the right things.\n"
"\n"
"The levels in this world were designed by Sian Carey, a UROP student\n"
"at Imperial College London, funded by a Mary Lister McCammon Fellowship,\n"
"in the summer of 2019. Thanks Sian!\n"
"\n"
"## Level 1: `zero_pow_zero`\n"
msgstr ""
"\n"
"Welt der Potenzen \n"
"\n"
"Eine neue Welt mit sieben levels. Und einem neuen Import! \n"
"Wenn du die ersten 6 Level der Welt der Addition und die ersten 9 Level \n"
"der Welt der Multiplikation geschafft hast, solltest du mit dieser Welt "
"keine \n"
"Probleme haben. Die üblichen Taktiken `induction`, `rw` und `refl` sollten \n"
"hier völlig ausreichen. Du könntest etwas mit den drop-down Menüs auf der "
"linken \n"
"Seite herumspielen, um die Sätze für die Welt der Potenzen zu sehen, die du "
"bisher \n"
"bewiesen hast. Für die Addition und Multiplikation haben wir inzwischen \n"
"eine recht solide API. Wenn du also etwas brauchst, wird es wahrscheinlich "
"schon \n"
"in unserer Bibliothek sein. Sammlerstücke sind ein klares Zeichen dafür, \n"
"dass wir die richtigen Dinge beweisen. \n"
"Die Level dieser Welt sind von Sian Carey im Sommer 2019 entwickelt worden, "
"einem UROP Studenten \n"
"des Imperial College London, der durch die Mary Lister McCammon Stiftung "
"unterstützt wird. \n"
"Danke Sian! \n"
"\n"
"## Level 1: `zero_pow_zero`\n"

#: Power world level 1
msgid "$0 ^ 0 = 1$.\n"
msgstr "$0 ^ 0 = 1$.\n"

#: Power world level 2
msgid ""
"\n"
"# Power World\n"
"\n"
"## Level 2: `zero_pow_succ`\n"
msgstr ""
"\n"
"# Welt der Potenzen\n"
"\n"
"## Level 2: `zero_pow_succ`\n"

#: Power world level 2
msgid "For all naturals $m$, $0 ^{succ (m)} = 0$.\n"
msgstr "Für alle natürlichen zahlen $m$ gilt: $0 ^{succ (m)} = 0$.\n"

#: Power world level 3
msgid ""
"\n"
"# Power World\n"
"\n"
"## Level 3: `pow_one`\n"
msgstr ""
"\n"
"# Welt der Potenzen \n"
"\n"
"## Level 3: `pow_one`\n"

#: Power world level 3
msgid "For all naturals $a$, $a ^ 1 = a$.\n"
msgstr "Für alle natürlichen Zahlen $a$ gilt:  $a ^ 1 = a$.\n"

#: Power world level 4
msgid ""
"\n"
"# Power World\n"
"\n"
"## Level 4: `one_pow`\n"
msgstr ""
"\n"
"# Welt der Potenzen \n"
"\n"
"## Level 4: `one_pow` \n"

#: Power world level 4
msgid "For all naturals $m$, $1 ^ m = 1$.\n"
msgstr "Für alle natürlichen Zahlen $m$ gilt: $1^m = 1$. \n"

#: Power world level 5
msgid ""
"\n"
"# Power World\n"
"\n"
"## Level 5: `pow_add`\n"
msgstr ""
"\n"
"# Welt der Potenzen \n"
"\n"
"## Level 5: `pow_add`\n"

#: Power world level 5
msgid "For all naturals $a$, $m$, $n$, we have $a^{m + n} = a ^ m  a ^ n$.\n"
msgstr ""
"für alle natürlichen Zahlen $a$, $m$, $n$ gilt: $a^{m + n} = a ^ m  a ^ n$.\n"

#: Power world level 6
msgid ""
"\n"
"# Power World\n"
"\n"
"## Level 6: `mul_pow`\n"
"\n"
"You might find the tip at the end of level 9 of Multiplication World\n"
"useful in this one. You can go to the main menu and pop back into\n"
"Multiplication World and take a look -- you won't lose any of your\n"
"proofs. You'll only lose proofs if you reload the page.\n"
msgstr ""
"\n"
"# Welt der Potenzen \n"
"\n"
"## Level 6: `mul_pow`\n"
"\n"
"Der Tip am Ende des neunten Levels der Welt der Multiplikation könnte \n"
"für dieses Level ebenfalls nützlich sein. Du kannst über das Hauptmenü \n"
"zurückgehen und nachsehen -- du wirst keinen Fortschritt oder Beweis \n"
"dadurch verlieren. Du verlierst sie nur, wenn du die Seite neu lädst. \n"

#: Power world level 6
msgid "For all naturals $a$, $b$, $n$, we have $(ab) ^ n = a ^ nb ^ n$.\n"
msgstr ""
"Für alle natürlichen Zahlen $a$, $b$ und $n$ gilt: $(ab) ^ n = a ^ nb ^ n$.\n"

#: Power world level 7
msgid ""
"\n"
"# Power World\n"
"\n"
"## Level 7: `pow_pow`\n"
msgstr ""
"\n"
"# Welt der Potenzen \n"
"\n"
"## Level 7: `pow_pow`\n"

#: Power world level 7
msgid "Boss level! What will the collectible be?\n"
msgstr "Boss Level! Was wird das Sammlerstück sein? \n"

#: Power world level 7
msgid "For all naturals $a$, $m$, $n$, we have $(a ^ m) ^ n = a ^ {mn}$.\n"
msgstr ""
"Für alle natürlichen Zahlen $a$, $m$ und $n$ gilt: $(a ^ m) ^ n = a ^ "
"{mn}$.\n"

#: Power world level 7
msgid ""
"Apparently Lean can't find a collectible, even though you feel like you\n"
"just finished power world so you must have proved *something*. What should "
"the\n"
"collectible for this level be called? \n"
msgstr ""
"Scheinbar kann Lean kein Sammlerstück finden, auch wenn du das Gefühl "
"hast, \n"
"dass du die Welt der Potenzen gerade geschafft hast, also *irgendwas* "
"bewiesen \n"
"haben musst. Wie sollte das Sammlerstück für dieses Level genannt werden? \n"

#: Power world level 7
msgid ""
"But what is this? It's one of those twists where there's another\n"
"boss after the boss you thought was the final boss! Go to the next\n"
"level!\n"
msgstr ""
"Aber was ist jetzt los? Es ist einer dieser Wendepunkte, wo ein weiter \n"
"Boss nach dem Boss auftaucht, obwohl du dachtest der erste war der "
"Endboss! \n"
"Geh weiter zum nächsten Level! \n"

#: Power world level 8
msgid "# Power World\n"
msgstr "# Welt der Potenzen \n"

#: Power world level 8
msgid ""
"## Level 8: `add_squared`\n"
"\n"
"[final boss music] \n"
"\n"
"You see something written on the stone dungeon wall:\n"
"```\n"
"begin\n"
"  rw two_eq_succ_one,\n"
"  rw one_eq_succ_zero,\n"
"  repeat {rw pow_succ},\n"
"  ...\n"
"```\n"
"\n"
"and you can't make out the last two lines because there's a kind\n"
"of thing in the way that will magically disappear\n"
"but only when you've beaten the boss.\n"
"\n"
msgstr ""
"## Level 8: ' add_squared' \n"
"\n"
"[Endboss Musik] \n"
"\n"
"Du siehst etwas auf der steinernen Dungeonwand: \n"
"```\n"
"begin\n"
"  rw two_eq_succ_one,\n"
"  rw one_eq_succ_zero,\n"
"  repeat {rw pow_succ},\n"
"  ...\n"
"```\n"
"\n"
"Die letzten zwei Zeilen kannst du nicht entziffern, weil irgendetwas \n"
"im Weg ist, dass magisch verschwinden wird, aber nur dann, wenn du den \n"
"Boss besiegst."

#: Power world level 8
msgid ""
"For all naturals $a$ and $b$, we have\n"
"$$(a+b)^2=a^2+b^2+2ab.$$\n"
msgstr ""
"Für alle natürlichen Zahlen $a$ und $b$ gilt: \n"
"$$(a+b)^2=a^2+b^2+2ab.$$\n"

#: Power world level 8
msgid ""
"As the boss lies smouldering, you notice on the dungeon wall that\n"
"<a href=\"https://twitter.com/XenaProject/status/1190453646904958976?s=20/\" "
"target=\"blank\">\n"
"two more lines of code are now visible under the first three...</a> (Twitter."
"com)\n"
"\n"
"I just beat this level with 27 single rewrites followed by a `refl`. \n"
"Can you do any better? (The current rewrite record is 25 -- see <a href="
"\"https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/"
"function.20with.20random.20definition/near/179723073\" target=\"blank"
"\">here</a>\n"
"(needs zulip login)).\n"
"If you beat it then well done! Do you\n"
"fancy doing $(a+b)^3$ now? You might want to read \n"
"<a href=\"https://xenaproject.wordpress.com/2018/06/13/ab3/\" target=\"blank"
"\">\n"
"this Xena Project blog post</a> before you start though.\n"
msgstr ""
"Als der Boss schwelend vor dir liegt, kannst du auf der Dungeonwand zwei "
"weitere Zeilen erkennen \n"
"<a href=\"https://twitter.com/XenaProject/status/1190453646904958976?s=20/\" "
"target=\"blank\">\n"
"Sie sind jetzt unter den ersten drei erkennbar. </a> (Twitter.com) \n"
"\n"
"Ich habe dieses Level mit 27 Umschreibungen gelöst, gefolgt von einem "
"`refl`.\n"
"Kannst du es besser? (Der aktuelle Rekord liegt bei 25 -- siehe: \n"
"<a href=\"https://leanprover.zulipchat.com/#narrow/stream/113488-general/"
"topic/function.20with.20random.20definition/near/179723073\" target=\"blank"
"\">hier</a>\n"
"(braucht einen zulip login)).\n"
"Wenn du es geschafft hast: gut gemacht! Du könntest vielleicht $(a+b)^3$ "
"schlagen wollen? \n"
"Falls ja, willst du vermutlich folgendes lesen: \n"
"<a href=\"https://xenaproject.wordpress.com/2018/06/13/ab3/\" target=\"blank"
"\">\n"
"Xena Project blog post</a>\n"

#: Power world level 8
msgid ""
"If you got this far -- very well done! If you only learnt the three\n"
"tactics `rw`, `induction` and `refl` then there are now more tactics to\n"
"learn; go back to the main menu and choose Function World. \n"
"\n"
"The main thing we really want to impress upon people is that we believe\n"
"that *all of pure mathematics* can be done in this new way.\n"
"A system called Coq (which is very like Lean) has\n"
"<a href=\"https://hal.inria.fr/hal-00816699\" target=\"blank\">\n"
"checked the proof of the Feit-Thompson theorem</a> (hundreds of pages of\n"
"group theory) and Lean has a\n"
"<a href=\"https://leanprover-community.github.io/lean-perfectoid-spaces/\"\n"
"  target=\"blank\">\n"
"definition of perfectoid spaces</a> (a very complex modern\n"
"mathematical structure). I believe that these systems will one day\n"
"cause a paradigm shift in the way mathematics is done, but first we need\n"
"to build what we know, or at least build enough to state what we\n"
"mathematicians believe. If you want to get involved, come and join\n"
"us at the <a href=\"https://leanprover.zulipchat.com\" target=\"blank"
"\">Zulip Lean chat</a>.\n"
"The #new members stream is a great place to start asking questions.\n"
"\n"
"To come (possibly): the real number game, the group theory game,\n"
"the integer game, the natural number game 2,... . Alternatively\n"
"see <a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/"
"FAQ.html\" target=\"blank\">the FAQ</a>\n"
"for some more ideas about what to do next.\n"
"\n"
msgstr ""
"Wenn du soweit gekommen bist -- sehr gut! Wenn du bisher nur die Taktiken \n"
"`rw`, `induction`und `refl`gelernt hast, dann warten jetzt noch mehr auf "
"dich! \n"
"Geh zurück ins Hauptmenü und betrete die Welt der Funktionen \n"
"\n"
"Der Knackpunkt, den wir allen leuten hier zeigen wollen ist, dass wir "
"glauben, \n"
"dass *alle reine Mathematik* in dieser neuen Art und Weise geschrieben "
"werden kann. \n"
"Ein System namens Coq (sehr ähnlich zu Lean) hat \n"
"<a href=\"https://hal.inria.fr/hal-00816699\" target=\"blank\">\n"
"den Beweis des Satzes von Feit -Thompson überprüft. </a> (Hunderte Seiten "
"von \n"
"Gruppentheorie). Außerdem hat Lean \n"
"<a href=\"https://leanprover-community.github.io/lean-perfectoid-spaces/\"\n"
"  target=\"blank\">\n"
"eine Definition für perfectoid spaces</a> (eine sehr komplexe und moderne \n"
"mathematische Struktur). Ich glaubem dass diese Programme eines Tages \n"
"einen Paradigmenwechsel in der Art, wie wir Mathematik betreiben, schaffen "
"werden. \n"
"Zuerst müssen wir aber alles, was wir bisher wissen, mit diesen System "
"reproduzieren, \n"
"oder zumindest soviel, dass wir ausdrücken können, was die meisten "
"Mathematiker glauben. \n"
"Wenn du dich einbringen möchtest, dann trete einfach dem us at the <a href="
"\"https://leanprover.zulipchat.com\" target=\"blank\">Zulip Lean chat</a> "
"bei. \n"
"Der #new members Teil ist ein großartiger Ort, um erste Fragen zu stellen. \n"
"\n"
"In der Zukunft (vermtulich): das Spiel der reellen Zahlen, das "
"Gruppentheorie Spiel, \n"
"Das Ganzzahlenspiel, das Spiel der natürlichen Zahlen - zweiter Teil, ... \n"
"Alternativ, sieh hier nach \n"
"<a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/FAQ."
"html\" target=\"blank\">FAQ</a>\n"
"wenn du mehr Ideen haben möchtest, wie es weitergehen könnte. \n"

#: world_config
msgid "Function world"
msgstr "Welt der Funktionen"

#: Function world level 1
msgid ""
"\n"
"# Function world. \n"
"\n"
"If you have beaten Addition World, then you have got\n"
"quite good at manipulating equalities in Lean using the `rw` tactic.\n"
"But there are plenty of levels later on which will require you\n"
"to manipulate functions, and `rw` is not the tool for you here.\n"
"\n"
"To manipulate functions effectively, we need to learn about a new "
"collection\n"
"of tactics, namely `exact`, `intro`, `have` and `apply`. These tactics\n"
"are specially designed for dealing with functions. Of course we are\n"
"ultimately interested in using these tactics to prove theorems\n"
"about the natural numbers &ndash; but in this\n"
"world there is little point in working with specific sets like `mynat`,\n"
"everything works for general sets.\n"
"\n"
"So our notation for this level is: $P$, $Q$, $R$ and so on denote general "
"sets,\n"
"and $h$, $j$, $k$ and so on denote general\n"
"functions between them. What we will learn in this world is how to use "
"functions\n"
"in Lean to push elements from set to set. A word of warning &ndash; \n"
"even though there's no harm at all in thinking of $P$ being a set and $p$\n"
"being an element, you will not see Lean using the notation $p\\in P$, "
"because\n"
"internally Lean stores $P$ as a \"Type\" and $p$ as a \"term\", and it uses "
"`p : P`\n"
"to mean \"$p$ is a term of type $P$\", Lean's way of expressing the idea "
"that $p$\n"
"is an element of the set $P$. You have seen this already &ndash; Lean has\n"
"been writing `n : mynat` to mean that $n$ is a natural number.\n"
"\n"
"## A new kind of goal.\n"
"\n"
"All through addition world, our goals have been theorems,\n"
"and it was our job to find the proofs. \n"
"**The levels in function world aren't theorems**. This is the only world "
"where\n"
"the levels aren't theorems in fact. In function world the object of a level\n"
"is to create an element of the set in the goal. The goal will look like `⊢ "
"X`\n"
"with $X$ a set and you get rid of the goal by constructing an element of $X"
"$. \n"
"I don't know if you noticed this, but you finished\n"
"essentially every goal of Addition World (and Multiplication World and Power "
"World,\n"
"if you played them) with `refl`.\n"
"This tactic is no use to us here.\n"
"We are going to have to learn a new way of solving goals &ndash; the `exact` "
"tactic.\n"
"\n"
"If you delete the sorry below then your local context will look like this:\n"
"\n"
"```\n"
"P Q : Type,\n"
"p : P,\n"
"h : P → Q\n"
"⊢ Q\n"
"```\n"
"\n"
"In this situation, we have sets $P$ and $Q$ (but Lean calls them types),\n"
"and an element $p$ of $P$ (written `p : P`\n"
"but meaning $p\\in P$). We also have a function $h$ from $P$ to $Q$,\n"
"and our goal is to construct an\n"
"element of the set $Q$. It's clear what to do *mathematically* to solve\n"
"this goal -- we can\n"
"make an element of $Q$ by applying the function $h$ to\n"
"the element $p$. But how to do it in Lean? There are at least two ways\n"
"to explain this idea to Lean,\n"
"and here we will learn about one of them, namely the method which\n"
"uses the `exact` tactic.\n"
"\n"
"## The `exact` tactic. \n"
"\n"
"If you can explicitly see how to make an element of your goal set,\n"
"i.e. you have a formula for it, then you can just write `exact <formula>` \n"
"and this will close the goal. \n"
"\n"
"### Example\n"
"\n"
"If your local context looks like this\n"
"\n"
"```\n"
"P Q : Type,\n"
"p : P,\n"
"h : P → Q\n"
"⊢ Q\n"
"```\n"
"\n"
"then $h(p)$ is an element of $Q$ so you can just write\n"
"\n"
"`exact h(p),`\n"
"\n"
"to close the goal. \n"
"\n"
"## Important note\n"
"\n"
"Note that `exact h(P),` won't work (with a capital $P$);\n"
"this is a common error I see from beginners. \n"
"$P$ is not an element of $P$, it's $p$ that is an element of $P$. \n"
"\n"
"## Level 1: the `exact` tactic.\n"
msgstr ""
"\n"
"# Welt der Funktionen. \n"
"\n"
"Wenn die die Welt der Addition geschafft hast, dann bist du inzwischen\n"
"wirklich gut darin, mit Lean Gleichungen mit der `rw` Taktik zu lösen.\n"
"Es gibt aber viele Level später, die zur Lösung\n"
"das Anwenden von Funktionen notwendig machen. Dafür ist `rw` nicht "
"geeignet.\n"
"\n"
"Um Funktionen effektiv zu benutzen, müssen wir einiges über eine neue "
"Sammlung von\n"
"Taktiken lernen, nämlich `exact`, `intro`, `have` und `apply`. Diese "
"Taktiken\n"
"sind speziell darauf zugeschnitte, sich mit Funktionen zu beschäftgen. "
"Natürlich wird es\n"
"irgendwann unser Ziel sein mit diesen Taktiken wiederum Sätze\n"
"über die natürlichen Zahlen zu beweisen. In dieser Welt aber\n"
"gibt es keinen Grund dafür, mit einer speziellen Menge wie `mynat` zu "
"arbeiten.\n"
"Alles was wir hier machen funktioniert für eine beliebige allgemeine Menge.\n"
"\n"
"In diesem Level gilt für unsere Notation: $P$, $Q$, $R$, usw. sind beliebige "
"Mengen \n"
"und $h$, $j$, $k$, etc. sind allgemeine\n"
"Funktionen zwischen ihnen. Was wir in dieser Welt lernen werden ist, wie "
"wirFunktionen\n"
"in Lean benutzen können um Elemente zwischen den Mengen hin und "
"herzuschieben. Eine kleine Warnung &ndash; \n"
"Auch wenn es gar kein Problem ist über $P$ als Menge und $p$\n"
"als Element zu denken, wirst du in Lean nicht die Notation $p\\in P$ sehen, "
"weil\n"
"Lean intern $P$ als \"Typ\" und $p$ als \"Term\" speichert. Es benutzt `p : "
"P`\n"
"um zu sagen \"$p$ ist ein Term von Typ $P$\", Leans Weg um die Idee "
"auszudrücken, dass $p$\n"
"ein Element der Menge $P$ ist. Das hast du bereits gesehen &ndash; Lean hat\n"
"`n : mynat` geschrieben, um zu sagen, dass $n$ eine natürliche Zahl ist.\n"
"\n"
"## Eine neue Art von Ziel.\n"
"\n"
"In der gesamten Welt der Addition waren unsere Ziele Sätze\n"
"und es war unsere Aufgabe Beweise für sie zu finden. \n"
"**Die Level in der Welt der Funktionen sind keine Sätze**. Tatsächlich ist "
"dies die einzige Welt, in der\n"
"die Level keine Sätze sind. In der Welt der Funktionen ist das Ziel eines "
"Levels, \n"
"ein Element der Menge im Ziel zu generieren. Das Ziel wird aussehen wie `⊢ "
"X`\n"
"wobei $X$ eine Menge ist und du das Ziel erfüllst, indem du ein Element von "
"$X$ konstruierst. \n"
"Ich weiß nicht, ob es dir aufgefallen ist, aber du hast\n"
"im Prinzip jedes Ziel in der Welt der Addition (und Multiplikation und "
"Potenz, wenn, \n"
"du sie gespielt hast) mit `refl` gelöst.\n"
"Diese Taktik hilft uns hier nicht weiter.\n"
"Wir werden einen neuen Weg finden müssen, um Ziele zu erfüllen; die "
"`exact`Taktik.\n"
"\n"
"Wenn du das sorry unten löscht, dann wird deine Box rechts oben so "
"aussehen: \n"
"\n"
"```\n"
"P Q : Type,\n"
"p : P,\n"
"h : P → Q\n"
"⊢ Q\n"
"```\n"
"\n"
"Wir haben also die Mengen $P$ und $Q$ (Lean nennt sie nur Typen)\n"
"und ein Element $p$ von $P$ (geschrieben als `p : P`,\n"
"aber gemeint ist $p \\in P$). Wir haben außerdem eine Funktion $h$ von $P$ "
"nach $Q$ gegeben\n"
"und unser Ziel ist es, ein\n"
"Element der Menge $Q$ anzugeben. Es ist klar, wie wir *mathematisch* dieses "
"Ziel\n"
"erfüllen würden -- wir können\n"
"ein Element von $Q$ erhalten, indem wir die Funktion $h$ auf\n"
"das Element $p$ anwenden. Aber wie funktioniert das in Lean? Es gibt "
"mindestens zwei Wege,\n"
"wie wir diese Idee Lean begreiflich machen können\n"
"und hier werden wir eine der beiden Möglichkeiten lernen. Nämlich die "
"Methode, die\n"
"die `exact` Taktik benutzt.\n"
"\n"
"## Die `exact` Taktik. \n"
"\n"
"Wenn du explizit sehen kannst, wie du ein Element der Zielmenge angeben "
"kannst,\n"
"du also z.B. eine Formel für sie hast, dann kannst du einfach `exact "
"<formula>` schreiben. \n"
"Das wird dein Ziel direkt erfüllen! \n"
"\n"
"### Beispiel\n"
"\n"
"Wenn dein Kontext so aussieht, \n"
"\n"
"```\n"
"P Q : Type,\n"
"p : P,\n"
"h : P → Q\n"
"⊢ Q\n"
"```\n"
"\n"
"dann ist $h(p)$ ein Element von $Q$, also kannst du einfach \n"
"\n"
"`exact h(p),`\n"
"\n"
"schreiben, um das Ziel zu erfüllen. \n"
"\n"
"## Wichtiger Hinweis:\n"
"\n"
"Beachte, dass `exact h(P)` nicht funktionieren wird (mit einem großen $P"
"$); \n"
"das ist ein häufiger Fehler, den Anfänger machen. \n"
"$P$ ist kein Element von $P$, es ist $p$, das ein Element von $P$ ist. \n"
"\n"
"## Level 1: die `exact` Taktik.\n"

#: Function world level 1
msgid ""
"Given an element of $P$ and a function from $P$ to $Q$,\n"
"we define an element of $Q$.\n"
msgstr ""
"Gegeben ist ein Element von $P$ und eine Funktion von $P$ nach $Q$ \n"
"und wir suchen ein Element von $Q$. \n"

#: Function world level 1
msgid ""
"\n"
"## Summary \n"
"\n"
"If the goal is `⊢ X` then `exact x` will close the goal if\n"
"and only if `x` is a term of type `X`. \n"
"\n"
"## Details\n"
"\n"
"Say $P$, $Q$ and $R$ are types (i.e., what a mathematician\n"
"might think of as either sets or propositions),\n"
"and the local context looks like this: \n"
"\n"
"```\n"
"p : P,\n"
"h : P → Q,\n"
"j : Q → R\n"
"⊢ R\n"
"```\n"
"\n"
"If you can spot how to make a term of type `R`, then you\n"
"can just make it and say you're done using the `exact` tactic\n"
"together with the formula you have spotted. For example the\n"
"above goal could be solved with\n"
"\n"
"`exact j(h(p)),`\n"
"\n"
"because $j(h(p))$ is easily checked to be a term of type $R$\n"
"(i.e., an element of the set $R$, or a proof of the proposition $R$).\n"
"\n"
msgstr ""
"\n"
"## Zusammenfassung \n"
"\n"
"Wenn das Ziel `⊢ X` lautet, dann wird `exact x` dieses Ziel  \n"
"genau dann erfüllen, wenn `x`ein Term vpm Typ `X` ist. \n"
"\n"
"Details\n"
"\n"
"Seien $P$, $Q$ und $R$ Typen (Mathematiker würden sie als \n"
"Mengen oder Aussagen sehen) und unser Kontext sieht so aus: \n"
"\n"
"```\n"
"p : P,\n"
"h : P → Q,\n"
"j : Q → R\n"
"⊢ R\n"
"```\n"
"\n"
"Wenn du siehst, wie du einen Term vom Typ `R` bauen kannst, dann \n"
"kannst du ihn zusammensetzen und mit der `exact` Taktik kombinieren. \n"
"Im obigen Beispiel würde das so aussehen: \n"
"\n"
"`exact j(h(p)),`\n"
"\n"
"Dies liegt daran, dass $j(h(p))$ leicht als Term für den Typ $R$ \n"
"(also ein Element der Menge $R$ oder ein Beweis für die Aussage $R$) \n"
"erkannt werden kann. \n"
"\n"

#: Function world level 2
msgid "import mynat.add -- + on mynat"
msgstr "import mynat.add -- + auf mynat"

#: Function world level 2
msgid "import mynat.mul -- * on mynat"
msgstr "import mynat.mul -- * auf mynat"

#: Function world level 2
msgid ""
"\n"
"## Summary:\n"
"\n"
"`intro p` will turn a goal `⊢ P → Q` into a hypothesis `p : P`\n"
"and goal `⊢ Q`. If `P` and `Q` are sets `intro p` means \"let $p$ be an "
"arbitrary element of $P$\".\n"
"If `P` and `Q` are propositions then `intro p` says \"assume $P$ is true"
"\". \n"
"\n"
"## Details\n"
"\n"
"If your goal is a function or an implication `⊢ P → Q` then `intro`\n"
"will always make progress. `intro p` turns\n"
"\n"
"`⊢ P → Q`\n"
"\n"
"into \n"
"\n"
"```\n"
"p : P\n"
"⊢ Q\n"
"```\n"
"\n"
"The opposite tactic to intro is `revert`; given the situation\n"
"just above, `revert p` turns the goal back into `⊢ P → Q`.\n"
"\n"
"There are two points of view with `intro` -- the\n"
"function point of view (Function World) and the proposition\n"
"point of view (Proposition World).\n"
"\n"
"## Example (functions)\n"
"\n"
"What does it mean to define\n"
"a function? Given an arbitrary term of type `P` (or an element\n"
"of the set `P` if you think set-theoretically) you need\n"
"to come up with a term of type `Q`, so your first step is\n"
"to choose `p`, an arbitary element of `P`. \n"
"\n"
"`intro p,` is Lean's way of saying \"let $p\\in P$ be arbitrary\".\n"
"The tactic `intro p` changes\n"
"\n"
"```\n"
"⊢ P → Q\n"
"```\n"
"\n"
"into\n"
"\n"
"```\n"
"p : P\n"
"⊢ Q\n"
"```\n"
"\n"
"So `p` is an arbitrary element of `P` about which nothing is known,\n"
"and our task is to come up with an element of `Q` (which can of\n"
"course depend on `p`).\n"
"\n"
"## Example (propositions)\n"
"\n"
"If your goal is an implication $P\\implies Q$ then Lean writes\n"
"this as `⊢ P → Q`, and `intro p,` can be thought of as meaning\n"
"\"let $p$ be a proof of $P$\", or more informally \"let's assume that\n"
"$P$ is true\". The goal changes to `⊢ Q` and the hypothesis `p : P`\n"
"appears in the local context.\n"
msgstr ""
"\n"
"## Zusammenfassung:\n"
"\n"
"`intro` wird jedes Ziel `⊢ P → Q` in eine Hypothese `p : P` und ein Ziel \n"
"`⊢ Q` verwandeln. Wenn `P` und `Q` Mengen sind bedeutet `intro p`: \n"
"\" Sei $p$ ein beliebiges Element von $P$\". \n"
"Wenn `P`und `Q` Aussagen sind, dann bedeutet `intro p`: \n"
"\"nimm an, dass $P$ wahr ist\".\n"
"\n"
"## Details\n"
"\n"
"Wenn dein Ziel eine Funktion oder eine Implikation `⊢ P → Q` ist, dann "
"wird \n"
"`intro` immer Fortschritte machen. `intro p` verwandelt \n"
"\n"
"`⊢ P → Q`\n"
"\n"
"in \n"
"\n"
"```\n"
"p : P\n"
"⊢ Q\n"
"```\n"
"\n"
"Die umgekehrte Taktik zu intro ist `revert`. Betrachten wir die obige "
"Situation, \n"
"dann wird `revert p`das Ziel zurück in `⊢ P → Q` verwandeln.\n"
"\n"
"Es gibt zwei Möglichkeiten `intro` zu betachten -- den Funktionsstandpunkt \n"
"(Welt der Funktionen) und den Aussagenstandpunkt (Welt der Aussagen). \n"
"\n"
"## Beispiel (Funktionen) \n"
"\n"
"Was bedeutet es eine Funktion zu definieren? Gegeben ist ein beliebiger \n"
"Term vom Typ `P` (oder ein Element der Menge `P`, wenn du \n"
"mengentheoretisch denkst). Du musst jetzt einen Term vom Typ `Q` \n"
"finden, also muss der erste Schritt sein, ein allgemeines Element `p` \n"
"von `P` zu wählen. \n"
"\n"
"`intro p,` ist Leans Art zu sagen: \"sei $p\\in P$  beliebig\"Die Taktik "
"`intro p` verändert\n"
"```\n"
"⊢ P → Q\n"
"```\n"
"\n"
"zu \n"
"\n"
"```\n"
"p : P\n"
"⊢ Q\n"
"```\n"
"\n"
"Also ist `p` ein beliebiges Element von `P` worüber wir nichts wissen. \n"
"Unsere Aufgabe ist es jetzt ein Element von `Q` zu finden (welches \n"
"natürlich von `p` abhängen kann). \n"
"\n"
"## Beispiel (Aussagen) \n"
"\n"
"Wenn dein Ziel eine Implikation $P\\implies Q$ ist, dann schreibt Lean \n"
"das als `⊢ P → Q` und `intro p` bedeutet: \n"
"\"sei $p$ ein Beweis für $P$\" oder informeller \"nehmen wir an, \n"
"dass $P$ waht ist\". Das Ziel verändert sich zu `⊢ Q` und die Hypothese \n"
"`p : P` erscheint im Kontext. \n"

#: Function world level 2
msgid ""
"# Function world. \n"
"\n"
"## Level 2: the `intro` tactic.\n"
"\n"
"Let's make a function. Let's define the function on the natural\n"
"numbers which sends a natural number $n$ to $3n+2$. If you delete the\n"
"`sorry` you will see that our goal is `mynat → mynat`. A mathematician\n"
"might denote this set with some exotic name such as\n"
"$\\operatorname{Hom}(\\mathbb{N},\\mathbb{N})$,\n"
"but computer scientists use notation `X → Y` to denote the set of\n"
"functions from `X` to `Y` and this name definitely has its merits.\n"
"In type theory, `X → Y` is a type (the type of all functions from $X$ to $Y"
"$),\n"
"and `f : X → Y` means that `f` is a term\n"
"of this type, i.e., $f$ is a function from $X$ to $Y$.\n"
"\n"
"To define a function $X\\to Y$ we need to choose an arbitrary\n"
"element $x\\in X$ and then, perhaps using $x$, make an element of $Y$.\n"
"The Lean tactic for \"let $x\\in X$ be arbitrary\" is `intro x`.\n"
"\n"
"## Rule of thumb: \n"
"\n"
"If your goal is `P → Q` then `intro p` will make progress.\n"
"\n"
"To solve the goal below, you have to come up with a function from `mynat`\n"
"to `mynat`. Start with\n"
"\n"
"`intro n,`\n"
"\n"
"(i.e. \"let $n\\in\\mathbb{N}$ be arbitrary\") and note that our\n"
"local context now looks like this:\n"
"\n"
"```\n"
"n : mynat\n"
"⊢ mynat\n"
"```\n"
"\n"
"Our job now is to construct a natural number, which is\n"
"allowed to depend on $n$. We can do this using `exact` and\n"
"writing a formula for the function we want to define. For example\n"
"we imported addition and multiplication at the top of this file,\n"
"so \n"
"\n"
"`exact 3*n+2,`\n"
"\n"
"will close the goal, ultimately defining the function $f(n)=3n+2$.\n"
"\n"
msgstr ""
"# Welt der Funktionen. \n"
"\n"
"## Level 2: die `intro` Taktik.\n"
"\n"
"Lass uns eine Funktion bauen. Wir definieren eine Funktion auf den "
"natürlichen \n"
"Zahlen, die eine natürliche Zahl $n$ auf $3n+2$ schickt. Wenn du das `sorry` "
"löscht, \n"
"dann wirst du sehen, dass unser Ziel `mynat → mynat` lautet. \n"
"Ein Mathematiker würde das vielleicht mit einem exotischen Namen wie \n"
"$\\operatorname{Hom}(\\mathbb{N},\\mathbb{N})$ bezeichnen. \n"
"Aber Informatiker verwenden die Schreibweise `X → Y`, um die Menge an \n"
"Funktionen von `X` zu `Y` zu schreiben und dieser Name hat definitiv seine "
"Vorzüge. \n"
"In der Typentheorie ist `X → Y` ein Typ (der Typ aller Funktionen von $X$ zu "
"$Y$) \n"
"und `f : X → Y` bedeutet, dass `f` ein Term dieses Typs ist, zum Beispiel "
"ist $f$ \n"
"eine Funktion von $X$ nach $Y$. \n"
"\n"
"Um eine Funktion $X \\to Y$ zu definieren müssen wir ein beliebiges "
"Element \n"
"$x \\in X$ auswählen und dann, möglicherweise mit Hilfe von $x$, ein "
"Element \n"
"von $Y$ konstruieren. \n"
"Die Lean Taktik für \"sei $x \\in X$ beliebig\" ist `intro x`. \n"
"\n"
"## Daumenregel: \n"
"\n"
"Wenn dein Ziel `P → Q` lautet, dann wird `intro p` nützlich sein. \n"
"\n"
"Um das untenstehende Ziel zu lösen musst du eine Funktion von ' mynat' zu \n"
"`mynat` bauen. Starte mit \n"
"\n"
"`intro n,`\n"
"\n"
"(z.B. \"sei $n \\in \\mathbb{N}$ beliebig\") und beachte, dass \n"
"unser lokaler Kontext jetzt so aussieht: \n"
"\n"
"```\n"
"n : mynat\n"
"⊢ mynat\n"
"```\n"
"\n"
"Unsere Aufgabe ist es jetzt, eine natürliche Zahl zu konstruieren, die \n"
"von $n$ abhängen darf. Wir können das mit `exact` lösen und eine Formel \n"
"für die zu definierende Funktion schreiben. \n"
"Beispielsweise haben wir die Addition und die Multiplikation bereits "
"importiert, \n"
"also wird \n"
"\n"
"`exact 3*n+2,`\n"
"\n"
"das Ziel lösen, was uns im Prinzip die Funktion  $f(n)=3n+2$ definiert. \n"

#: Function world level 2
msgid "We define a function from mynat to mynat.\n"
msgstr "Wir definieren eine Funktion von `mynat` zu `mynat`. \n"

#: Function world level 3
msgid ""
"\n"
"## Summary\n"
"\n"
"`have h : P,` will create a new goal of creating a term of type `P`,\n"
"and will add `h : P` to the hypotheses for the goal you were working on.\n"
"\n"
"## Details\n"
"\n"
"If you want to name a term of some type (because you want it\n"
"in your local context for some reason), and if you have the\n"
"formula for the term, you can use `have` to give the term a name. \n"
"\n"
"## Example (`have q := ...` or `have q : Q := ...`)\n"
"\n"
"If the local context contains\n"
"```\n"
"f : P → Q\n"
"p : P\n"
"```\n"
"\n"
"then the tactic `have q := f(p),` will add `q` to our local context,\n"
"leaving it like this:\n"
"\n"
"```\n"
"f : P → Q\n"
"p : P\n"
"q : Q\n"
"```\n"
"\n"
"If you think about it, you don't ever really need `q`, because whenever you\n"
"think you need it you coudl just use `f(p)` instead. But it's good that\n"
"we can introduce convenient notation like this.\n"
"\n"
"## Example (`have q : Q,`)\n"
"\n"
"A variant of this tactic can be used where you just declare the\n"
"type of the term you want to have, finish the tactic statement with\n"
"a comma and no `:=`, and then Lean just adds it as a new goal.\n"
"The number of goals goes up by one if you use `have` like this.\n"
"\n"
"For example if the local context is\n"
"```\n"
"P Q R : Prop/Type,\n"
"f : P → Q,\n"
"g : Q → R,\n"
"p : P\n"
"⊢ R\n"
"```\n"
"\n"
"then after `have q : Q,`, there will be the new goal\n"
"```\n"
"f : P → Q,\n"
"g : Q → R,\n"
"p : P,\n"
"⊢ Q\n"
"```\n"
"\n"
"and your original goal will have `q : Q` added to the list\n"
"of hypotheses.\n"
msgstr ""
"\n"
"## Zusammenfassung \n"
"\n"
"`have h : P,` wird ein neues Ziel erzeugen und ein Term vom Typ `P`ist "
"nötig, \n"
"um es zu erfüllen. Außerdem wird eine Hypothese `h : P` zu deinem "
"derzeitgen \n"
"Ziel hinzugefügt. \n"
"\n"
"## Details\n"
"\n"
"Wenn du einen Term eines Typs bennenen willst (weil du es z.B. in deinem \n"
"lokalen kontext haben willst) und du hast eine Formel für diesen Term, "
"dann \n"
"kannst du `have` zur Benennung verwenden. \n"
"\n"
"## Beispiel (`have q := ...` or `have q : Q := ...`)\n"
"\n"
"Wenn der lokale Kontext ```\n"
"f : P → Q\n"
"p : P\n"
"```\n"
"\n"
"enthält, dann wird die Taktik `have q := f(p),` `q` zu unserem lokalen \n"
"Kontext hinzufügen: \n"
"\n"
"```\n"
"f : P → Q\n"
"p : P\n"
"q : Q\n"
"```\n"
"\n"
"Wenn du darüber nachdenkst, dann brauchst du `q` eigentlich nie, denn du "
"kannst \n"
"stattdessen einfach `f(p)` benutzen. Aber es ist gut, dass wir eine "
"praktische \n"
"Schreibweise wie diese haben. \n"
"\n"
"## Beispiel (`have q : Q,`)\n"
"\n"
"Eine Variante dieser Taktik kann verwendet werden, bei der nur der Typ \n"
" des Terms angegeben wird, den man haben möchte. Beende dazu deine Eingabe \n"
"mit einem Komma und ohne `:=`. Lean fügt es dann als neues Ziel hinzu. \n"
"Die Anzahl der Ziele vergrößert sich dadurch natürlich um eins. \n"
"Ein Beispiel: \n"
"```\n"
"P Q R : Prop/Type,\n"
"f : P → Q,\n"
"g : Q → R,\n"
"p : P\n"
"⊢ R\n"
"```\n"
"\n"
"Nach der Eingabe `have q : Q,`wird dann das folgende Ziel erscheinen: \n"
"```\n"
"f : P → Q,\n"
"g : Q → R,\n"
"p : P,\n"
"⊢ Q\n"
"```\n"
"\n"
"und das ursprüngliche Ziel wird zu `q : Q` in der Liste der Hypothesen "
"werden. \n"

#: Function world level 3
msgid ""
"# Function world. \n"
"\n"
"## Level 3: the `have` tactic.\n"
"\n"
"Say you have a whole bunch of sets and functions between them,\n"
"and your goal is to build a certain element of a certain set.\n"
"If it helps, you can build intermediate elements of other sets\n"
"along the way, using the `have` command. `have` is the Lean analogue\n"
"of saying \"let's define an element $q\\in Q$ by...\" in the middle of a "
"calculation.\n"
"It is often not logically necessary, but on the other hand\n"
"it is very convenient, for example it can save on notation, or\n"
"it can break proofs or calculations up into smaller steps.\n"
"\n"
"In the level below, we have an element of $P$ and we want an element\n"
"of $U$; during the proof we will make several intermediate elements\n"
"of some of the other sets involved. The diagram of sets and\n"
"functions looks like this pictorially:\n"
"\n"
"![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/"
"natural_number_game_images/function_diag.jpg)\n"
"\n"
"and so it's clear how to make the element of $U$ from the element of $P.$\n"
"Indeed, we could solve this level in one move by typing\n"
"\n"
"`exact l(j(h(p))),`\n"
"\n"
"But let us instead stroll more lazily through the level.\n"
"We can start by using the `have` tactic to make an element of $Q$:\n"
"\n"
"`have q := h(p),`\n"
"\n"
"and then we note that $j(q)$ is an element of $T$\n"
"\n"
"`have t : T := j(q),`\n"
"\n"
"(notice how on this occasion we explicitly told Lean what set we thought $t$ "
"was in, with\n"
"that `: T` thing before the `:=`) and we could even define $u$ to be "
"$l(t)$:\n"
"\n"
"`have u : U := l(t),`\n"
"\n"
"and then finish the level with\n"
"\n"
"`exact u,`\n"
"\n"
". \n"
msgstr ""
"# Function world. \n"
"\n"
"## Level 3: die `have` Taktik.\n"
"\n"
"Sagen wir, wir haben eine ganze Menge an Mengen und Funktionen zwischen "
"ihnen. \n"
"Außerdem soll das Ziel sein, ein bestimmtes Element einer bestimmten menge "
"zu erzeugen. \n"
"Wenn es hilft, können wir dazwischenliegende Elemente anderer Mengen "
"bestimmen. \n"
"Dazu können wir wieder `have` verwenden. `have` ist das Lean Äquivalent zu "
"sagen: \n"
"\"Wir definieren ein Element $q\\in Q$ mit... \". \n"
"Es ist häufig nicht logisch notwendig, aber auf der anderen Seite ist es "
"sehr praktisch. \n"
"Es kann z.B. einiges an Notation sparen oder den Beweis in kleinere Teile "
"teilen. \n"
"\n"
"Im untenstehenden Level haben wir ein Element von $P$ und wir wollen ein "
"Element von $U$ \n"
"konstruieren; während des Beweises werden wir verschiedene Zwischenelemente "
"anderer \n"
"Mengen verwenden. Das Diagramm der Mengen und Funktionen sieht so aus: \n"
"\n"
"![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/"
"natural_number_game_images/function_diag.jpg)\n"
"\n"
"Wir können den Weg von $P$ nach $U$ so leicht nachvollziehen! \n"
"Tatsächlich könnten wir dieses Level sofort lösen, indem wir schreiben: \n"
"\n"
"`exact l(j(h(p))),`\n"
"\n"
"Aber lass uns etwas langsamer durch das Level wandern. \n"
"Wir beginnen, indem wir die `have`Taktik verwenden, um ein Element von $Q$ "
"zu erzeugen: \n"
"\n"
"`have q := h(p),`\n"
"\n"
"Jetzt können wir erkennen, dass $j(q)$ ein Element von $T$ ist: \n"
"\n"
"`have t : T := j(q),`\n"
"\n"
"(Beachte: wir haben Lean explizit gesagt, welche Menge $t$ enthält, indem "
"wir \n"
"dieses `: T` Ding vor das `:=` geschrieben haben.) Ähnlich geht es mit $u$ "
"weiter: \n"
"\n"
"`have u : U := l(t),`\n"
"\n"
"Und zum Schluss: \n"
"\n"
"`exact u,`\n"
"\n"

#: Function world level 3 4
msgid "Given an element of $P$ we can define an element of $U$.\n"
msgstr ""
"Gegeben sei ein Element von $P$, dann können wir ein Element von $U$ "
"konstruieren. \n"

#: Function world level 3
msgid ""
"If you solved the level using `have`, then click on the last line of your "
"proof\n"
"(you do know you can move your cursor around with the arrow keys\n"
"and explore your proof, right?) and note that the local context at that "
"point\n"
"is in something like the following mess:\n"
"\n"
"```\n"
"P Q R S T U : Type,\n"
"p : P,\n"
"h : P → Q,\n"
"i : Q → R,\n"
"j : Q → T,\n"
"k : S → T,\n"
"l : T → U,\n"
"q : Q,\n"
"t : T,\n"
"u : U\n"
"⊢ U\n"
"```\n"
"\n"
"It was already bad enough to start with, and we added three more\n"
"terms to it. In level 4 we will learn about the `apply` tactic\n"
"which solves the level using another technique, without leaving\n"
"so much junk behind.\n"
msgstr ""
"Wenn du das Level mit `have` gelöst hast, dann klicke in die letzten Zeile \n"
"deines Beweises. (Du erinnerst dich, dass du die Pfeiltasten nutzen "
"kannst, \n"
"um deinen Beweis zu erkunden, oder?) Der Kontext dieser letzten Zeile "
"sieht \n"
"etwa so aus: \n"
"```\n"
"P Q R S T U : Type,\n"
"p : P,\n"
"h : P → Q,\n"
"i : Q → R,\n"
"j : Q → T,\n"
"k : S → T,\n"
"l : T → U,\n"
"q : Q,\n"
"t : T,\n"
"u : U\n"
"⊢ U\n"
"```\n"
"\n"
"Es war am Anfang schon schlimm, aber wir haben drei weitere Terme ergänzt! \n"
"In Level 4 werden wir lernen, wie die `apply` Taktik funktioniert. So kann \n"
"man das Level einfacher lösen, ohne soviel Müll zurückzulassen. \n"

#: Function world level 4
msgid ""
"\n"
"## Summary\n"
"\n"
"If `h : P → Q` is a hypothesis, and the goal is `⊢ Q` then\n"
"`apply h` changes the goal to `⊢ P`. \n"
"\n"
"## Details\n"
"\n"
"If you have a function `h : P → Q` and your goal is `⊢ Q`\n"
"then `apply h` changes the goal to `⊢ P`. The logic is\n"
"simple: if you are trying to create a term of type `Q`,\n"
"but `h` is a function which turns terms of type `P` into\n"
"terms of type `Q`, then it will suffice to construct a\n"
"term of type `P`. A mathematician might say: \"we need\n"
"to construct an element of $Q$, but we have a function $h:P\\to Q$\n"
"so it suffices to construct an element of $P$\". Or alternatively\n"
"\"we need to prove $Q$, but we have a proof $h$ that $P\\implies Q$\n"
"so it suffices to prove $P$\".\n"
"\n"
msgstr ""
"\n"
"## Zusammenfassung\n"
"\n"
"Wenn `h : P → Q` eine Hypothese und `⊢ Q` das Ziel ist, dann wird \n"
"`apply h` das Ziel zu `⊢ P` verändern. \n"
"\n"
"## Details\n"
"\n"
"Wenn du eine Funktion `h : P → Q` hast und dein Ziel `⊢ Q` ist, \n"
"dann wird `apply  h`das Ziel ändern zu: `⊢ P`. Die Logik dahinter ist \n"
"recht einfach: wenn du einen Term vom Typ `Q` erzeugen möchtest \n"
"und `h` eine Funktion ist, die Terme vom Typ `P` in den Typ `Q` \n"
"verwandelt, dann wird das ausreichen, um einen Term vom Typ `P` zu \n"
"bastlen!. Ein Mathematiker würde sagen: \" Wir müssen ein Element \n"
"von $Q$ konstruieren, aber wir haben eine Funktion $h:P\\to Q$, \n"
"also genügt es, ein Element von $P$ zu erzeugen.\". Oder alternativ: \n"
"\"Wir müssen $Q$ beweisen, aber wir haben einen Beweis $h$, der zeigt: \n"
"$P\\implies Q$, also genügt es $P$ zu beweisen. \". \n"

#: Function world level 4
msgid ""
"\n"
"# Function world. \n"
"\n"
"## Level 4: the `apply` tactic.\n"
"\n"
"Let's do the same level again:\n"
"\n"
"![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/"
"natural_number_game_images/function_diag.jpg)\n"
"\n"
"We are given $p \\in P$ and our goal is to find an element of $U$, or\n"
"in other words to find a path through the maze that links $P$ to $U$.\n"
"In level 3 we solved this by using `have`s to move forward, from $P$\n"
"to $Q$ to $T$ to $U$. Using the `apply` tactic we can instead construct\n"
"the path backwards, moving from $U$ to $T$ to $Q$ to $P$.\n"
"\n"
"Our goal is to construct an element of the set $U$. But $l:T\\to U$ is\n"
"a function, so it would suffice to construct an element of $T$. Tell\n"
"Lean this by starting the proof below with\n"
"\n"
"`apply l,`\n"
"\n"
"and notice that our assumptions don't change but *the goal changes*\n"
"from `⊢ U` to `⊢ T`. \n"
"\n"
"Keep `apply`ing functions until your goal is `P`, and try not\n"
"to get lost! Now solve this goal\n"
"with `exact p`. Note: you will need to learn the difference between\n"
"`exact p` (which works) and `exact P` (which doesn't, because $P$ is\n"
"not an element of $P$).\n"
msgstr ""
"\n"
"# Welt der Funktionen. \n"
"\n"
"## Level 4: Die `apply` Taktik.\n"
"\n"
"Lass uns dasselbe Level nochmal machen:\n"
"\n"
"![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/"
"natural_number_game_images/function_diag.jpg)\n"
"\n"
"Wir haben $p \\in P$ gegeben und unser Ziel ist es, ein Element von $U$ \n"
"zu finden. Mit anderen Worten: Wir suchen uns einen Weg durch das "
"Labyrinth \n"
"von $P$ nach $U$. Im dritten level haben wir das Level mit `have` gelöst. \n"
"Wir haben uns dabei langsam durch das Labyrinth von $P$ nach $Q$ nach $T$ "
"nach $U$ bewegt. \n"
"Wenn wir die `apply` Taktik nutzen, können wir stattdessen einen Weg "
"rückwärts, \n"
"also von $U$ nach $T$ nach $Q$ nach $P$ bewegen. \n"
"\n"
"Unser Ziel ist es, ein Element der Menge $U$ zu konstruieren. Aber $l:T\\to U"
"$ ist \n"
" eine Funktion, also wird es genügen, ein Element von $T$ zu konstruieren. \n"
"Das kannst du Lean sagen, indem wir den Beweis wie folgt starten: \n"
"\n"
"`apply l,`\n"
"\n"
"Wir bemekeren, dass unsere Annahmen sich nicht verändert haben, aber das "
"Ziel! \n"
"von `⊢ U` zu `⊢ T`. \n"
"\n"
"Mache genau so weiter und benutze `apply`, bis dein Ziel nur noch `P` ist. \n"
"Versuche nicht verloren zu gehen! Am Ende löse mit `exact p`.\n"
"Anmerkung: `exact p` funktioniert, `exact P` aber nicht, weil $P$ kein "
"Element \n"
"von $P$ ist! \n"

#: Function world level 5
msgid ""
"# Function world. \n"
"\n"
"## Level 5: `P → (Q → P)`.\n"
"\n"
"In this level, our goal is to construct a function, like in level 2.\n"
"\n"
"```\n"
"⊢ P → (Q → P)\n"
"```\n"
"\n"
"So $P$ and $Q$ are sets, and our goal is to construct a function\n"
"which takes an element of $P$ and outputs a function from $Q$ to $P$.\n"
"We don't know anything at all about the sets $P$ and $Q$, so initially\n"
"this seems like a bit of a tall order. But let's give it a go. Delete\n"
"the `sorry` and let's think about how to proceed.\n"
"\n"
"Our goal is `P → X` for some set $X=\\operatorname{Hom}(Q,P)$, and if our\n"
"goal is to construct a function then we almost always want to use the\n"
"`intro` tactic from level 2, Lean's version of \"let $p\\in P$ be arbitrary."
"\"\n"
"So let's start with\n"
"\n"
"`intro p,`\n"
"\n"
"and we then find ourselves in this state:\n"
"\n"
"```\n"
"P Q : Type,\n"
"p : P\n"
"⊢ Q → P\n"
"```\n"
"\n"
"We now have an arbitrary element $p\\in P$ and we are supposed to be "
"constructing\n"
"a function $Q\\to P$. Well, how about the constant function, which sends "
"everything to $p$?\n"
"This will work. So let $q\\in Q$ be arbitrary:\n"
"\n"
"`intro q,`\n"
"\n"
"and then let's output `p`.\n"
"\n"
"`exact p,`\n"
msgstr ""
"# Welt der Funktionen. \n"
"\n"
"## Level 5: `P → (Q → P)`.\n"
"\n"
"In diesem Level wollen wir eine Funktion wie in Level 2 konstruieren. \n"
"\n"
"```\n"
"⊢ P → (Q → P)\n"
"```\n"
"\n"
"$P$ und $Q$ are Mengen und unser Ziel ist es, eine Funktion zu "
"konstruieren, \n"
"die ein Element von $P$ als Eingabe hat und eine Funktion von $Q$ nach $P$ "
"als \n"
"Ausgabe. Wir wissen nichts über die Mengen $P$ und $Q$, auf den ersten "
"Blick \n"
"wirkt dies wie eine recht anspruchsvolle Aufgabe. Aber wir versuchen es "
"trotzdem. \n"
"Lösche das `sorry` und denken wir über das weitere Vorgehen nach. \n"
"\n"
"Unser Ziel ist `P → X` für eine Menge $X=\\operatorname{Hom}(Q,P)$. \n"
"Wenn unser Ziel die Konstruktion einer Funktion ist, dann wollen wir fast \n"
"immer die `intro` Taktik aus Level 2 verwenden, also Leans Version von: \n"
"\"Sei $p\\in P$ beliebig:\"\n"
"Fangen wir also an: \n"
"\n"
"`intro p,`\n"
"\n"
"Dann finden wir uns plötzlich hier wieder: \n"
"\n"
"```\n"
"P Q : Type,\n"
"p : P\n"
"⊢ Q → P\n"
"```\n"
"\n"
"Wir haben jetzt ein beliebiges Element $p \\in P$ und wir sollen eine \n"
"Funktion $Q\\to P$ konstruieren. Na ja, wir könnten zum Beispiel eine "
"konstante \n"
"Funktion definieren, die alles immer auf $p$ abbildet. \n"
"Das wird funktionieren, also sei $q \\in Q$ ein beliebiges Element: \n"
"\n"
"`intro q,`\n"
"\n"
"Dann können wir jetzt `p` ausgeben. \n"
"\n"
"`exact p,`\n"

#: Function world level 5
msgid ""
"We define an element of $\\operatorname{Hom}(P,\\operatorname{Hom}(Q,P))$.\n"
msgstr ""
"Wir definieren ein Element von $\\operatorname{Hom}(P,\\operatorname{Hom}(Q,"
"P))$. \n"

#: Function world level 5
msgid ""
"A mathematician would treat the set `P → (Q → P)` as the same as the set `P "
"× Q → P`,\n"
"because to give an element of either function space is just to give a rule "
"which takes\n"
"an element of $P$ and an element of $Q$, and returns an element of $P$. "
"Thinking of the\n"
"goal as a function from `P × Q` to `P` we realise that it's just projection "
"onto the first\n"
"factor.\n"
"\n"
"## Did you notice?\n"
"\n"
"I wrote `P → (Q → P)` but Lean just writes `P → Q → P`. This is because\n"
"computer scientists adopt the convention that `→` is *right associative*,\n"
"which is a fancy way of saying \"when we write `P → Q → R`, we mean `P → (Q "
"→ R)`.\"\n"
"Mathematicians use right associativity as a convention for powers: if\n"
"a mathematician says $10^{10^{10}}$ they don't mean $(10^{10})^{10}"
"=10^{100}$, they\n"
"mean $10^{(10^{10})}$. So `10 ^ 10 ^ 10` in Lean means `10 ^ (10 ^ 10)` and "
"not `(10 ^ 10) ^ 10`.\n"
"However they use left associativity as a convention for subtraction: if\n"
"a mathematician writes $6 - 2 - 1$ they mean $(6 - 2) - 1$ and not $6 - (2 - "
"1)$.\n"
"\n"
"## Pro tip\n"
"\n"
"`intros p q,` is the same as `intro p, intro q,`.\n"
msgstr ""
"Ein Mathematiker würde die Menge `P → (Q → P)` genauso wie die Menge \n"
"`P × Q → P` behandeln. Das liegt daran, dass die Angabe eines Elements \n"
"eines Funktionenraums nur bedeutet, dass eine Regel angegeben werden muss, \n"
"die ein Element von $P$ und ein Element von $Q$ nimmt und ein Element von \n"
"$P$ wieder ausgibt. Denken wir an das Ziel als Funktion von `P × Q nach "
"`P`, \n"
"so können wir verstehen, dass es nur die Projektion auf den ersten Faktor "
"ist! \n"
"\n"
"## Hast du es bemerkt? \n"
"\n"
"Ich habe `P → (Q → P)` geschrieben, aber Lean schreibt nur `P → Q → P`. \n"
"Das liegt daran, dass Informatiker die Konvention benutzen, dass `→` \n"
"rechtsassoziativ ist. Das ist wieder nur eine schlaue Art zu sagen: \n"
"\" wenn wir `P → Q → R` schreiben, dann meinen wir `P → (Q → R)` \" \n"
"Mathematiker benutzen Rechtsassoziativität als eine Konvention für "
"Potenzen: \n"
"wenn ein Mathematiker $10^{10^{10}} sagt, dann meint er nicht \n"
"$(10^{10})^{10}=10^{100}, sondern $10^{(10^{10})}$. In Lean ist `10 ^ 10 ^ "
"10` \n"
"also `10 ^ (10 ^ 10)` und nicht `(10 ^ 10) ^ 10`. \n"
"Leider nutzen Mathematiker Linksassoziativität für Differenzen: \n"
"wenn ein Mathematiker $6-2-1$ schreibt, meinen sie $(6-2)-1$ und nicht \n"
"$6-(2-1)$. \n"
"##Profi Tipp: \n"
"\n"
"`intros p q,` ist das Gleiche wie: `intro p, intro q,`.\n"

#: Function world level 6
msgid ""
"# Function world. \n"
"\n"
"## Level 6: `(P → (Q → R)) → ((P → Q) → (P → R))`.\n"
"\n"
"You can solve this level completely just using `intro`, `apply` and "
"`exact`,\n"
"but if you want to argue forwards instead of backwards then don't forget\n"
"that you can do things like\n"
"\n"
"`have j : Q → R := f p,`\n"
"\n"
"if `f : P → (Q → R)` and `p : P`. Remember the trick with the colon in "
"`have`:\n"
"we could just write `have j := f p,` but this way we can be sure that `j` "
"is\n"
"what we actually expect it to be.\n"
"\n"
"I recommend that you start with `intro f` rather than `intro p`\n"
"because even though the goal starts `P → ...`, the brackets mean that\n"
"the goal is not a function from `P` to anything, it's a function from\n"
"`P → (Q → R)` to something. In fact you can save time by starting\n"
"with `intros f h p`, which introduces three variables at once, although "
"you'd\n"
"better then look at your tactic state to check that you called all those "
"new\n"
"terms sensible things. \n"
"\n"
"After all the intros, you find that your your goal is `⊢ R`. If you try "
"`have j : Q → R := f p`\n"
"now then you can `apply j`. Alternatively you can `apply (f p)` directly.\n"
"What happens if you just try `apply f`? Can you figure out what just "
"happened? This is a little\n"
"`apply` easter egg. Why is it mathematically valid?\n"
msgstr ""
"# Welt der Funktionen \n"
"\n"
"## Level 6: `(P → (Q → R)) → ((P → Q) → (P → R))`.\n"
"\n"
"Du kannst diese Level komplett mit `intro`, `apply` und `exact` lösen. \n"
"Wemm du vorwärts statt rückwärts argumentieren willst, dann vergiss nicht, \n"
"dass du auch solche Dinge tun kannst: \n"
"\n"
"`have j : Q → R := f p,`\n"
"\n"
"if `f : P → (Q → R)` and `p : P`. Denk an den Trick mit dem Doppelpunkt in \n"
"`have`:\n"
"Wir könnten nur `have j := f p,` schreiben, aber andernfalls können wir \n"
"sicher sein, dass `j` genau das ist, was wir auch erwarten. \n"
"\n"
"Ich empfehle, dass du mit `intro f` startest und nicht mit `intro p`.\n"
"Das Ziel startet zwar mit `P → ...`, die Klammern bedeuten aber, dass \n"
"das Ziel keine Funktion von `P` irgendwohin ist, sondern eine Funktion von \n"
"`P → (Q → R)` irgendwohin! Tatsächlich kannst du dir Zeit sparen, indem du \n"
"mit `intros f h p` startest. Dadurch werden drei Variablen auf einmal "
"erzeugt, \n"
"allerdings solltest du besser genau hinsehen und überprüfen, ob alle diese \n"
"neuen Terme wirklich vernünftige Dinge sind. \n"
"\n"
"Nach den ganzen Intros ist unser Ziel `⊢ R`. Wenn du \n"
"`have j : Q → R := f p`\n"
"versuchst, kannst du danach `apply j` schreiben. Alternativ funktioniert "
"auch \n"
"`apply (f p)` direkt. \n"
"Was passiert, wenn du nur `apply f` versuchst? Kannst du dir vorstellen, was "
"gerade \n"
"passiert ist? Es ist ein kleines `apply` easter egg. Warum ist es "
"mathematisch sinnvoll? \n"

#: Function world level 6
msgid ""
"Whatever the sets $P$ and $Q$ and $R$ are, we\n"
"make an element of $\\operatorname{Hom}(\\operatorname{Hom}(P,"
"\\operatorname{Hom}(Q,R)),\n"
"\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\\operatorname{Hom}(P,R)))$.\n"
msgstr ""
"Seien $P$ und $Q$ und $R$ beliebige Mengen, dann bauen wir ein \n"
"Element von $\\operatorname{Hom}(\\operatorname{Hom}(P,\\operatorname{Hom}(Q,"
"R)),\n"
"\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\\operatorname{Hom}(P,R)))$.\n"

#: Function world level 7
msgid ""
"# Function world. \n"
"\n"
"## Level 7: `(P → Q) → ((Q → F) → (P → F))` \n"
"\n"
"Have you noticed that, in stark contrast to earlier worlds,\n"
"we are not amassing a large collection of useful theorems? \n"
"We really are just constructing abstract levels with sets and\n"
"functions, and then solving them and never using the results\n"
"ever again. Here's another one, which should hopefully be\n"
"very easy for you now. Advanced mathematician viewers will\n"
"know it as contravariance of $\\operatorname{Hom}(\\cdot,F)$\n"
"functor.\n"
msgstr ""
"# Welt der Funktionen. \n"
"\n"
"## Level 7: `(P → Q) → ((Q → F) → (P → F))` \n"
"\n"
"Hast du bemerkt, dass wir im Gegensatz zu früheren Welten kein \n"
"große Menge an nützlichen Sätzen angefhäuft haben? \n"
"We haben eigentlich nur abstrakte Level mit Mengen und Funktionen \n"
"bearbeitet und diese dann gelöst, ohne auf die vorhergehenden \n"
"Ergebnisse Bezug zu nehmen. Hier ist jetzt ein weiteres Problem, \n"
"dass hofentlich sehr einfach für dich ist. Fortgeschrittene Mathematiker \n"
"werden es natürlich als die Kontravarianz des $\\operatorname{Hom}(\\cdot,"
"F)$\n"
"Funktors erkennen. \n"

#: Function world level 7
msgid ""
"Whatever the sets $P$ and $Q$ and $F$ are, we \n"
"make an element of $\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\n"
"\\operatorname{Hom}(\\operatorname{Hom}(Q,F),\\operatorname{Hom}(P,F)))$.\n"
msgstr ""
"Seien $P$, $Q$ und $F$ beliebige Mengen, dann bauen wir \n"
"Element von $\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\n"
"\\operatorname{Hom}(\\operatorname{Hom}(Q,F),\\operatorname{Hom}(P,F)))$.\n"

#: Function world level 8
msgid ""
"# Function world. \n"
"\n"
"## Level 8: `(P → Q) → ((Q → empty) → (P → empty))` \n"
"\n"
"Level 8 is the same as level 7, except we have replaced the\n"
"set $F$ with the empty set $\\emptyset$. The same proof will work (after "
"all, our\n"
"previous proof worked for all sets, and the empty set is a set).\n"
"But note that if you start with `intro f, intro h, intro p,`\n"
"(which can incidentally be shortened to `intros f h p`),\n"
"then the local context looks like this:\n"
"\n"
"```\n"
"P Q : Type,\n"
"f : P → Q,\n"
"h : Q → empty,\n"
"p : P\n"
"⊢ empty\n"
"```\n"
"\n"
"and your job is to construct an element of the empty set!\n"
"This on the face of it seems hard, but what is going on is that\n"
"our hypotheses (we have an element of $P$, and functions $P\\to Q$\n"
"and $Q\\to\\emptyset$) are themselves contradictory, so\n"
"I guess we are doing some kind of proof by contradiction at this point? "
"However,\n"
"if your next line is `apply h` then all of a sudden the goal\n"
"seems like it might be possible again. If this is confusing, note\n"
"that the proof of the previous world worked for all sets $F$, so in "
"particular\n"
"it worked for the empty set, you just probably weren't really thinking "
"about\n"
"this case explicitly beforehand. [Technical note to constructivists: I know\n"
"that we are not doing a proof by contradiction. But how else do you explain\n"
"to a classical mathematician that their goal is to prove something false\n"
"and this is OK because their hypotheses don't add up?]\n"
"\n"
msgstr ""
"# Welt der Funktionen. \n"
"\n"
"## Level 8: `(P → Q) → ((Q → empty) → (P → empty))` \n"
"\n"
"Level 9 ist im Prinzip dasselbe Level wie Level 7. Wir haben aber die "
"Menge \n"
"$F$ mit der leeren menge $\\emptyset$ ersetzt. Der Beweis wird genau wie "
"vorher \n"
"funktionieren. (Unser vorheriger Beweis hat schließlich für alle Mengen \n"
"funktioniert und die leere Menge ist eine Menge!) \n"
"Beachte aber, dass der lokale Kontext wie folgt aussieht, wenn du mit \n"
"`intro f, intro h, intro p,` (kurz `intros f h p`) beginnst: \n"
"\n"
"```\n"
"P Q : Type,\n"
"f : P → Q,\n"
"h : Q → empty,\n"
"p : P\n"
"⊢ empty\n"
"```\n"
"\n"
"Dein Job ist es jetzt, ein Element der leeren Menge zu konstruieren! \n"
"Das sieht, wieder einmal, recht kompliziert aus, aber was wirklich passiert "
"ist, \n"
"dass unsere Hypothesen (wir haben ein Element von $P$ und Funktionen $P \\to "
"Q$ \n"
"und $Q \\to \\emptyset$) in sich schon widersprüchlich sind. \n"
"Wir führen also einen Beweis durch Widerspruch an dieser Stelle? \n"
"Sollte deine nächste Zeile `apply h`sein, dann sieht dein Ziel plötzlich \n"
"wieder machbar aus. Sollte dich das verwirren, dann beachte, dass \n"
"der Beweis der vorherigen Welt für alle Mengen $F$ funktioniert hat. \n"
"Insbesondere also auch für die leere Menge, wir haben nur nicht an diesen \n"
"Fall direkt gedacht! \n"
"[Technische Notiz für Konstruktivisten: Ich weiß, dass wir hier \n"
"nicht wirklich einen Beweis durch Widerspruch durchführen. Aber wie sollte \n"
"man sonst einem klassischen Mathematiker erklären, dass es ihr Ziel ist, \n"
"etwas falsches zu beweisen und das es in Ordnung ist, weil ihre Hypothesen \n"
"nicht zusammenpassen?] \n"
"\n"

#: Function world level 8
msgid ""
"Whatever the sets $P$ and $Q$ are, we\n"
"make an element of $\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\n"
"\\operatorname{Hom}(\\operatorname{Hom}(Q,\\emptyset),\\operatorname{Hom}(P,"
"\\emptyset)))$.\n"
msgstr ""
"Seien $P$ und $Q$ beliebige Mengen, dann bauen wir \n"
"ein Element von $\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\n"
"\\operatorname{Hom}(\\operatorname{Hom}(Q,\\emptyset),\\operatorname{Hom}(P,"
"\\emptyset)))$.\n"

#: Function world level 9
msgid ""
"# Function world. \n"
"\n"
"## Level 9: a big maze. \n"
"\n"
"I asked around on Zulip and apparently there is not a tactic for this, "
"perhaps because\n"
"this level is rather artificial. In world 6 we will see a variant of this "
"example\n"
"which can be solved by a tactic. It would be an interesting project to make "
"a tactic\n"
"which could solve this sort of level in Lean.\n"
"\n"
"You can of course work both forwards and backwards, or you could crack and "
"draw a picture.\n"
"\n"
msgstr ""
"# Welt der Funktionen. \n"
"\n"
"## Level 9: ein großes Labyrinth. \n"
"\n"
"I habe auf Zulip herumgefragt und scheinbar gibt es keine Taktik hierfür. \n"
"Vielleicht liegt es daran, dass dieses Level eher künstlich ist. In Welt \n"
"Nummer 6 werden wir eine Variante dieses Beispiels sein, das mit einer "
"Taktik \n"
"lösbar ist. Es wäre ein interessantes Projekt, eine Taktik zu entwickeln, "
"die diese \n"
"Art Level in Lean lösen kann. Du kannst natürlich vorwärts oder rückwärts "
"arbeiten, oder aufgeben und ein Bild \n"
"malen! \n"
"\n"

#: Function world level 9
msgid "Given a bunch of functions, we can define another one.\n"
msgstr "Haben wir einige Funktionen, so können wir eine neue definieren. \n"

#: Function world level 9
msgid ""
"That's the end of Function World! Next it's Proposition world, and the "
"tactics you've learnt in Function World are enough\n"
"to solve all nine levels! In fact, the levels in Proposition world might "
"look strangely familiar$\\ldots$.\n"
msgstr ""
"Dies ist das Ende der Welt der Funktionen! Als nächstes sind wir in der "
"Welt \n"
"der Aussagen und die Taktiken, die du in der Welt der Funktionen gelernt "
"hast, \n"
"sind ausreichend, um alle neun Level zu lösen! Tatsächlich sollten die "
"Level \n"
"seltsam bekannt aussehen $\\ldots$. \n"

#: world_config
msgid "Proposition world"
msgstr "Welt der Aussagen"

#: Proposition world level 1
msgid ""
"\n"
"# Proposition world. \n"
"\n"
"A Proposition is a true/false statement, like `2 + 2 = 4` or `2 + 2 = 5`.\n"
"Just like we can have concrete sets in Lean like `mynat`, and abstract\n"
"sets called things like `X`, we can also have concrete propositions like\n"
"`2 + 2 = 5` and abstract propositions called things like `P`. \n"
"\n"
"Mathematicians are very good at conflating a theorem with its proof.\n"
"They might say \"now use theorem 12 and we're done\". What they really\n"
"mean is \"now use the proof of theorem 12...\" (i.e. the fact that we "
"proved\n"
"it already). Particularly problematic is the fact that mathematicians\n"
"use the word Proposition to mean \"a relatively straightforward statement\n"
"which is true\" and computer scientists use it to mean \"a statement of\n"
"arbitrary complexity, which might be true or false\". Computer scientists\n"
"are far more careful about distinguishing between a proposition and a "
"proof.\n"
"For example: `x + 0 = x` is a proposition, and `add_zero x`\n"
"is its proof. The convention we'll use is capital letters for propositions\n"
"and small letters for proofs. \n"
"\n"
"In this world you will see the local context in the following kind of "
"state:\n"
"\n"
"```\n"
"P : Prop\n"
"p : P\n"
"```\n"
"\n"
"Here `P` is the true/false statement (the statement of proposition), and `p` "
"is its proof.\n"
"It's like `P` being the set and `p` being the element. In fact computer "
"scientists\n"
"sometimes think about the following analogy: propositions are like sets,\n"
"and their proofs are like their elements. \n"
"\n"
"## What's going on in this world? \n"
"\n"
"We're going to learn about manipulating propositions and proofs.\n"
"Fortunately, we don't need to learn a bunch of new tactics -- the\n"
"ones we just learnt (`exact`, `intro`, `have`, `apply`) will be perfect.\n"
"\n"
"The levels in proposition world are \"back to normal\", we're proving\n"
"theorems, not constructing elements of sets. Or are we?\n"
"\n"
"If you delete the sorry below then your local context will look like this:\n"
"\n"
"```\n"
"P Q : Prop,\n"
"p : P,\n"
"h : P → Q\n"
"⊢ Q\n"
"```\n"
"\n"
"In this situation, we have true/false statements $P$ and $Q$,\n"
"a proof $p$ of $P$, and $h$ is the hypothesis that $P\\implies Q$.\n"
"Our goal is to construct a proof of $Q$. It's clear what to do\n"
"*mathematically* to solve this goal, $P$ is true and $P$ implies $Q$\n"
"so $Q$ is true. But how to do it in Lean?\n"
"\n"
"Adopting a point of view wholly unfamiliar to many mathematicians,\n"
"Lean interprets the hypothesis $h$ as a function from proofs\n"
"of $P$ to proofs of $Q$, so the rather surprising approach\n"
"\n"
"`exact h(p),`\n"
"\n"
"works to close the goal.\n"
"\n"
"Note that `exact h(P),` (with a capital P) won't work;\n"
"this is a common error I see from beginners. \"We're trying to solve `P`\n"
"so it's exactly `P`\". The goal states the *theorem*, your job is to\n"
"construct the *proof*. $P$ is not a proof of $P$, it's $p$ that is a proof "
"of $P$. \n"
"\n"
"In Lean, Propositions, like sets, are types, and proofs, like elements of "
"sets, are terms.\n"
"\n"
"## Level 1: the `exact` tactic.\n"
msgstr ""
"\n"
"# Proposition world. \n"
"\n"
"Eine Aussage kann wahr oder falsch sein, wie `2 + 2 = 4` oder `2 + 2 = 5`. \n"
"Genauso wie wir konkrete Mengen in Lean haben können wie `mynat`und "
"abstrakte Mengen \n"
"wie `X`, können wir auch konkrete Aussagen haben wie `2 + 2 = 5` und "
"abstrakte Aussagen \n"
"wie `P` \n"
"\n"
"Mathematiker sind sehr gut darin, ihre Sätze mit dem Beweis zu "
"verschmelzen. \n"
"Sie sagen zum Beispiel: \"Wir verwenden jetzt Satz 12 und sind fertig \" \n"
"Was sie aber wirklich meinen ist: \"Jetzt verwenden wir den Beweis von Satz "
"12 \n"
"und sind fertig \" (also die Tatsache, dass dieser Satz schon bewiesen "
"ist!) \n"
"Die Tatsache, dass Mathematiker das Wort Aussage im Sinne von \n"
"\" es ist eine Aussage von beliebiger Komplexität, die wahr oder falsch ist"
"\" \n"
"verwenden ist besonders problematisch. Informatiker sind in der Regel "
"wesentlich \n"
"vorsichtiger in dieser Beziehung. \n"
"Zum Beispiel: `x+0=x` ist eine Aussage und `add_zero x' ist der Beweis. \n"
"Wir werden die Konvention verwenden, dass Großbuchstaben für Aussagen und \n"
"Kleinbuchstaben für Beweise stehen. \n"
"\n"
"In dieser Welt wird der lokale Kontext oft so aussehen: \n"
"\n"
"```\n"
"P : Prop\n"
"p : P\n"
"```\n"
"\n"
"`P` ist dabei die Wahr/Falsch Aussage und `p` der zugehörige Beweis. \n"
"Es ist wie mit der Menge `P` und dem Element der Menge `p`. \n"
"Tatsächlich ist für Informatiker die folgende Analogie oft sehr nützlich: \n"
"Aussagen sind wie Mengen und Beweise sind wie deren Elemente. \n"
"\n"
"## Was passiert in dieser Welt? \n"
"\n"
"Wir werden lernen, wie wir Aussagen und Beweise manipulieren können. \n"
"Glücklicherweise müssen wir keine neuen Taktiken lernen -- die Taktiken \n"
"Aus der Welt der Funktionen sind perfekt (`exact`, `intro`, `have`, "
"`apply`). \n"
"n\n"
"Die Level in der Welt der Aussagen sind wieder \"wie gewohnt \". Wir "
"beweisen \n"
"Sätze und konstruieren keine Elemente von Mengen... oder doch? \n"
"\n"
"Wenn du das sorry löscht, dann wird dein Kontext so aussehen: \n"
"\n"
"```\n"
"P Q : Prop,\n"
"p : P,\n"
"h : P → Q\n"
"⊢ Q\n"
"```\n"
"\n"
"In dieser Situation haben wir die Wahr/Falsch Aussagen $P$ und $Q$. \n"
"Außerdem einen Beweis $p$ von $P$ und eine Hypothese $h$, die aussagt \n"
"$P \\implies Q$ \n"
"Unser Ziel ist ein Beweis von $q$. Es ist also klar, was zu tun ist! \n"
"Zumindest aus mathematischer Sichtweise, wenn $P$ wahr ist und \n"
"aus $P$ auch $Q$ folgt, dann ist $Q$ automatisch wahr. \n"
"Wie funktioniert das aber in Lean? \n"
"\n"
"Wir stellen uns auf einen Standpunkt, der für viele Mathematiker völlig \n"
"ungewohnt ist. Lean interpretiert die Hypothese $h$ als eine Funktion, die \n"
"von den Beweisen von $P$ in die Beweise von $Q$ abbildet, der "
"überraschende \n"
"Ansatz \n"
"\n"
"`exact h(p),`\n"
"\n"
"bringt uns also nahe ans Ziel! \n"
"\n"
"Beachte, dass `exact h(P)` (mit einem großen P) nicht funktioniert; \n"
"Es ist wieder ein üblicher Fehler von Anfängern \"Wir versuchen `P` \n"
"zu beweisen, also ist es exact `P` \". \n"
"Das Ziel zeigt den *Satz*, dein Job ist es den *Beweis* zu konstruieren. \n"
"$P$ ist kein beweis von $P$, sondern $p$. \n"
"\n"
"In Lean sind Aussagen, wie Mengen, Typen und Beweise, wie Elemente von "
"Mengen, \n"
"sind Terme. \n"
"\n"
"## Level 1: die `exact` Taktik.\n"

#: Proposition world level 1
msgid "If $P$ is true, and $P\\implies Q$ is also true, then $Q$ is true.\n"
msgstr ""
"Wenn $P$ waht ist und $P \\implies Q$ ebenfalls wahr ist, dann ist $Q$ "
"wahr. \n"

#: Proposition world level 2
msgid ""
"# Proposition world. \n"
"\n"
"## Level 2: `intro`.\n"
"\n"
"Let's prove an implication. Let $P$ be a true/false statement,\n"
"and let's prove that $P\\implies P$. If you delete the\n"
"`sorry` you will see that our goal is `P → P`. Constructing a term\n"
"of type `P → P` (which is what solving this goal *means*) in this\n"
"case amounts to proving that $P\\implies P$, and computer scientists\n"
"think of this as coming up with a function which sends proofs of $P$\n"
"to proofs of $P$.\n"
"\n"
"To define an implication $P\\implies Q$ we need to choose an arbitrary\n"
"proof $p : P$ of $P$ and then, perhaps using $p$, construct a proof\n"
"of $Q$.  The Lean way to say \"let's assume $P$ is true\" is `intro p`,\n"
"i.e., \"let's assume we have a proof of $P$\".\n"
"\n"
"## Note for worriers.\n"
"\n"
"Those of you who know\n"
"something about the subtle differences between truth and provability\n"
"discovered by Goedel -- these are not relevant here. Imagine we are\n"
"working in a fixed model of mathematics, and when I say \"proof\"\n"
"I actually mean \"truth in the model\", or \"proof in the metatheory\".\n"
"\n"
"## Rule of thumb: \n"
"\n"
"If your goal is to prove `P → Q` (i.e. that $P\\implies Q$)\n"
"then `intro p`, meaning \"assume $p$ is a proof of $P$\", will make "
"progress.\n"
"\n"
"To solve the goal below, you have to come up with a function from\n"
"`P` (thought of as the set of proofs of $P$!) to itself. Start with\n"
"\n"
"`intro p,`\n"
"\n"
"(i.e. \"let $p$ be a proof of $P$\") and note that our\n"
"local context now looks like this:\n"
"\n"
"```\n"
"P : Prop,\n"
"p : P\n"
"⊢ P\n"
"```\n"
"\n"
"Our job now is to construct a proof of $P$. But $p$ is a proof of $P$.\n"
"So\n"
"\n"
"`exact p,`\n"
"\n"
"will close the goal. Note that `exact P` will not work -- don't\n"
"confuse a true/false statement (which could be false!) with a proof.\n"
"We will stick with the convention of capital letters for propositions\n"
"and small letters for proofs.\n"
msgstr ""
"# Welt der Aussagen. \n"
"\n"
"## Level 2: `intro`.\n"
"\n"
"Lass uns eine Implikation beweisen. Sei $P$ eine Wahr/Falsch Aussage. \n"
"Wir wollen beweisen, dass $P\\implies P$ gilt. Wenn du das sorry löscht, "
"dann \n"
"wirst du sehen, dass unser Ziel `P → P`  lautet. Einen Term vom Typ `P → "
"P` \n"
"zu konstruieren (das ist es, was es *bedeutet*, dieses Ziel zu erfüllen) \n"
"ist in diesem Fall gleichbedeutend damit zu beweisen, dass $P \\implies P$ "
"gilt. \n"
"Informatiker würden denken: wir suchen eine Funktion, die die Beweise von $P"
"$ \n"
"auf die Beweise von $P$ abbildet. \n"
"\n"
"Um eine Implikation $P\\implies Q$ zu definieren brauchen wir einen "
"beliebigen \n"
"Beweis $p : P$ von $P$ und dann, vielleicht unter Verwendung von $p$, "
"konstruieren \n"
"wir einen Beweis von $Q$. Lean sagt \"lass uns annehmen, dass $P$ wahr ist\" "
"mit \n"
"`intro p`, also etwa \"Wir nehmen an, wir haben einen Beweis für $P$\". \n"
"\n"
"## Anmerkung für alle Besorgten. \n"
"\n"
"An diejenigen von euch, die etwas über die subtilen Unterschiede zwischen \n"
"Wahrheit und Beweisbarkeit, die von Goedel entdeckt wurden, wissen -- \n"
"sie sind hier nicht relevant. Wir können uns vorstellen, dass wir in einem \n"
"fixierten Modell der Mathematik arbeiten und wenn ich \"Beweis\" sage, \n"
"dann meine ich eigentlich \"wahr innerhalb meines Modells\", oder \n"
"\"Beweis in der Metatheorie\". \n"
"\n"
"Daumenregel: \n"
"\n"
"Wenn es dein Ziel ist `P → Q` (also z.B. $P\\implies Q$) zu beweisen, \n"
"dann ist `intro p`ein guter Start, da es bedeutet: \n"
"\"Wir nehmen an, dass $p$ ein Beweis von $P$ ist\". \n"
"\n"
"Um untenstehendes Ziel jetzt zu lösen, musst du eine Funktion von \n"
"`P` (also der Menge aller Beweise von $P$!) in sich selbst entwickeln. \n"
"Beginne mit: \n"
"\n"
"`intro p,`\n"
"\n"
"(z.B.: \"sei $p$ ein Beweis von $P$\") und beachte, dass unser lokaler \n"
"Kontext dann wie folgt aussieht: \n"
"\n"
"```\n"
"P : Prop,\n"
"p : P\n"
"⊢ P\n"
"```\n"
"\n"
"Unser Job ist es jetzt einen Beweis von $P$ zu konstruieren. Aber $p$ \n"
"ist schon ein Beweis von $P$, also: \n"
"\n"
"`exact p,`\n"
"\n"
"Das reicht schon um das Ziel zu erfüllen! Beachte, dass  `exact P`wieder \n"
"nicht funktioniert -- verwechsle eine Wahr/Falsch Aussage (die falsch \n"
"sein könnte!) nicht mit einem Beweis! \n"
"Wir werden die Konvention mit den Großbuchstaben für Aussagen und den \n"
"Kleinbuchstaben für Beweise fortfahren. \n"

#: Proposition world level 2
msgid "If $P$ is a proposition then $P\\implies P$.\n"
msgstr "Wenn $P$ eine Aussage ist, dann gilt $P\\implies P$.\n"

#: Proposition world level 3
msgid ""
"# Proposition world. \n"
"\n"
"## Level 3: `have`.\n"
"\n"
"Say you have a whole bunch of propositions and implications between them,\n"
"and your goal is to build a certain proof of a certain proposition.\n"
"If it helps, you can build intermediate proofs of other propositions\n"
"along the way, using the `have` command. `have q : Q := ...` is the Lean "
"analogue\n"
"of saying \"We now see that we can prove $Q$, because...\"\n"
"in the middle of a proof.\n"
"It is often not logically necessary, but on the other hand\n"
"it is very convenient, for example it can save on notation, or\n"
"it can break proofs up into smaller steps.\n"
"\n"
"In the level below, we have a proof of $P$ and we want a proof\n"
"of $U$; during the proof we will construct proofs of\n"
"of some of the other propositions involved. The diagram of\n"
"propositions and implications looks like this pictorially:\n"
"\n"
"![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/"
"natural_number_game_images/implies_diag.jpg)\n"
"\n"
"and so it's clear how to deduce $U$ from $P$.\n"
"Indeed, we could solve this level in one move by typing\n"
"\n"
"`exact l(j(h(p))),`\n"
"\n"
"But let us instead stroll more lazily through the level.\n"
"We can start by using the `have` tactic to make a proof of $Q$:\n"
"\n"
"`have q := h(p),`\n"
"\n"
"and then we note that $j(q)$ is a proof of $T$:\n"
"\n"
"`have t : T := j(q),`\n"
"\n"
"(note how we explicitly told Lean what proposition we thought $t$ was\n"
"a proof of, with that `: T` thing before the `:=`) \n"
"and we could even define $u$ to be $l(t)$:\n"
"\n"
"`have u : U := l(t),`\n"
"\n"
"and then finish the level with\n"
"\n"
"`exact u,`\n"
"\n"
". \n"
msgstr ""
"# Welt der Aussagen. \n"
"\n"
"## Level 3: `have`.\n"
"\n"
"Wir nehmen an, dass wir einige Aussagen und Implikationen zwischen ihnen "
"haben. \n"
"Unser Ziel ist es, einen Beweis einer bestimmten Aussagen zu konstruieren. \n"
"Wenn es dir hilft, kannst du Zwischenbeweise für andere Aussagen "
"konstruieren. \n"
"Dazu kannst du wieder `have` verwenden. `have q : Q := ...` ist Leans Art zu "
"sagen: \n"
"\"Wir können jetzt $Q$ beweisen, weil...\" während wir etwas anderes "
"beweisen. \n"
"Es ist häufig nicht logisch notwendig, aber auf der anderen Seite ist es "
"sehr praktisch. \n"
"Es kann z.B. einiges an Notation sparen oder den Beweis in kleinere Teile "
"teilen. \n"
"\n"
"Im untenstehenden Level haben wir einen Beweis von $P$ und wir wollen "
"einen \n"
"Beweis von $U$; während des Beweises werden wir Beweise für einige andere \n"
"Aussagen konstruieren, die involviert sind. \n"
"Das Diagramm der Aussagen und Implikationen sieht so aus: \n"
"\n"
"![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/"
"natural_number_game_images/implies_diag.jpg)\n"
"\n"
"Es ist also klar, wie wir $U$ aus $P$ ableiten können. \n"
"Wir könnten das Level leicht in einem Schritt lösen: \n"
"\n"
"`exact l(j(h(p))),`\n"
"\n"
"Aber lass uns etwas langsamer durch das Level wandern. \n"
"Wir beginnen, indem wir die `have`Taktik verwenden, um einem Beweis von $Q$ "
"zu erzeugen: \n"
"\n"
"\n"
"`have q := h(p),`\n"
"\n"
"Dann können wir sehen, dass $j(q)$ ein Beweis von $T$ ist: \n"
"\n"
"`have t : T := j(q),`\n"
"\n"
"(Beachte, dass wir Lean explizit gesagt haben, welche Aussage zum \n"
"Beweis $t$ gehört mit dem `: T` Ding vor dem `:=`) \n"
"Wir könnten sogar definieren: \n"
"\n"
"`have u : U := l(t),`\n"
"\n"
"und dann das Level beenden mit: \n"
"\n"
"`exact u,`\n"
"\n"

#: Proposition world level 3
msgid ""
"In the maze of logical implications above, if $P$ is true then so is $U$.\n"
msgstr ""
"Im Labyrinth der obigen logischen Implikationen gilt: wenn $P$ wahr ist, "
"dann ist auch $U$ wahr. \n"

#: Proposition world level 3
msgid ""
"If you solved the level using `have`, then click on the last line of your "
"proof\n"
"(you do know you can move your cursor around with the arrow keys\n"
"and explore your proof, right?) and note that the local context at that "
"point\n"
"is in something like the following mess:\n"
"\n"
"```\n"
"P Q R S T U : Prop,\n"
"p : P,\n"
"h : P → Q,\n"
"i : Q → R,\n"
"j : Q → T,\n"
"k : S → T,\n"
"l : T → U,\n"
"q : Q,\n"
"t : T,\n"
"u : U\n"
"⊢ U\n"
"```\n"
"\n"
"It was already bad enough to start with, and we added three more\n"
"terms to it. In level 4 we will learn about the `apply` tactic\n"
"which solves the level using another technique, without leaving\n"
"so much junk behind.\n"
msgstr ""
"Wenn du das Level mit `have` gelöst hast, dann klicke in die letzten Zeile \n"
"deines Beweises. (Du erinnerst dich, dass du die Pfeiltasten nutzen "
"kannst, \n"
"um deinen Beweis zu erkunden, oder?) Der Kontext dieser letzten Zeile "
"sieht \n"
"etwa so aus: \n"
"\n"
"```\n"
"P Q R S T U : Prop,\n"
"p : P,\n"
"h : P → Q,\n"
"i : Q → R,\n"
"j : Q → T,\n"
"k : S → T,\n"
"l : T → U,\n"
"q : Q,\n"
"t : T,\n"
"u : U\n"
"⊢ U\n"
"```\n"
"\n"
"Es war am Anfang schon schlimm, aber wir haben drei weitere Terme ergänzt! \n"
"In Level 4 werden wir lernen, wie die `apply` Taktik funktioniert. So kann \n"
"man das Level einfacher lösen, ohne soviel Müll zurückzulassen. \n"

#: Proposition world level 4
msgid ""
"\n"
"# Proposition world. \n"
"\n"
"## Level 4: `apply`.\n"
"\n"
"Let's do the same level again:\n"
"\n"
"![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/"
"natural_number_game_images/implies_diag.jpg)\n"
"\n"
"We are given a proof $p$ of $P$ and our goal is to find a proof of $U$, or\n"
"in other words to find a path through the maze that links $P$ to $U$.\n"
"In level 3 we solved this by using `have`s to move forward, from $P$\n"
"to $Q$ to $T$ to $U$. Using the `apply` tactic we can instead construct\n"
"the path backwards, moving from $U$ to $T$ to $Q$ to $P$.\n"
"\n"
"Our goal is to prove $U$. But $l:T\\implies U$ is\n"
"an implication which we are assuming, so it would suffice to prove $T$.\n"
"Tell Lean this by starting the proof below with\n"
"\n"
"`apply l,`\n"
"\n"
"and notice that our assumptions don't change but *the goal changes*\n"
"from `⊢ U` to `⊢ T`. \n"
"\n"
"Keep `apply`ing implications until your goal is `P`, and try not\n"
"to get lost! Now solve this goal\n"
"with `exact p`. Note: you will need to learn the difference between\n"
"`exact p` (which works) and `exact P` (which doesn't, because $P$ is\n"
"not a proof of $P$).\n"
msgstr ""
"\n"
"# Welt der Aussagen. \n"
"\n"
"## Level 4: `apply`.\n"
"\n"
"Lass uns dasselbe Level noch einmal machen: \n"
"\n"
"![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/"
"natural_number_game_images/implies_diag.jpg)\n"
"\n"
"Wir haben einen Beweis $p$ von $P$ gegeben und unser Ziel ist es, einen \n"
"Beweis von $U$ zu finden. Mit anderen Worten: wir suchen einen Pfad durch \n"
"das Labyrinthm der $P$ und $U$ verbindet. \n"
"Im dritten Level haben wir dies mit der `have`Taktik gelöst, um uns "
"vorwärts \n"
"durch das Labyrinth zu bewegen, von $P$ über $Q$ und $T$ zu $U$. \n"
"Wenn wir die `apply`Taktik verwenden, konstruieren wir den Weg rückwärts, "
"also \n"
"von $U$ über $T$ und $Q$ zu $P$. \n"
"\n"
"Unser Ziel ist es $U$ zu beweisen. Allerdings ist $l:T\\implies U$ ist "
"eine \n"
"Implikation, die wir schon annehmen. Es ist also ausreichend, $T$ zu "
"beweisen. \n"
"Wir sagen das Lean, indem wir den Beweis wie folgt starten: \n"
"\n"
"`apply l,`\n"
"\n"
"Wir können jetzt sehen, dass unsere Annahmen sich nicht verändern, aber \n"
"*das Ziel verändert sich*. \n"
"von `⊢ U` zu `⊢ T`. \n"
"\n"
"Mache weiter mit `apply`, bis dein Ziel `P` ist und versuche, nicht \n"
"verloren zu gehen! Löse das letzte Ziel mit `exact p`. \n"
"Hinweis: Du wirst den Unterschied zwischen `exact p` (das funktioniert) \n"
"und `exact P` (das nicht funktioniert, weil $P$ kein Beweis von $P$ ist) \n"
"lernen müssen! \n"

#: Proposition world level 4
msgid "We can solve a maze.\n"
msgstr "Wir können ein Labyrinth lösen. \n"

#: Proposition world level 5
msgid ""
"# Proposition world. \n"
"\n"
"## Level 5 : `P → (Q → P)`.\n"
"\n"
"In this level, our goal is to construct an implication, like in level 2.\n"
"\n"
"```\n"
"⊢ P → (Q → P)\n"
"```\n"
"\n"
"So $P$ and $Q$ are propositions, and our goal is to prove\n"
"that $P\\implies(Q\\implies P)$.\n"
"We don't know whether $P$, $Q$ are true or false, so initially\n"
"this seems like a bit of a tall order. But let's give it a go. Delete\n"
"the `sorry` and let's think about how to proceed.\n"
"\n"
"Our goal is `P → X` for some true/false statement $X$, and if our\n"
"goal is to construct an implication then we almost always want to use the\n"
"`intro` tactic from level 2, Lean's version of \"assume $P$\", or more "
"precisely\n"
"\"assume $p$ is a proof of $P$\". So let's start with\n"
"\n"
"`intro p,`\n"
"\n"
"and we then find ourselves in this state:\n"
"\n"
"```\n"
"P Q : Prop,\n"
"p : P\n"
"⊢ Q → P\n"
"```\n"
"\n"
"We now have a proof $p$ of $P$ and we are supposed to be constructing\n"
"a proof of $Q\\implies P$. So let's assume that $Q$ is true and try\n"
"and prove that $P$ is true. We assume $Q$ like this:\n"
"\n"
"`intro q,`\n"
"\n"
"and now we have to prove $P$, but have a proof handy:\n"
"\n"
"`exact p,`\n"
msgstr ""
"# Welt der Aussagen. \n"
"\n"
"## Level 5 : `P → (Q → P)`.\n"
"\n"
"In diesem Level ist es unser Ziel eine Implikation wie in level 2 zu "
"konstruieren. \n"
"\n"
"```\n"
"⊢ P → (Q → P)\n"
"```\n"
"\n"
"$P$ und $Q$ sind Aussagen und unser Ziel ist es zu zeigen, dass gilt: \n"
"$P\\implies(Q\\implies P)$.\n"
"Wir wissen nicht, ob $P$ und $Q$ wahr oder falsch sind. Auf den ersten "
"Blick \n"
"ist dies also wieder eine schwere Aufgabe. Aber wir versuchen es! \n"
"Lösche das `sorry` und wir denken darüber nach, wie es weitergeht. \n"
"\n"
"Unser Ziel ist `P → X` für eine wahre oder falsche Aussage $X$. Wenn \n"
"es unser Ziel ist, eine Implikation zu beweisen, dann wollen wir "
"eigentlich \n"
"immer die `intro` Taktik aus Level 2 verwenden, also Leans Version von \n"
"\"Wir nehmen an, $P$ ist wahr\". Oder noch genauer: \n"
"\"Wir nehmen an, $p$ ist ein Beweis von $P$\". Fangen wir also an: \n"
"\n"
"`intro p,`\n"
"\n"
"Wir finden uns in folgendem Zustand wieder: \n"
"\n"
"```\n"
"P Q : Prop,\n"
"p : P\n"
"⊢ Q → P\n"
"```\n"
"\n"
"Wir haben jetzt einen Beweis $p$ von $P$ und wir sollen einen Beweis "
"konstruieren, \n"
"sodass gilt: $Q\\implies P$. Nehmen wir also an, dass $Q$ wahr ist und "
"versuchen \n"
"zu bweisen, dass $P$ wahr ist. Das geht so: \n"
"\n"
"`intro q,`\n"
"\n"
"Jetzt müssen wir nur noch $P$ beweisen, aber wir haben einen Beweis zur "
"Hand! \n"
"\n"
"`exact p,`\n"

#: Proposition world level 5
msgid ""
"For any propositions $P$ and $Q$, we always have\n"
"$P\\implies(Q\\implies P)$. \n"
msgstr ""
"Für beliebige Aussagen $P$ und $Q$ gilt immer \n"
"$P\\implies(Q\\implies P)$. \n"

#: Proposition world level 5
msgid ""
"A mathematician would treat the proposition $P\\implies(Q\\implies P)$\n"
"as the same as the proposition $P\\land Q\\implies P$,\n"
"because to give a proof of either of these is just to give a method which "
"takes\n"
"a proof of $P$ and a proof of $Q$, and returns a proof of $P$. Thinking of "
"the\n"
"goal as $P\\land Q\\implies P$ we see why it is provable.\n"
"\n"
"## Did you notice?\n"
"\n"
"I wrote `P → (Q → P)` but Lean just writes `P → Q → P`. This is because\n"
"computer scientists adopt the convention that `→` is *right associative*,\n"
"which is a fancy way of saying \"when we write `P → Q → R`, we mean `P → (Q "
"→ R)`.\n"
"Mathematicians would never dream of writing something as ambiguous as\n"
"$P\\implies Q\\implies R$ (they are not really interested in proving "
"abstract\n"
"propositions, they would rather work with concrete ones such as Fermat's "
"Last Theorem),\n"
"so they do not have a convention for where the brackets go. It's important "
"to\n"
"remember Lean's convention though, or else you will get confused. If your "
"goal\n"
"is `P → Q → R` then you need to know whether `intro h` will create `h : P` "
"or `h : P → Q`. \n"
"Make sure you understand which one. \n"
msgstr ""
"Ein mathematiker würde die Aussagen $P\\implies(Q\\implies P)$ wie \n"
"die Aussage $P\\land Q\\implies P$ behandeln. Dies liegt daran, dass \n"
"es für beides ausreichend ist, eine Methode anzugehen, die einen Beweis \n"
"von $P$ und einen Beweis von $Q$ nimmt und einen Beweis von $P$ "
"zurückgibt. \n"
"Wir denken an unser Ziel als  $P\\land Q\\implies P$ und sehen, warum \n"
"es beweisbar ist. \n"
"\n"
"## Hast du es bemerkt? \n"
"\n"
"Ich habe `P → (Q → P)` geschrieben, aber Lean schreibt nur `P → Q → P`. \n"
"Das liegt daran, dass Informatiker die Konvention benutzen, dass `→` \n"
"rechtsassoziativ ist. Das ist wieder nur eine schlaue Art zu sagen: \n"
"\" wenn wir `P → Q → R` schreiben, dann meinen wir `P → (Q → R)` \" \n"
"Mathematiker würden niemals auch nur davon träumen etwas so zweideutiges "
"wie \n"
"$P\\implies Q\\implies R$ zu schreiben. (Sie sind ohnehin nicht daran "
"interessiert \n"
"so abstrakte Aussagen zu beweisen. Sie arbeiten lieber mit konkreten \n"
"Aussagen wie Fermats letztem Satz. \n"
"Es gibt also keine Konvention, wohin die Klammern kommen. Es ist aber "
"wichtig \n"
"sich zu merken, dass Lean eine Konvention hat, oder man wird verwirrt. \n"
"Wenn dein Ziel `P → Q → R` ist, dann musst du wissen, dass `intro h` \n"
"entweder `h : P` oder `h : P → Q` erzeugt. Vergewissere dich, dass du \n"
"das richtige gedacht hast. \n"

#: Proposition world level 6
msgid ""
"# Proposition world. \n"
"\n"
"## Level 6: `(P → (Q → R)) → ((P → Q) → (P → R))`.\n"
"\n"
"You can solve this level completely just using `intro`, `apply` and "
"`exact`,\n"
"but if you want to argue forwards instead of backwards then don't forget\n"
"that you can do things like `have j : Q → R := f p` if `f : P → (Q → R)`\n"
"and `p : P`. I recommend that you start with `intro f` rather than `intro "
"p`\n"
"because even though the goal starts `P → ...`, the brackets mean that\n"
"the goal is not the statement that `P` implies anything, it's the statement "
"that\n"
"$P\\implies (Q\\implies R)$ implies something. In fact I'd recommend that "
"you started\n"
"with `intros f h p`, which introduces three variables at once.\n"
"You then find that your your goal is `⊢ R`. If you try `have j : Q → R := f "
"p`\n"
"now then you can `apply j`. Alternatively you can `apply (f p)` directly.\n"
"What happens if you just try `apply f`? Can you figure out what just "
"happened? This is a little\n"
"`apply` easter egg. Why is it mathematically valid?\n"
msgstr ""
"# Welt der Aussagen. \n"
"\n"
"## Level 6: `(P → (Q → R)) → ((P → Q) → (P → R))`.\n"
"\n"
"Du kannst dieses Level komplett lösen, indem du nur `intro`, `apply`, \n"
"und `exact` verwendest. Aber wenn du vorwärts statt rückwärts "
"argumentieren \n"
"willst, dann vergiss nicht, dass du zum Beispiel `have j : Q → R := f p` if "
"`f : P → (Q → R)` \n"
"verwenden kannst oder `p : P`. \n"
"Ich empfehle, dass du mit `intro f` anstelle von `intro p`beginnst. \n"
"Das liegt daran, dass das Ziel zwar mit `P → ...` beginnt, die \n"
"Klammern aber bedeuten, dass das Ziel nicht ist, dass die Aussage $P$ \n"
"irgendetwas impliziert. Tatsächlich würde ich sogar empfehlen mit \n"
"`intros f h p` zu beginnen, was alle drei Variablen auf einmal einführt. \n"
"Dein Ziel ist dann `⊢ R`. Wenn du `have j : Q → R := f p`versuchst, dann \n"
"kannst du `apply j` verwenden. \n"
"Allternativ funktioniert auch `apply (f p)` direkt. \n"
"Was passiert, wenn du nur `apply f` versuchst? Kannst du dir vorstellen, was "
"gerade \n"
"passiert ist? Es ist ein kleines `apply` easter egg. Warum ist es "
"mathematisch sinnvoll? \n"

#: Proposition world level 6
msgid ""
"If $P$ and $Q$ and $R$ are true/false statements, then\n"
"$$(P\\implies(Q\\implies R))\\implies((P\\implies Q)\\implies(P\\implies R))."
"$$\n"
msgstr ""
"Wenn $P$, $Q$ und $R$ Wahr/Falsch Aussagen sind, dann gilt:$$(P\\implies(Q"
"\\implies R))\\implies((P\\implies Q)\\implies(P\\implies R)).$$\n"

#: Proposition world level 7
msgid ""
"# Function world. \n"
"\n"
"## Level 7: `(P → Q) → ((Q → R) → (P → R))` \n"
"\n"
"If you start with `intro hpq` and then `intro hqr`\n"
"the dust will clear a bit and the level will look like this:\n"
"```\n"
"P Q R : Prop,\n"
"hpq : P → Q,\n"
"hqr : Q → R\n"
"⊢ P → R\n"
"```\n"
"So this level is really about showing transitivity of $\\implies$,\n"
"if you like that sort of language.\n"
msgstr ""
"# Welt der Aussagen. \n"
"\n"
"## Level 7: `(P → Q) → ((Q → R) → (P → R))` \n"
"\n"
"Wenn du mit `intro hpq` und dann `intro hqr` beginnst, \n"
"wird sich der Rauch etwas lichten und das Level sieht so aus: \n"
"```\n"
"P Q R : Prop,\n"
"hpq : P → Q,\n"
"hqr : Q → R\n"
"⊢ P → R\n"
"```\n"
"Das Level beschäftigt sich also mit der Transitivität von $\\implies$, \n"
"wenn du diese Art der Sprache magst. \n"

#: Proposition world level 7
msgid "From $P\\implies Q$ and $Q\\implies R$ we can deduce $P\\implies R$.\n"
msgstr ""
"Aus $P\\implies Q$ und $Q\\implies R$ können wir $P\\implies R$ folgern. \n"

#: Proposition world level 8
msgid ""
"# Proposition world. \n"
"\n"
"## Level 8 : `(P → Q) → (¬ Q → ¬ P)` \n"
"\n"
"There is a false proposition `false`, with no proof. It is\n"
"easy to check that $\\lnot Q$ is equivalent to $Q\\implies {\\tt false}$,\n"
"and in the natural number game we call this\n"
"\n"
"`not_iff_imp_false (P : Prop) : ¬ P ↔ (P → false)`\n"
"\n"
"So you can start the proof of the contrapositive below with\n"
"\n"
"`repeat {rw not_iff_imp_false},`\n"
"\n"
"to get rid of the two occurences of `¬`, and I'm sure you can\n"
"take it from there (note that we just added `not_iff_imp_false` to the\n"
"theorem statements in the menu on the left). At some point your goal might "
"be to prove `false`.\n"
"At that point I guess you must be proving something by contradiction.\n"
"Or are you? \n"
msgstr ""
"# Welt der Aussagen. \n"
"\n"
"## Level 8 : `(P → Q) → (¬ Q → ¬ P)` \n"
"\n"
"Es gibt eine falsche Aussage `faksch`, ohne einen Beweis. Es ist leicht \n"
"einzusehen, dass $\\lnot Q$ äquivalent zu $Q\\implies {\\tt false}$ ist. \n"
"Im Spiel der natürlichen Zahlen nennen wir das: \n"
"\n"
"`not_iff_imp_false (P : Prop) : ¬ P ↔ (P → false)`\n"
"\n"
"Wir können den Beweis der Kontraposition unten also starten: \n"
"\n"
"`repeat {rw not_iff_imp_false},`\n"
"\n"
"Wir werden damit das zweimalige Auftreten von `¬` los. Ich bin sicher, "
"dass \n"
"du es von hier aus schaffst. (Beachte, dass wir `not_iff_imp_false`zu den \n"
"vorhandenen Aussagen im Menü links hinzugefügt haben. \n"
"Eventuell wird es an einem bestimmten Punkt dein Ziel sein `falsch`zu "
"beweisen. \n"
"Dann musst du offensichtlich etwas durch Widerspruch beweisen, wirklich? \n"

#: Proposition world level 8
msgid ""
"If $P$ and $Q$ are propositions, and $P\\implies Q$, then\n"
"$\\lnot Q\\implies \\lnot P$. \n"
msgstr ""
"Sind $P$ und $Q$ Aussagen und gilt $P \\implies Q$, dann gilt auch: \n"
"$\\lnot Q\\implies \\lnot P$. \n"

#: Proposition world level 8
msgid ""
"## Technical note\n"
"\n"
"\n"
"All of that rewriting you did with `rw` in addition world\n"
"was rewriting hypothesis of the form `h : X = Y`, but\n"
"you can also `rw h` if `h : P ↔ Q` (because propositional\n"
"extensionality says that if $P\\iff Q$ then $P=Q$, and\n"
"mathematicians use this whether or not they notice.)\n"
msgstr ""
"## Technische Anmerkung: \n"
"\n"
"\n"
"Das Umschreiben mit `rw` in der Welt der Addition hat \n"
"Hypothesen der Form `h : X = Y` umgeschrieben. \n"
"Man kann aber auch `rw h` schreiben, wenn gilt: `h : P ↔ Q` \n"
"(Das liegt daran, dass aus $P\\iff Q$ auch $P=Q$ folgt. \n"
"Mathematiker benutzen das, sogar wenn sie es nicht bemerken.) \n"

#: Proposition world level 9
msgid ""
"# Proposition world. \n"
"\n"
"## Level 9: a big maze. \n"
"\n"
"Lean's \"congruence closure\" tactic `cc` is good at mazes. You might want "
"to try it now.\n"
"Perhaps I should have mentioned it earlier.\n"
msgstr ""
"# Welt der Aussagen. \n"
"\n"
"## Level 9: ein großes Labyrintg. \n"
"\n"
"Lean's \"congruence closure\" Taktik ist gut für Labyrinthe. Du könntest \n"
" sie jetzt ausprobieren.\n"
"Vielleicht hätte ich sie früher erwähnen sollen $\\ldots$"

#: Proposition world level 9
msgid "There is a way through the following maze.\n"
msgstr "Es gibt einen Weg durch das folgende Labyrinth. \n"

#: Proposition world level 9
msgid ""
"Now move onto advanced proposition world, where you will see\n"
"how to prove goals such as `P ∧ Q` ($P$ and $Q$), `P ∨ Q` ($P$ or $Q$),\n"
"`P ↔ Q` ($P\\iff Q$).\n"
"You will need to learn five more tactics: `split`, `cases`,\n"
"`left`, `right`, and `exfalso`,\n"
"but they are all straightforward, and furthermore they are\n"
"essentially the last tactics you\n"
"need to learn in order to complete all the levels of the Natural Number "
"Game,\n"
"including all the 17 levels of Inequality World. \n"
msgstr ""
"Es geht jetzt mit der forgeschrittenen Welt der Aussagen weiter, dort \n"
"wirst du sehen, wie Ziele der Form `P ∧ Q` ($P$ and $Q$) bewiesen werden \n"
"können, oder auch `P ∨ Q` ($P$ or $Q$), `P ↔ Q` ($P\\iff Q$). \n"
"Du musst dazu fünf weitere Taktiken lernen: `split`, `cases`, \n"
"`left`, `right` und `exfalso`. \n"
"Sie sind aber alle recht geradlinig und außerdem im Prinzip die \n"
"letzten Taktiken, die du lernen musst, um alle Level des Spiels \n"
"zu bewältigen, inklusive der 17 Level der Welt der Ungleichungen. \n"

#: Proposition world level 9
msgid ""
"\n"
"## Summary:\n"
"\n"
"`cc` will solve certain \"logic\" goals.\n"
"\n"
"## Details\n"
"\n"
"`cc` is a \"congruence closure tactic\". In practice this means that it is\n"
"good at solving certain logic goals. It's worth trying if you think\n"
"that the goal could be solved using truth tables.\n"
msgstr ""

#: world_config
msgid "Advanced Proposition world"
msgstr "Fortgeschrittene Welt der Aussagen"

#: Advanced Proposition world level 1
msgid ""
"\n"
"# Advanced proposition world. \n"
"\n"
"In this world we will learn five key tactics needed to solve all the\n"
"levels of the Natural Number Game, namely `split`, `cases`, `left`, `right`, "
"and `exfalso`.\n"
"These, and `use` (which we'll get to in Inequality World) are all the\n"
"tactics you will need to beat all the levels of the game.\n"
"\n"
"## Level 1: the `split` tactic.\n"
"\n"
"The logical symbol `∧` means \"and\". If $P$ and $Q$ are propositions, then\n"
"$P\\land Q$ is the proposition \"$P$ and $Q$\". If your *goal* is `P ∧ Q` "
"then\n"
"you can make progress with the `split` tactic, which turns one goal `⊢ P ∧ "
"Q`\n"
"into two goals, namely `⊢ P` and `⊢ Q`. In the level below, after a "
"`split`,\n"
"you will be able to finish off the goals with the `exact` tactic.\n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Aussagen. \n"
"\n"
"In dieser Welt lernen wir fünf weitere Schlüsseltaktiken, die benötigt "
"werden, \n"
"um alle Level des Spiels zu lösen, nämlich `split`, `cases`, \n"
"`left`, `right` und `exfalso`. \n"
"Na ja, diese Taktiken und `use` (das in der Welt der Ungleichheit eingeführt "
"wird) \n"
"## Level 1: die `split` Taktik.\n"
"\n"
"Das logische Symbol  `∧` bedeutet \"und\". Wenn $P$ und $Q$ Aussagen sind, \n"
"dann ist $P\\land Q$ die Aussage \"$P$ und $Q$\". Wenn dein *Ziel* `P ∧ Q` "
"ist, \n"
"dann kannst du mit der `split`Taktik Fortschritte machen, da sie Ziele \n"
"der Form `⊢ P ∧ Q` in zwei Ziele teilt, nämlich `⊢ P` und `⊢ Q` \n"
"Im untenstehenden Level wirst du nach dem `split` alle Ziele mit \n"
"`exact` lösen können. \n"

#: Advanced Proposition world level 1
msgid "If $P$ and $Q$ are true, then $P\\land Q$ is true.\n"
msgstr "Wenn $P$ und $Q$ wahr sind, dann ist $P\\land Q$ wahr. \n"

#: Advanced Proposition world level 1
msgid ""
"\n"
"## Summary:\n"
"\n"
"If the goal is `P ∧ Q` or `P ↔ Q` then `split` will break it into two "
"goals.\n"
"\n"
"## Details\n"
"\n"
"If `P Q : Prop` and the goal is `⊢ P ∧ Q`, then `split` will change it into\n"
"two goals, namely `⊢ P` and `⊢ Q`. \n"
"\n"
"If `P Q : Prop` and the goal is `⊢ P ↔ Q`, then `split` will change it into\n"
"two goals, namely `⊢ P → Q` and `⊢ Q → P`.  \n"
"\n"
"## Example:\n"
"\n"
"If your local context (the top right window) looks like this\n"
"```\n"
"a b : mynat,\n"
"⊢ a = b ↔ a + 3 = b + 3\n"
"```\n"
"\n"
"then after\n"
"\n"
"`split,`\n"
"\n"
"it will look like this:\n"
"\n"
"```\n"
"2 goals\n"
"a b : mynat\n"
"⊢ a = b → a + 3 = b + 3\n"
"\n"
"a b : mynat\n"
"⊢ a + 3 = b + 3 → a = b\n"
"\n"
msgstr ""
"\n"
"## Zusammenfassung:\n"
"\n"
"Wenn das Ziel `P ∧ Q` oder `P ↔ Q` ist, dann wird `split` diese in zwei "
"Teilziele zerlegen. \n"
" \n"
"## Details\n"
"\n"
"Wenn gilt: `P Q : Prop` und `⊢ P ∧ Q`, dann wird `split` es in zwei Ziele \n"
"zerlegen, nämlich `⊢ P` und `⊢ Q`. \n"
"\n"
"Wenn gilt: `P Q : Prop` und `⊢ P ↔ Q`, dann wird `split` es in zwei Ziele \n"
"zerlegen, nämlich `⊢ P → Q` und `⊢ Q → P`.  \n"
"\n"
"## Beispiel:\n"
"\n"
"Wenn dein lokaler Kontext (rechts oben) so aussieht: \n"
"```\n"
"a b : mynat,\n"
"⊢ a = b ↔ a + 3 = b + 3\n"
"```\n"
"\n"
"dann wird \n"
"\n"
"`split,`\n"
"\n"
"es in folgendes zerlegen: \n"
"\n"
"```\n"
"2 goals\n"
"a b : mynat\n"
"⊢ a = b → a + 3 = b + 3\n"
"\n"
"a b : mynat\n"
"⊢ a + 3 = b + 3 → a = b\n"
"\n"

#: Advanced Proposition world level 2
msgid ""
"\n"
"# Advanced proposition world. \n"
"\n"
"## Level 2: the `cases` tactic.\n"
"\n"
"If `P ∧ Q` is in the goal, then we can make progress with `split`.\n"
"But what if `P ∧ Q` is a hypothesis? In this case, the `cases` tactic will "
"enable\n"
"us to extract proofs of `P` and `Q` from this hypothesis.\n"
"\n"
"The lemma below asks us to prove `P ∧ Q → Q ∧ P`, that is,\n"
"symmetry of the \"and\" relation. The obvious first move is\n"
"\n"
"`intro h,`\n"
"\n"
"because the goal is an implication and this tactic is guaranteed\n"
"to make progress. Now `h : P ∧ Q` is a hypothesis, and\n"
"\n"
"`cases h with p q,`\n"
"\n"
"will change `h`, the proof of `P ∧ Q`, into two proofs `p : P`\n"
"and `q : Q`. From there, `split` and `exact` will get you home.\n"
msgstr ""
"\n"
"Fortgeschrittene Welt der Aussagen. \n"
"\n"
"## Level 2: die `cases` Taktik.\n"
"\n"
"Wenn das Ziel `P ∧ Q` ist, dann können wir mit `split` Fortschritte "
"machen. \n"
"Was ist aber, wenn `P ∧ Q` eine Hypothese ist? In diese Fall kann die \n"
"`cases`Taktik weiterhelfen und uns ermöglichen, Beweise von `P`und `Q`\n"
"aus dieser Hypothese zu extrahieren. \n"
"\n"
"Das untenstehende Lemma lässt uns `P ∧ Q → Q ∧ P` beweisen. Dies \n"
"entspricht der Symmetrie der \"und\" Relation. Es geht logischerweise los "
"mit: \n"
"\n"
"`intro h,`\n"
"\n"
"Das Ziel eine Implikation ist und diese Taktik macht garantiert "
"Fortschritte. \n"
"Jetzt ist `h : P ∧ Q`  eine Hypothese und \n"
"\n"
"`cases h with p q,`\n"
"\n"
"wird das `h` verändern. Der Beweis von `P ∧ Q` wird in zwei Beweise "
"geteilt. \n"
"`p : P` und `q : Q`. Von hier aus sind `split` und `exact` ausreichend. \n"

#: Advanced Proposition world level 2
msgid ""
"If $P$ and $Q$ are true/false statements, then $P\\land Q\\implies Q\\land P"
"$. \n"
msgstr ""
"Wenn $P$ und $Q$ Wahr/Falsch Aussagen sind, dann gilt $P\\land Q\\implies Q"
"\\land P$. \n"

#: Advanced Proposition world level 2
msgid ""
"\n"
"## Summary:\n"
"\n"
"`cases` is a tactic which works on hypotheses.\n"
"If `h : P ∧ Q` or `h : P ↔ Q` is a hypothesis then `cases h with h1 h2` will "
"remove `h`\n"
"from the list of hypotheses and replace it with the \"ingredients\" of `h`,\n"
"i.e. `h1 : P` and `h2 : Q`, or `h1 : P → Q` and `h2 : Q → P`. Also\n"
"works with `h : P ∨ Q` and `n : mynat`. \n"
"\n"
"## Details\n"
"\n"
"How does one prove `P ∧ Q`? The way to do it is to prove `P` and to\n"
"prove `Q`. There are hence two ingredients which go into a proof of\n"
"`P ∧ Q`, and the `cases` tactic extracts them. \n"
"\n"
"More precisely, if the local context contains\n"
"```\n"
"h : P ∧ Q`\n"
"```\n"
"\n"
"then after the tactic `cases h with p q,` the local context will\n"
"change to\n"
"```\n"
"p : P,\n"
"q : Q\n"
"```\n"
"and `h` will disappear. \n"
"\n"
"Similarly `h : P ↔ Q` is proved by proving `P → Q` and `Q → P`,\n"
"and `cases h with hpq hqp` will delete our assumption `h` and\n"
"replace it with\n"
"```\n"
"hpq : P → Q,\n"
"hqp : Q → P\n"
"```\n"
"\n"
"Be warned though -- `rw h` works with `h : P ↔ Q` (`rw` works with\n"
"`=` and `↔`), whereas you cannot rewrite with an implication.\n"
"\n"
"`cases` also works with hypotheses of the form `P ∨ Q` and even\n"
"with `n : mynat`. Here the situation is different however. \n"
"To prove `P ∨ Q` you need to give either a proof of `P` *or* a proof\n"
"of `Q`, so if `h : P ∨ Q` then `cases h with p q` will change one goal\n"
"into two, one with `p : P` and the other with `q : Q`. Similarly, each\n"
"natural is either `0` or `succ(d)` for `d` another natural, so if\n"
"`n : mynat` then `cases n with d` also turns one goal into two,\n"
"one with `n = 0` and the other with `d : mynat` and `n = succ(d)`.\n"
msgstr ""
"\n"
"## Zusammenfassung: \n"
"\n"
"`cases` ist eine Taktik, die für Hypothesen geeignet ist. \n"
"Wenn `h : P ∧ Q` oder h : P ↔ Q` eine Hypothese ist, dann wird \n"
"`cases h with h1 h2` das `h` entfernen und es mit den \"Zutaten\" \n"
"von `h` ersetzen, also z.B. `h1 : P` und `h2 : Q oder \n"
"`h1 : P → Q` und `h2 : Q → P`. Es funktioniert auch mit \n"
" `h : P ∨ Q` und `n : mynat`. \n"
"\n"
"## Details\n"
"\n"
"Wie beweist man `P ∧ Q`? Um das zu erreichen muss man `P` und `Q` \n"
"beweisen. Es gibt deswegen zwei Zutaten, die wir in den Beweis stecken \n"
"und die `cases` Taktik extrahiert diese. \n"
"\n"
"Noch genauer, wenn der Kontext \n"
"```\n"
"h : P ∧ Q`\n"
"```\n"
"\n"
"enthält, dann wird die Taktik `cases h with p q,` den Kontext wie folgt \n"
"verändern: \n"
"```\n"
"p : P,\n"
"q : Q\n"
"```\n"
"`h` ist verschwunden! \n"
"\n"
"`h : P ↔ Q` wird ganz ähnlich bewiesen, indem man `P → Q` und  `Q → P` \n"
"verwendet. Wendet man dann `cases h with hpq hqp` an, wird unsere \n"
"Annahme `h` verschwinden und durch \n"
"```\n"
"hpq : P → Q,\n"
"hqp : Q → P\n"
"```\n"
"\n"
"ersetzt werden. \n"
"Aber sei gewarnt -- `rw h` funktioniert mit `h : P ↔ Q` (`rw ` kann \n"
"allgemein mit `= `und `↔` funktionieren!), allerdings nicht mit \n"
"Implikationen! \n"
"\n"
"`cases` kann auch Hypothesen der Form `P ∨ Q` und sogar `n : mynat` \n"
"auflösen. Hier ist die Situation aber eine andere. \n"
"Um `P ∨ Q` zu beweisen muss ein Beweis für `P` *oder* ein Beweis \n"
"von `Q` gefunden werden. Wenn also `h : P ∨ Q`  gilt, dann wird \n"
"`cases h with p q` ein Ziel in zwei verwandeln: `p : P` und `q : Q` \n"
"Ähnlich gesehen ist jede natürliche Zahl entweder `0` oder `succ(d)` \n"
"für eine andere natürliche Zahl `d`. Wenn also gilt `n : mynat`, dann \n"
"wird `cases n with d` ein Ziel in zwei verwandeln:  `n = 0` und \n"
"`d : mynat` mit `n = succ(d)`.\n"

#: Advanced Proposition world level 3
msgid ""
"\n"
"# Advanced proposition world. \n"
"\n"
"## Level 3: and_trans.\n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Aussagen. \n"
"\n"
"## Level 3: and_trans.\n"

#: Advanced Proposition world level 3
msgid ""
"If $P$, $Q$ and $R$ are true/false statements, then $P\\land Q$ and\n"
"$Q\\land R$ together imply $P\\land R$.\n"
msgstr ""
"Wenn $P$, $Q$ und $R$ Wahr/Falsch Aussagen sind, dann implizieren $P\\land Q"
"$ \n"
"und $Q\\land R$ together imply $P\\land R$.\n"

#: Advanced Proposition world level 4
msgid ""
"\n"
"# Advanced proposition world. \n"
"\n"
"## Level 4: `iff_trans`.\n"
"\n"
"The mathematical statement $P\\iff Q$ is equivalent to $(P\\implies "
"Q)\\land(Q\\implies P)$. The `cases`\n"
"and `split` tactics work on hypotheses and goals (respectively) of the form "
"`P ↔ Q`. If you need\n"
"to write an `↔` arrow you can do so by typing `\\iff`, but you shouldn't "
"need to. After an initial\n"
"`intro h,` you can type `cases h with hpq hqp` to break `h : P ↔ Q` into its "
"constituent parts.\n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Aussagen. \n"
"\n"
"## Level 4: `iff_trans`.\n"
"\n"
"Die mathematische Aussage $P\\iff Q$ ist äquivalent zu $(P\\implies "
"Q)\\land(Q\\implies P)$ \n"
"Die `cases` und `split` Taktiken operieren auf Hypothesen und Zielen der \n"
"Form `P ↔ Q` Wenn du einen `↔` Pfeil schreiben willst kannst du das mit `"
"\\iff`. \n"
"Du solltest das aber gar nicht müssen. Nach einem ersten `intro h,` kannst \n"
"du mit `cases h with hpq hqp` weitermachen, um `h : P ↔ Q` in seine Teile \n"
"aufzuteilen. \n"

#: Advanced Proposition world level 4
msgid ""
"If $P$, $Q$ and $R$ are true/false statements, then\n"
"$P\\iff Q$ and $Q\\iff R$ together imply $P\\iff R$.\n"
msgstr ""
"Wenn $P$, $Q$ und $R$ Wahr/Falsch Aussagen sind, dann implizieren \n"
"$P\\iff Q$ und $Q\\iff R$ zusammen $P\\iff R$.\n"

#: Advanced Proposition world level 5
msgid ""
"\n"
"# Advanced proposition world. \n"
"\n"
"## Level 5: `iff_trans` easter eggs.\n"
"\n"
"Let's try `iff_trans` again. Try proving it in other ways.\n"
"\n"
"### A trick.\n"
"\n"
"Instead of using `cases` on `h : P ↔ Q` you can just access the proofs of `P "
"→ Q` and `Q → P`\n"
"directly with `h.1` and `h.2`. So you can solve this level with\n"
"\n"
"```\n"
"intros hpq hqr, \n"
"split,\n"
"intro p,\n"
"apply hqr.1,\n"
"...\n"
"```\n"
"\n"
"### Another trick\n"
"\n"
"Instead of using `cases` on `h : P ↔ Q`, you can just `rw h`, and this will "
"change all `P`s to `Q`s\n"
"in the goal. You can use this to create a much shorter proof. Note that\n"
"this is an argument for *not* running the `cases` tactic on an iff "
"statement;\n"
"you cannot rewrite one-way implications, but you can rewrite two-way "
"implications.\n"
"\n"
"### Another trick\n"
"\n"
"`cc` works on this sort of goal too.\n"
msgstr ""
"\n"
"Fortgeschrittene Welt der Aussagen. \n"
"\n"
"## Level 5: `iff_trans` easter eggs.\n"
"\n"
"Lass uns noch einmal `iff_trans` ansehen. Versuche es anders zu beweisen! \n"
"\n"
"### Ein Trick:\n"
"\n"
"Anstelle von `cases` für `h : P ↔ Q` zu verwenden kannst du einfach die \n"
"Beweise von `P → Q` und `Q → P` direkt verwenden, indem du `h.1` und "
"`h.2`tippst. \n"
"Du kannst das Level mit folgender Kommandofolge lösen: \n"
"\n"
"```\n"
"intros hpq hqr, \n"
"split,\n"
"intro p,\n"
"apply hqr.1,\n"
"...\n"
"```\n"
"\n"
"### Noch ein Trick\n"
"Anstelle von `cases` kannst du auch einfach `rw h` verwenden und alle \n"
" `P`s in `Q`s im Ziel verwandeln. Damit kann man einen deutlich kürzeren \n"
"Beweis schreiben. Beachte, dass dies ein Argument dafür ist, die `cases` \n"
"Taktik nicht auf eine Äquivalenz anzuwenden. \n"
"Du kannst keine einseitigen Implikationen umschreiben, aber zweiseitige! \n"
"\n"
"### Und noch ein Trick! \n"
"\n"
"`cc` funktioniert auch für solche Ziele!\n"

#: Advanced Proposition world level 5
msgid ""
"If $P$, $Q$ and $R$ are true/false statements, then `P ↔ Q` and `Q ↔ R` "
"together imply `P ↔ R`.\n"
msgstr ""
"Wenn $P$, $Q$ und $R$ Wahr/Falsch Aussagen sind, dann implizieren \n"
"`P ↔ Q` und `Q ↔ R` zusammen `P ↔ R`.\n"

#: Advanced Proposition world level 6
msgid ""
"# Advanced proposition world. \n"
"\n"
"## Level 6: Or, and the `left` and `right` tactics.\n"
"\n"
"`P ∨ Q` means \"$P$ or $Q$\". So to prove it, you\n"
"need to choose one of `P` or `Q`, and prove that one.\n"
"If `⊢ P ∨ Q` is your goal, then `left` changes this\n"
"goal to `⊢ P`, and `right` changes it to `⊢ Q`.\n"
"Note that you can take a wrong turn here. Let's\n"
"start with trying to prove $Q\\implies (P\\lor Q)$.\n"
"After the `intro`, one of `left` and `right` leads\n"
"to an impossible goal, the other to an easy finish.\n"
msgstr ""
"# Fortgeschrittene Welt der Aussagen. \n"
"\n"
"## Level 6: Oder und die `left` und `right` Taktiken. \n"
"\n"
"`P ∨ Q` bedeutet \"$P$ oder $Q$\". Um das zu beweisen genügt \n"
"es, sich `P` oder `Q` auszusuchen und das zu beweisen. \n"
"Wenn dein Ziel `⊢ P ∨ Q`  ist, dann wird `left` `P` auswählen, \n"
"also `⊢ P` und `right``Q`, also `⊢ Q`.\n"
"Beachte, dass man sich hier leicht verirren kann. Lass uns \n"
"damit anfangen $Q\\implies (P\\lor Q)$ zu beweisen. \n"
"Nach dem `intro` wird entweder `left` oder `right` zu \n"
"einem unmöglichen Ziel führen, das andere dagegen ist leicht \n"
"zu lösen. \n"

#: Advanced Proposition world level 6
msgid ""
"If $P$ and $Q$ are true/false statements, then\n"
"$$Q\\implies(P\\lor Q).$$ \n"
msgstr ""
"Sind $P$ und $Q$ Wahr/Falsch Aussagen, dann gilt: \n"
"$$Q\\implies(P\\lor Q).$$ \n"

#: Advanced Proposition world level 6
msgid ""
"\n"
"## Summary\n"
"\n"
"`left` and `right` work on the goal, and they change\n"
"`⊢ P ∨ Q` to `⊢ P` and `⊢ Q` respectively.\n"
"\n"
"## Details\n"
"\n"
"The tactics `left` and `right` work on a goal which is a type with\n"
"two constructors, the classic example being `P ∨ Q`. \n"
"To prove `P ∨ Q` it suffices to either prove `P` or prove `Q`,\n"
"and once you know which one you are going for you can change\n"
"the goal with `left` or `right` to the appropriate choice.\n"
msgstr ""
"\n"
"## Zusammenfassung\n"
"\n"
"`left` und `right` operieren auf dem Ziel und verändern\n"
"`⊢ P ∨ Q` zu `⊢ P` oder `⊢ Q`.\n"
"\n"
"## Details\n"
"\n"
"Die Taktiken `left` und `right` operieren auf einem Ziel, das einem Typ \n"
"mit zwei Konstruktoren entspricht. Das einfachste Beispiel ist `P ∨ Q`. \n"
"Um `P ∨ Q` zu beweisen genügt es, entweder `P` oder `Q`zu beweisen. \n"
"Sobald du doch für eines entscheiden hast kannst du entweder \n"
"`left` oder `right` verwenden, je nachdem, was einfacher ist. \n"

#: Advanced Proposition world level 7
msgid ""
"# Advanced proposition world. \n"
"\n"
"## Level 7: `or_symm`\n"
"\n"
"Proving that $(P\\lor Q)\\implies(Q\\lor P)$ involves an element of danger.\n"
"`intro h,` is the obvious start. But now,\n"
"even though the goal is an `∨` statement, both `left` and `right` put\n"
"you in a situation with an impossible goal. Fortunately, after `intro h,`\n"
"you can do `cases h with p q`. Then something new happens: because\n"
"there are two ways to prove `P ∨ Q` (namely, proving `P` or proving `Q`),\n"
"the `cases` tactic turns one goal into two, one for each case. You should\n"
"be able to make it home from there. \n"
msgstr ""
"# Fortgeschrittene Welt der Aussagen. \n"
"\n"
"## Level 7: `or_symm`\n"
"\n"
"Zu beweisen, dass $(P\\lor Q)\\implies(Q\\lor P)$ gilt, beinhaltet eine "
"Gefahr. \n"
"`intro h,` ist der offensichtliche Startpunkt, aber dann haben wir ein "
"Problem. \n"
"Sowohl `left` als auch `right` bringen uns zu einem unmöglichen Ziel. \n"
"Glücklicherweise kannst du stattdessen `cases h with p q` verwenden. \n"
"Es passiert dann etwas neues! Da es zwei Wege gibt `P ∨ Q`  zu beweisen \n"
"(nämlich `P` oder `Q` beweisen), splittet `cases` ein Ziel in zwei Ziele "
"auf. \n"
"Von hier aus solltest du alleine weiterkommen. \n"

#: Advanced Proposition world level 7
msgid ""
"If $P$ and $Q$ are true/false statements, then\n"
"$$P\\lor Q\\implies Q\\lor P.$$ \n"
msgstr ""
"Wenn $P$ und $Q$ Wahr/Falsch Aussagen sind, dann gilt: \n"
"$$P\\lor Q\\implies Q\\lor P.$$ \n"

#: Advanced Proposition world level 8
msgid ""
"# Advanced proposition world. \n"
"\n"
"## Level 8: `and_or_distrib_left`\n"
"\n"
"We know that `x(y+z)=xy+xz` for numbers, and this\n"
"is called distributivity of multiplication over addition.\n"
"The same is true for `∧` and `∨` -- in fact `∧` distributes\n"
"over `∨` and `∨` distributes over `∧`. Let's prove one of these.\n"
msgstr ""
"# Fortgeschrittene Welt der Aussagen. \n"
"\n"
"## Level 8: `and_or_distrib_left`\n"
"\n"
"Wir wissen, dass für Zahlen gilt: `x(y+z)=xy+xz` \n"
"Dieses Gesetz wird das Distributivgesetz der Multiplikation genannt. \n"
"Für `∧` und `∨` gilt dasselbe - tatsächlich ist `∧` distributiv \n"
"über `∨` und auch umgekehrt! Lass uns eins davon beweisen. \n"

#: Advanced Proposition world level 8
msgid ""
"If $P$. $Q$ and $R$ are true/false statements, then\n"
"$$P\\land(Q\\lor R)\\iff(P\\land Q)\\lor (P\\land R).$$ \n"
msgstr ""
"Wenn $P$, $Q$ und $R$ Wahr/Falsch Aussagen, dann gilt: \n"
"$$P\\land(Q\\lor R)\\iff(P\\land Q)\\lor (P\\land R).$$ \n"

#: Advanced Proposition world level 8
msgid ""
"## Pro tip\n"
"\n"
"Did you spot the import? What do you think it does?\n"
"\n"
"If you follow the instructions at\n"
"<a href=\"https://github.com/leanprover-community/mathlib#installation\" "
"target=\"blank\">the mathlib github page</a>\n"
"you will be able to install Lean and mathlib on your own system, and then "
"you can create a new project\n"
"and experiment with such imports yourself.\n"
msgstr ""
"## Profi Tipp\n"
"\n"
"Hast du den Import bemerkt? Was glaubst du tut er?Wenn du den Anweisungen "
"auf der \n"
"<a href=\"https://github.com/leanprover-community/mathlib#installation\" "
"target=\"blank\">mathlib github Seite</a>\n"
"folgst kannst du Lean und mathlib auf deinem eigenen System installieren. \n"
"Dann kannst du eigene Projekte anlegen und solche Importe selbst "
"ausprobieren. \n"

#: Advanced Proposition world level 9
msgid "import tactic.tauto -- useful high-powered tactic"
msgstr "import tactic.tauto -- eine nützliche, mächtige Taktik"

#: Advanced Proposition world level 9
msgid ""
"# Advanced proposition world. \n"
"\n"
"You already know enough to embark on advanced addition world. But here are "
"just a couple\n"
"more things.\n"
"\n"
"## Level 9: `exfalso` and proof by contradiction. \n"
"\n"
"It's certainly true that $P\\land(\\lnot P)\\implies Q$ for any propositions "
"$P$\n"
"and $Q$, because the left hand side of the implication is false. But how do\n"
"we prove that `false` implies any proposition $Q$? A cheap way of doing it "
"in\n"
"Lean is using the `exfalso` tactic, which changes any goal at all to "
"`false`. \n"
"You might think this is a step backwards, but if you have a hypothesis `h : "
"¬ P`\n"
"then after `rw not_iff_imp_false at h,` you can `apply h,` to make "
"progress. \n"
"Try solving this level without using `cc` or `tauto`, but using `exfalso` "
"instead.\n"
"\n"
msgstr ""
"# Fortgeschrittene Welt der Aussagen. \n"
"\n"
"Du weißt jetzt schon genug, um die fortgeschrittene Welt der Addition \n"
"zu betreten, aber hier gibt es noch ein paar nützliche Dinge: \n"
"\n"
"## Level 9: `exfalso` und der Beweis durch Widerspruch. \n"
"\n"
"Es ist natürlich wahr, dass $P\\land(\\lnot P)\\implies Q$ für beliebige \n"
"Aussagen $P$ und $Q$ gilt. Das liegt daran, dass die linke Seite der "
"Implikation \n"
"schon falsch ist. Aber wie kann man beweisen, dass aus `false` eine "
"beliebige \n"
"Aussage $Q$ folgt? Eine einfache Methode wäre die `exfalso` Taktik. Diese \n"
"Taktik dreht beliebige Ziele zu `false`. \n"
"Man könnte jetzt denken, dass das ein Schritt rückwärts ist, aber wenn man \n"
"eine Hypothese `h : ¬ P` betrachtet, dann wird nach `rw not_iff_imp_false at "
"h,` \n"
"`apply h`große Fortschritte machen .\n"
"Versuche das Level ohne `cc` oder `tauto` zu lösen, sondern stattdessen \n"
"mit `exfalso`. \n"
"\n"

#: Advanced Proposition world level 9
msgid ""
"If $P$ and $Q$ are true/false statements, then\n"
"$$(P\\land(\\lnot P))\\implies Q.$$\n"
msgstr ""
"Wenn $P$ und $Q$ Wahr/Falsch Aussagen sind, dann gilt: \n"
"$$(P\\land(\\lnot P))\\implies Q.$$\n"

#: Advanced Proposition world level 9
msgid ""
"## Pro tip.\n"
"\n"
"`¬ P` is actually `P → false` *by definition*. Try\n"
"commenting out `rw not_iff_imp_false at ...` by putting two minus signs `--"
"`\n"
"before the `rw`. Does it still compile?\n"
msgstr ""
"## Profi Tipp: \n"
"\n"
"`¬ P` ist eigentlich `P → false` *nach Definition*. Versuche \n"
"`rw not_iff_imp_false at ...` auszukommentieren, indem du zwei \n"
"Minuszeichen `--` vor `rw` schreibst. Kompiliert es immer noch? \n"

#: Advanced Proposition world level 9
msgid ""
"\n"
"## Summary\n"
"\n"
"`exfalso` changes your goal to `false`. \n"
"\n"
"## Details\n"
"\n"
"We know that `false` implies `P` for any proposition `P`, and so if your "
"goal is `P`\n"
"then you should be able to `apply` `false → P` and reduce your goal to "
"`false`. This\n"
"is what the `exfalso` tactic does. The theorem that `false → P` is called "
"`false.elim`\n"
"so one can achieve the same effect with `apply false.elim`. \n"
"\n"
"This tactic can be used in a proof by contradiction, where the hypotheses "
"are enough\n"
"to deduce a contradiction and the goal happens to be some random statement "
"(possibly\n"
"a false one) which you just want to simplify to `false`.\n"
msgstr ""
"\n"
"## Zusammenfassung\n"
"\n"
"`exfalso` verändert dein Ziel zu `false`. \n"
"\n"
"## Details\n"
"\n"
"Wir wissen, dass `false` eine beliebige Aussage `P` impliziert. Wenn dein "
"Ziel \n"
"also `P`ist, dann kannst du mit `apply` `false → P` verwenden und dein "
"Ziel \n"
"auf `false` reduzieren. Das ist es, was `exfalso` kann. Der Satz, der `false "
"→ P` \n"
"beinhaltet wird `false.elim` genannt. Deswegen hat `apply false.elim` "
"denselben Effekt. \n"
"\n"
"Diese Taktik kann in einem Beweis durch Widerspruch benutzt werden, in dem \n"
"die Hypothesen ausreichen, um einen Widerspruch zu erzeugen und das Ziel \n"
"eine zufällige Aussage (möglicherweise eine falsche) ist. Dann kannst du "
"es \n"
"zu `false` vereinfachen. \n"

#: Advanced Proposition world level 10
msgid ""
"local attribute [instance, priority 10] classical.prop_decidable -- we are "
"mathematicians"
msgstr ""
"lokales Attribut [Instanz, Priorität 10] classical.prop_decidable -- wir "
"sind Mathematiker."

#: Advanced Proposition world level 10
msgid ""
"# Advanced proposition world.\n"
"\n"
"\n"
"\n"
"## Level 10: the law of the excluded middle.\n"
"\n"
"We proved earlier that `(P → Q) → (¬ Q → ¬ P)`. The converse,\n"
"that `(¬ Q → ¬ P) → (P → Q)` is certainly true, but trying to prove\n"
"it using what we've learnt so far is impossible (because it is not provable "
"in\n"
"constructive logic). For example, after\n"
"\n"
"```\n"
"intro h,\n"
"intro p,\n"
"repeat {rw not_iff_imp_false at h},\n"
"```\n"
"\n"
"in the below, you are left with\n"
"```\n"
"P Q : Prop,\n"
"h : (Q → false) → P → false\n"
"p : P\n"
"⊢ Q\n"
"```\n"
"\n"
"The tools you have are not sufficient to continue. But you can just\n"
"prove this, and any other basic lemmas of this form like `¬ ¬ P → P`,\n"
"using the `by_cases` tactic. Instead of starting with all the `intro`s,\n"
"try this instead:\n"
"\n"
"`by_cases p : P; by_cases q : Q,`\n"
"\n"
"**Note the semicolon**! It means \"do the next tactic to all the goals, not "
"just the top one\".\n"
"After it, there are four goals, one for each of the four possibilities "
"PQ=TT, TF, FT, FF.\n"
"You can see that `p` is a proof of `P` in some of the goals, and a proof of "
"`¬ P` in others.\n"
"Similar comments apply to `q`. \n"
"\n"
"`repeat {cc}` then finishes the job.\n"
"\n"
"This approach assumed that `P ∨ ¬ P` was true; the `by_cases` tactic just "
"does `cases` on\n"
"this result. This is called the law of the excluded middle, and it cannot be "
"proved just\n"
"using tactics such as `intro` and `apply`.\n"
"\n"
msgstr ""
"# Fortgeschrittene Welt der Aussagen.\n"
"\n"
"\n"
"\n"
"## Level 10: Der Satz vom ausgeschlossenen Dritten.\n"
"\n"
"We haben schon bewiesen, dass `(P → Q) → (¬ Q → ¬ P)` gilt. Die Umkehrung \n"
"`(¬ Q → ¬ P) → (P → Q)` ist sicherlich wahr, aber wenn wir versuchen "
"würden, \n"
"dies mit allem zu beweisen, was wir bisher wissen, würden wir scheitern. \n"
"(das liegt daran, dass es mit konstruktiver Logik nicht beweisbar ist!) \n"
"Zum Beispiel: \n"
"\n"
"```\n"
"intro h,\n"
"intro p,\n"
"repeat {rw not_iff_imp_false at h},\n"
"```\n"
"\n"
"Danach bleibt noch übrig: \n"
"```\n"
"P Q : Prop,\n"
"h : (Q → false) → P → false\n"
"p : P\n"
"⊢ Q\n"
"```\n"
"\n"
"Unsere Werkzeuge reichen nicht aus, um weiterzumachen. Aber man kann \n"
"diese Aussage und andere grundlegende Lemmata dieser Form wie `¬ ¬ P → P` \n"
"beweisen, indem man die `by_cases` Taktik verwendet. Anstatt mit `intro`s, \n"
"versuche stattdessen das: \n"
"\n"
"`by_cases p : P; by_cases q : Q,`\n"
"\n"
"**Beachte den Strichpunkt**! Er bedeutet \"wende die nächste Taktik auf alle "
"Ziele \n"
"an, nicht nur das oberste\". \n"
"Danach gibt es vier Ziele, eines für jede der vier Möglichkeiten PQ=TT, TF, "
"FT, FF.\n"
"`p` ist ein Beweis für `P` in einigen der Ziele und für `¬ P` in anderen. \n"
"Ähnliches gilt auch für `q`. \n"
"\n"
"`repeat {cc}` beendet dann alle Ziele.\n"
"\n"
"In diesem Ansatz nehmen wir an, dass `P ∨ ¬ P` wahr ist; die `by_cases` "
"Taktik \n"
"wendet `cases` auf dieses Ergebnis an. \n"
"Das nennt man den Satz vom ausgeschlossenen Dritten und es kann nicht mit \n"
" Taktiken wie `intro` und `apply` bewiesen werden. \n"

#: Advanced Proposition world level 10
msgid ""
"If $P$ and $Q$ are true/false statements, then\n"
"$$(\\lnot Q\\implies \\lnot P)\\implies(P\\implies Q).$$ \n"
msgstr ""
"Wenn $P$ und $Q$ Wahr/Falsch Aussagen sind, dann gilt: \n"
"$$(\\lnot Q\\implies \\lnot P)\\implies(P\\implies Q).$$ \n"

#: Advanced Proposition world level 10
msgid ""
"OK that's enough logic -- now perhaps it's time to go on to Advanced "
"Addition World!\n"
"Get to it via the main menu.\n"
msgstr ""
"In Ordnung, das ist jetzt genug Logik -- es ist vielleicht ander Zeit \n"
"in die fortgeschrittene Welt der Addition zu gehen. \n"
"Du findest sie über das Hauptmenü! \n"

#: Advanced Proposition world level 10
msgid ""
"## Pro tip\n"
"\n"
"In fact the tactic `tauto!` just kills this goal (and many other logic "
"goals) immediately.\n"
msgstr ""
"## Profi Tipp \n"
"\n"
"Tatsächlich kann die Taktik `tauto` dieses Ziel direkt erfüllen (undviele "
"andere logische Ziele). \n"

#: Advanced Proposition world level 10
msgid ""
"\n"
"## Summary\n"
"\n"
"`by_cases h : P` does a cases split on whether `P` is true or false.\n"
"\n"
"## Details\n"
"\n"
"Some logic goals cannot be proved with `intro` and `apply` and `exact`.\n"
"The simplest example is the law of the excluded middle `¬ ¬ P → P`.\n"
"You can prove this using truth tables but not with `intro`, `apply` etc.\n"
"To do a truth table proof, the tactic `by_cases h : P` will turn a goal of\n"
"`⊢ ¬ ¬ P → P` into two goals\n"
"\n"
"```\n"
"P : Prop,\n"
"h : P\n"
"⊢ ¬¬P → P\n"
"\n"
"P : Prop,\n"
"h : ¬P\n"
"⊢ ¬¬P → P\n"
"```\n"
"\n"
"Each of these can now be proved using `intro`, `apply`, `exact` and "
"`exfalso`.\n"
"Remember though that in these simple logic cases, high-powered logic\n"
"tactics like `cc` and `tauto!` will just prove everything.\n"
"\n"
"\n"
"\n"
msgstr ""
"\n"
"## Zusammenfassung\n"
"\n"
"`by_cases h : P` erzeugt eine Fallunterscheidung, ob `P` wahr oder fasch "
"ist. \n"
"\n"
"## Details\n"
"\n"
"Einige logische Ziele können nicht mit `intro`, `apply` und `exact` gelöst "
"werden. \n"
"Das einfachste Beispiel ist der Satz vom ausgeschlossenen Dritten: `¬ ¬ P → "
"P`.\n"
"Man kan dies mit Wahrheitstabellen beweisen, aber nicht mit `intro`, "
"`apply`, etc. \n"
"Um eine Wahrheitstabelle zu erzeugen kann `by_cases h : P` verwendet "
"werden, \n"
"um ein Ziel `⊢ ¬ ¬ P → P` in zwei Ziele zu zerlegen. \n"
"\n"
"```\n"
"P : Prop,\n"
"h : P\n"
"⊢ ¬¬P → P\n"
"\n"
"P : Prop,\n"
"h : ¬P\n"
"⊢ ¬¬P → P\n"
"```\n"
"\n"
"Jedes Einzelne davon kann jetzt mit `intro`, `apply`, `exact`und \n"
"`exfalso` bewiesen werden. Denk daran, dass in diesen einfachen \n"
"logischen Fällen mächtige Taktiken wie `cc` und `tauto` \n"
"direkt alles beweisen. \n"
"\n"
"\n"
"\n"

#: Advanced Proposition world level 10
msgid ""
"\n"
"## Summary\n"
"\n"
"The `tauto` tactic (and its variant `tauto!`) will close various logic\n"
"goals.\n"
"\n"
"## Details\n"
"\n"
"`tauto` is an all-purpose logic tactic which will try to solve goals using "
"pure\n"
"logical reasoning -- for example it will close the following goal:\n"
"\n"
"```\n"
"P Q : Prop,\n"
"hP : P,\n"
"hQ : Q\n"
"⊢ P ∧ Q\n"
"```\n"
"\n"
"`tauto` is supposed to only use constructive logic, but its big brother "
"`tauto!` uses classical logic\n"
"and hence closes more goals.\n"
msgstr ""
"\n"
"## Zusammenfassung\n"
"\n"
"Die `tauto`Taktik (und seine Variante `tauto!`) wird verschiedene \n"
"logische Ziele erfüllen. \n"
"\n"
"## Details\n"
"\n"
"`tauto` ist eine Allzweck Logik Taktik, die versucht Ziele nur durch \n"
"reines logisches Argumentieren zu erfüllen -- zum Beispiel schließt \n"
"es das folgende Ziel: \n"
"\n"
"```\n"
"P Q : Prop,\n"
"hP : P,\n"
"hQ : Q\n"
"⊢ P ∧ Q\n"
"```\n"
"\n"
"`tauto` kann nur konstruktive Logik verwenden, aber sein großer Bruder \n"
"`tauto!` benutzt klassische Logik und kann deswegen mehr. \n"

#: world_config
msgid "Advanced Addition world"
msgstr "Fortgeschrittene Welt der Addition"

#: Advanced Addition world level 1
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 1: `succ_inj`. A function.\n"
"\n"
"Peano's original collection of axioms for the natural numbers contained two "
"further\n"
"assumptions, which have not yet been mentioned in the game:\n"
"\n"
"```\n"
"succ_inj {a b : mynat} :\n"
"  succ(a) = succ(b) → a = b\n"
"\n"
"zero_ne_succ (a : mynat) :\n"
"  zero ≠ succ(a)\n"
" ```\n"
"\n"
"The reason they have not been used yet is that they are both implications,\n"
"that is,\n"
"of the form $P\\implies Q$. This is clear for `succ_inj a b`, which\n"
"says that for all $a$ and $b$ we have $succ(a)=succ(b)\\implies a=b$.\n"
"For `zero_ne_succ` the trick is that $X\\ne Y$ is *defined to mean*\n"
"$X = Y\\implies{\\tt false}$. If you have played through Proposition world,\n"
"you now have the required Lean skills (i.e., you know the required\n"
"tactics) to work with these implications.\n"
"Let's finally learn how to use `succ_inj`. You should know a couple\n"
"of ways to prove the below -- one directly using an `exact`,\n"
"and one which uses an `apply` first. But either way you'll need to use "
"`succ_inj`.\n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Addition\n"
"\n"
"## Level 1: `succ_inj`. Eine Funktion\n"
"Peanos ursprüngliche Axiome für die natürlichen Zahlen enthalten zwei \n"
"weitere Annahmen, die wir bis jetzt noch nicht im Spiel erwähnt wurden: \n"
"\n"
"```\n"
"succ_inj {a b : mynat} :\n"
"  succ(a) = succ(b) → a = b\n"
"\n"
"zero_ne_succ (a : mynat) :\n"
"  zero ≠ succ(a)\n"
" ```\n"
"\n"
"Der Grund dafür, dass sie bisher noch nicht verwendet wurden ist, dass sie \n"
"beide Implikationen der Form $P\\implies Q$ sind. \n"
"Für `succ_inj a b` ist das klar, da es sagt, dass für alle $a$ und $b$ \n"
"gilt: $succ(a)=succ(b)\\implies a=b$.Für `zero_ne_succ` liegt der Trick in "
"der Tatsache, dass $X\\ne Y$ \n"
"*definiert* ist als $X = Y\\implies{\\tt false}$. \n"
"Wenn du die Welt der Aussagen gespielt hast, hast du jetzt alle "
"erforderlichen \n"
"Fähigkeiten (also die entsprechenden Taktiken), um mit diesen "
"Implikationen \n"
"zu arbeiten. Lass uns endlich lernen, wie wir `succ_inj` verwenden können. \n"
"Du solltest einige Wege kennen das zu beweisen -- einen direkten mit Hilfe \n"
"von `exact` und eine weitere mit `apply`. In jedem Fall brauchst du "
"`succ_inj`. \n"

#: Advanced Addition world level 1
msgid ""
"For all naturals $a$ and $b$, if we assume $succ(a)=succ(b)$, then we can\n"
"deduce $a=b$. \n"
msgstr ""
"Für alle natürlichen Zahlen $a$ und $b$ können wir, wenn $succ(a)=succ(b)$ "
"gilt folger, \n"
"dass gilt: $a=b$. \n"

#: Advanced Addition world level 1
msgid ""
"## Important thing.\n"
"\n"
"You can rewrite proofs of *equalities*. If `h : A = B` then `rw h` changes "
"`A`s to `B`s.\n"
"But you *cannot rewrite proofs of implications*. `rw succ_inj` will *never "
"work*\n"
"because `succ_inj` isn't of the form $A = B$, it's of the form $A\\implies B"
"$. This is one\n"
"of the most common mistakes I see from beginners. $\\implies$ and $=$ are "
"*two different things*\n"
"and you need to be clear about which one you are using.\n"
msgstr ""
"## Wichtig.\n"
"\n"
"Du kannst Beweise mit *Gleichungen* umschreiben. Wenn `h : A = B` gilt, "
"dann \n"
"wird `rw h` `A`s zu `B`s umschreiben. \n"
"Du kannst aber *keine Beweise mit Implikationen* umschreiben. `rw "
"succ_inj` \n"
"wird *nie* funktionieren. \n"
"Das liegt daran, dass `succ_inj` nicht von der Form $A = B$ ist. Es ist \n"
"von der Form $A\\implies B$. \n"
"Das ist einer der häufigsten Fehler, den Anfänger machen. $\\implies$ und $="
"$ sind \n"
"zwei *unterschiedliche Dinge* und dir muss klar sein, welches du benutzt. \n"

#: Advanced Addition world level 2
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 2: `succ_succ_inj`.\n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Addition\n"
"\n"
"## Level 2: `succ_succ_inj`.\n"

#: Advanced Addition world level 2
msgid ""
"In the below theorem, we need to apply `succ_inj` twice. Once to prove\n"
"$succ(succ(a))=succ(succ(b))\\implies succ(a)=succ(b)$, and then again\n"
"to prove $succ(a)=succ(b)\\implies a=b$. However `succ(a)=succ(b)` is\n"
"nowhere to be found, it's neither an assumption or a goal when we start\n"
"this level. You can make it with `have` or you can use `apply`.\n"
msgstr ""
"Für den Satz unten brauchen wir `succ_inj` zweimal. Zuerst, \n"
"um $succ(succ(a))=succ(succ(b))\\implies succ(a)=succ(b)$ zu beweisen, "
"dann \n"
"für $succ(a)=succ(b)\\implies a=b$. Allerdings ist `succ(a)=succ(b)` nicht "
"vorhanden. \n"
"Es ist weder eine Annahme noch ein Ziel, wenn das Level startet. Du kannst "
"es mit \n"
"mit `have` erzeugen oder einfach `apply` verwenden. "

#: Advanced Addition world level 2
msgid ""
"For all naturals $a$ and $b$, if we assume $succ(succ(a))=succ(succ(b))$, "
"then we can\n"
"deduce $a=b$. \n"
msgstr ""
"Für alle natürlichen Zahlen $a$ und $b$ gilt: aus "
"$succ(succ(a))=succ(succ(b))$ \n"
"folgt $a=b$. \n"

#: Advanced Addition world level 2
msgid ""
"## Sample solutions to this level. \n"
"\n"
"Make sure you understand them all. And remember that `rw` should not be "
"used\n"
"with `succ_inj` -- `rw` works only with equalities or `↔` statements,\n"
"not implications or functions.\n"
"\n"
msgstr ""
"## Beispiellösungen für dieses Level. \n"
"\n"
"Du solltest alle verstehen, denk außerdem daran, dass `rw` nicht mit \n"
"`succ_inj` funktioniert -- `rw` kann nur Gleichheiten oder `↔` Aussagen \n"
"verwenden, keine Implikationen oder Funktionen. \n"

#: Advanced Addition world level 3
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 3: `succ_eq_succ_of_eq`.\n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Addition\n"
"\n"
"## Level 3: `succ_eq_succ_of_eq`.\n"

#: Advanced Addition world level 3
msgid ""
"We are going to prove something completely obvious: if $a=b$ then\n"
"$succ(a)=succ(b)$. This is *not* `succ_inj`!\n"
"This is trivial -- we can just rewrite our proof of `a=b`.\n"
"But how do we get to that proof? Use the `intro` tactic.\n"
msgstr ""
"Wir werden etwas völlig offensichtliches beweisen: \n"
"wenn $a=b$ gilt, dann folgt $succ(a)=succ(b)$. Dies entspricht \n"
"*nicht* `succ_inj`! Im Prinzip ist dieser Beweis trivial -- wir \n"
"können einfach unseren Beweis von `a=b` umschreiben. \n"
"Wie kommen wir aber an diesen heran? Verwende `intro`!\n"

#: Advanced Addition world level 3
msgid "For all naturals $a$ and $b$, $a=b\\implies succ(a)=succ(b)$. \n"
msgstr ""
"Für alle natürlichen Zahlen $a$ und $b$ gilt: $a=b\\implies "
"succ(a)=succ(b)$. \n"

#: Advanced Addition world level 4
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 4: `eq_iff_succ_eq_succ`\n"
"\n"
"Here is an `iff` goal. You can split it into two goals (the implications in "
"both\n"
"directions) using the `split` tactic, which is how you're going to have to "
"start.\n"
"\n"
"`split,`\n"
"\n"
"Now you have two goals. The first is exactly `succ_inj` so you can close\n"
"it with\n"
"\n"
"`exact succ_inj,`\n"
"\n"
"and the second one you could solve by looking up the name of the theorem\n"
"you proved in the last level and doing `exact <that name>`, or "
"alternatively\n"
"you could get some more `intro` practice and seeing if you can prove it\n"
"using `intro`, `rw` and `refl`.\n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Addition\n"
"\n"
"## Level 4: `eq_iff_succ_eq_succ`\n"
"\n"
"Wir haben hier ein `iff` Ziel. Du kannst es in zwei Ziele aufteilen mit "
"Hilfe \n"
"von `split`, so musst du auch anfangen! \n"
"\n"
"`split,`\n"
"\n"
"Jetzt hast du zwei Ziele. Das erste entspricht genau `succ_inj`, du kannst "
"es \n"
"also mit\n"
"`exact succ_inj,`\n"
"\n"
"lösen. Das zweite Ziel könntest du erreichen, wenn du den Namen des Satzes \n"
"aus dem letzten Level nachsiehst und `exact <der Name>`verwendest. \n"
"Alternativ kannst du ein wenig `intro`, `rw` und `refl` üben. \n"

#: Advanced Addition world level 4
msgid ""
"Two natural numbers are equal if and only if their successors are equal.\n"
msgstr ""
"Zwei natürliche Zahlen sind genau dann gleich, wenn ihre Nachfolger gleich "
"sind. \n"

#: Advanced Addition world level 5
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 5: `add_right_cancel`\n"
"\n"
"The theorem `add_right_cancel` is the theorem that you can cancel on the "
"right\n"
"when you're doing addition -- if `a + t = b + t` then `a = b`. After `intro "
"h`\n"
"I'd recommend induction on `t`. Don't forget that `rw add_zero at h` can be "
"used\n"
"to do rewriting of hypotheses rather than the goal.\n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Addition\n"
"\n"
"## Level 5: `add_right_cancel`\n"
"\n"
"Der Satz `add_right_cancel` ist ein Satz über das \"Kürzen\" auf der \n"
"rechten Seite einer Addition -- wenn `a + t = b + t` gilt, dann ist `a = "
"b`. \n"
"Nach dem `intro` solltest du eine Induktion über `t` durchführen. Vergiss "
"nicht \n"
" `rw add_zero at h`, hiermit kannst du deine Hypothesen umschreiben "
"anstelle \n"
"deines Ziels. \n"

#: Advanced Addition world level 5
msgid ""
"On the set of natural numbers, addition has the right cancellation "
"property.\n"
"In other words, if there are natural numbers $a, b$ and $c$ such that\n"
"$$ a + t = b + t, $$\n"
"then we have $a = b$.\n"
msgstr ""
"In der Menge der natürlichen Zahlen hat die Addition die Eigenschaft \n"
"des Kürzens auf der rechten Seite. Mit anderen Worten: \n"
"Wenn wir natürliche Zahlen $a,b$ und $t$ haben mit $$ a + t = b + t,$$ \n"
"dann gilt $a = b$. \n"

#: Advanced Addition world level 6
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 6: `add_left_cancel`\n"
"\n"
"The theorem `add_left_cancel` is the theorem that you can cancel on the "
"left\n"
"when you're doing addition -- if `t + a = t + b` then `a = b`. \n"
"There is a three-line proof which ends in `exact add_right_cancel a t b` (or "
"even\n"
"`exact add_right_cancel _ _ _`); this\n"
"strategy involves changing the goal to the statement of `add_right_cancel` "
"somehow.\n"
"\n"
"\n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Addition\n"
"\n"
"## Level 6: `add_left_cancel`\n"
"\n"
"Der Satz `add_left_cancel` ist ein Satz über das \"Kürzen\" auf der \n"
"linken Seite einer Addition -- wenn `t + a = t + b` gilt, dann ist `a = "
"b`. \n"
"Es gibt einen Dreizeiler als Beweis, der mit `exact add_right_cancel a t "
"b` \n"
"endet (oder sogar `exact add_right_cancel _ _ _`). \n"
"Diese Strategie beinhaltet das Ändern des Ziels zur Aussage von "
"`add_right_cancel`. \n"
"\n"
"\n"

#: Advanced Addition world level 6
msgid ""
"On the set of natural numbers, addition has the left cancellation property.\n"
"In other words, if there are natural numbers $a, b$ and $t$ such that\n"
"$$ t + a = t + b, $$\n"
"then we have $a = b$.\n"
msgstr ""
"In der Menge der natürlichen Zahlen hat die Addition die Eigenschaft \n"
"des Kürzens auf der linken Seite. Mit anderen Worten: \n"
"Wenn wir natürliche Zahlen $a,b$ und $t$ haben mit $$ t + a = t + b,$$ \n"
"dann gilt $a = b$. \n"

#: Advanced Addition world level 7
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 7: `add_right_cancel_iff`\n"
"\n"
"It's sometimes convenient to have the \"if and only if\" version\n"
"of theorems like `add_right_cancel`. Remember that you can use `split`\n"
"to split an `↔` goal into the `→` goal and the `←` goal.\n"
"\n"
"## Pro tip:\n"
"\n"
"`exact add_right_cancel _ _ _` means \"let Lean figure out the missing inputs"
"\"\n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Addition \n"
"\n"
"## Level 7: `add_right_cancel_iff`\n"
"\n"
"Es ist manchmal praktisch die \"genau dann wenn\" Variante von Sätzen \n"
"wie `add_right_cancel` zu haben. Denk daran, dass du solche Ziele mit \n"
"`split` in ein `→` und ein `←` Ziel verwandeln kannst. \n"
"\n"
"## Profi Tipp:\n"
"\n"
"`exact add_right_cancel _ _ _`bedeutet \"Lass Lean die fehlenden Eingaben \n"
"herausfinden\"\n"

#: Advanced Addition world level 7
msgid ""
"For all naturals $a$, $b$ and $t$, \n"
"$$ a + t = b + t\\iff a=b. $$\n"
msgstr ""
"Für alle natürlichen Zahlen $a$, $b$ und $t$ gilt: \n"
"$$ a + t = b + t\\iff a=b. $$\n"

#: Advanced Addition world level 8
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 8: `eq_zero_of_add_right_eq_self`\n"
"\n"
"The lemma you're about to prove will be useful when we want to prove that $"
"\\leq$ is antisymmetric.\n"
"There are some wrong paths that you can take with this one.\n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Addition\n"
"## Level 8: `eq_zero_of_add_right_eq_self`\n"
"\n"
"Das folgende Lemma wird nützlich sein, wenn wir \\leq$ is antisymmetric \n"
" beweisen werden. Es gibt hier einige falsche Wege die du nehmen könntest. \n"

#: Advanced Addition world level 8
msgid ""
"If $a$ and $b$ are natural numbers such that \n"
"$$ a + b = a, $$\n"
"then $b = 0$.\n"
msgstr ""
"Sind $a$ und $b$ natürliche Zahlen mit $$ a + b = a$$ \n"
"dann gilt $b = 0$. \n"

#: Advanced Addition world level 9
msgid ""
"\n"
"## Summary\n"
"\n"
"`symmetry` turns goals of the form `⊢ A = B` to `⊢ B = A`.\n"
"Also works with `≠`. Also works on hypotheses: if `h : a ≠ b`\n"
"then `symmetry at h` gives `h : b ≠ a`.\n"
"\n"
"## Details\n"
"\n"
"`symmetry` works on both goals and hypotheses. By default it\n"
"works on the goal. It will turn a goal of the form `⊢ A = B`\n"
"to `⊢ B = A`. More generally it will work with any symmetric\n"
"binary relation (for example `≠`, or more generally any\n"
"binary relation whose proof of symmetry has been tagged\n"
"with the `symm` attribute).\n"
"\n"
"To get `symmetry` working on a hypothesis, use `symmetry at h`.\n"
"\n"
"## Examples\n"
"\n"
"If the tactic state is\n"
"```\n"
"h : a = b\n"
"⊢ c ≠ d\n"
"```\n"
"\n"
"then `symmetry` changes the goal to `⊢ d ≠ c` and\n"
"`symmetry at h` changes `h` to `h : b = a`.\n"
msgstr ""
"\n"
"## Zusammenfassung\n"
"\n"
"`symmetry` bringt Ziele `⊢ A = B` in die Form `⊢ B = A`. \n"
"Es funktioniert auch mit `≠` und Hypothesen: gilt `h : a ≠ b`, \n"
"dann liefert `symmetry at h` `h : b ≠ a`.\n"
"\n"
"## Details\n"
"\n"
"`symmetry` funktioniert mit Zielen und Hypothesen. Standardmäßig \n"
"allerdings verändert es das Ziel. Es wird ein Ziel der Form `⊢ A = B` \n"
"zu `⊢ B = A` umwandeln. Allgemeiner: es funktioniert mit beliebigen \n"
"binären Relationen (z.B. `≠`, oder noch allgemeiner eine beliebige \n"
" binäre binäre Relation deren Beweis der Symmetrie mit dem `symm` \n"
"Attribut versehen wurde). \n"
"\n"
"Um `symmetry` auf Hypothesen anzuwenden verwende: `symmetry at h`. \n"
"\n"
"## Examples\n"
"\n"
"Wenn unser Zustand so aussieht: \n"
"```\n"
"h : a = b\n"
"⊢ c ≠ d\n"
"```\n"
"\n"
"dann wird `symmetry` das Ziel zu `⊢ d ≠ c` umwandeln und \n"
"`symmetry at h` bring `h` in die Form `h : b = a`.\n"

#: Advanced Addition world level 9
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 9: `succ_ne_zero`\n"
"\n"
"Levels 9 to 13 introduce the last axiom of Peano, namely\n"
"that $0\\not=\\operatorname{succ}(a)$. The proof of this is called "
"`zero_ne_succ a`. \n"
"\n"
"`zero_ne_succ (a : mynat) : 0 ≠ succ(a)`\n"
"\n"
"The `symmetry` tactic will turn any goal of the form `R x y` into `R y x`,\n"
"if `R` is a symmetric binary relation (for example `=` or `≠`).\n"
"In particular, you can prove `succ_ne_zero` below by first using\n"
"`symmetry` and then `exact zero_ne_succ a`. \n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Addition \n"
"\n"
"## Level 9: `succ_ne_zero`\n"
"\n"
"Die Level 9 bis 13 werden das letzte Axiom von Pean einführen, nämlich \n"
"dass gilt: $0\\not=\\operatorname{succ}(a). Dieser Beweis heißt "
"$`zero_ne_succ a`. \n"
"\n"
"`zero_ne_succ (a : mynat) : 0 ≠ succ(a)`\n"
"\n"
"Die `symmetry` Taktik wird jedes Ziel der Form `R x y` in `R y x` \n"
"verwandeln, wenn `R` eine symmetrische binäre Relation ist (also \n"
"z.B. `=` oder `≠`). \n"
"Insbesondere kannst du `succ_ne_zero` lösen, indem du zuerst `symmetry` \n"
"verwendest und dann `exact zero_ne_succ a`.\n"

#: Advanced Addition world level 9
msgid "Zero is not the successor of any natural number.\n"
msgstr "Null ist kein Nachfolger einer natürlichen Zahl. \n"

#: Advanced Addition world level 10
msgid ""
"# Advanced Addition World\n"
"\n"
"## Level 10: `add_left_eq_zero`\n"
"\n"
"## Important: the definition of `≠`\n"
"\n"
"In Lean, `a ≠ b` is *defined to mean* `(a = b) → false`. \n"
"This means that if you see `a ≠ b` you can *literally treat\n"
"it as saying* `(a = b) → false`. Computer scientists would\n"
"say that these two terms are *definitionally equal*. \n"
"\n"
"The following lemma, $a+b=0\\implies b=0$, will be useful in inequality "
"world.\n"
"Let me go through the proof, because it introduces several new\n"
"concepts: \n"
"\n"
"* `cases b`, where `b : mynat`\n"
"* `exfalso`\n"
"* `apply succ_ne_zero`\n"
"\n"
"We're going to prove $a+b=0\\implies b=0$. Here is the\n"
"strategy. Each natural number is either `0` or `succ(d)` for\n"
"some other natural number `d`. So we can start the proof\n"
"with \n"
"\n"
"`cases b with d,`\n"
"\n"
"and then we have two goals, the case `b = 0` (which you can solve easily)\n"
"and the case `b = succ(d)`, which looks like this:\n"
"\n"
"```\n"
"a d : mynat,\n"
"H : a + succ d = 0\n"
"⊢ succ d = 0\n"
"```\n"
"\n"
"Our goal is impossible to prove. However our hypothesis `H`\n"
"is also impossible, meaning that we still have a chance!\n"
"First let's see why `H` is impossible. We can\n"
"\n"
"`rw add_succ at H,`\n"
"\n"
"to turn `H` into `H : succ (a + d) = 0`. Because\n"
"`succ_ne_zero (a + d)` is a proof that `succ (a + d) ≠ 0`,\n"
"it is also a proof of the implication `succ (a + d) = 0 → false`.\n"
"Hence `succ_ne_zero (a + d) H` is a proof of `false`!\n"
"Unfortunately our goal is not `false`, it's a generic\n"
"false statement. \n"
"\n"
"Recall however that the `exfalso` command turns any goal into `false`\n"
"(it's logically OK because `false` implies every proposition, true or "
"false).\n"
"You can probably take it from here.\n"
msgstr ""
"# Fortgeschrittene Welt der Addition\n"
"\n"
"## Level 10: `add_left_eq_zero`\n"
"\n"
"## Wichtig: Die Definition von `≠`\n"
"\n"
"In Lean ist `a ≠ b` *definiert* als  `(a = b) → false`. \n"
"Das bedeutet: siehst du `a ≠ b`, dann kannst du es genauso \n"
"behandeln wie `(a = b) → false`. Informatiker würden sagen, \n"
"dass diese beiden Aussagen *definitionsmäßig gleich* sind. \n"
"\n"
"Das folgende Lemma $a+b=0\\implies b=0$ wird in der Welt der \n"
"Ungleichheit nützlich sein. \n"
"Wir sehen den Beweis gemeinsam durch, denn er enthält einige neue \n"
"Konzepte: \n"
"\n"
"* `cases b`, where `b : mynat`\n"
"* `exfalso`\n"
"* `apply succ_ne_zero`\n"
"\n"
"Wir werden $a+b=0\\implies b=0$ beweisen. Hier kommt die Strategie: \n"
"Jede natürliche Zahl ist entweder `0` oder `succ(d)` für \n"
"eine andere natürliche Zahl `d`. Wir können also anfangen mit: \n"
"\n"
"`cases b with d,`\n"
"\n"
"Jetzt haben wir zwei Ziele, den Fall `b=0`(den du einfach lösen kannst) \n"
"und den Fall `b=succ(d)`, der so aussieht: \n"
"\n"
"```\n"
"a d : mynat,\n"
"H : a + succ d = 0\n"
"⊢ succ d = 0\n"
"```\n"
"\n"
"Unser Ziel ist unmöglich zu beweisen. Allerdings auch unsere \n"
"Hypothese H, wir haben also noch eine Chance! \n"
"Wir können \n"
"`rw add_succ at H,`\n"
"\n"
"schreiben, um `H` in `H : succ (a + d) = 0` umzuschreiben. \n"
"Da `succ_ne_zero(a+d)` ein Beweis für `succ (a + d) ≠ 0` ist, \n"
"ist es auch ein Beweis für die Implikation `succ (a + d) = 0 → false`.\n"
"Also ist `succ_ne_zero (a + d) H` ein beweis für `false`! \n"
"Leider ist unser Ziel nicht `false`, sondern eine allgemeine falsche \n"
"Aussage. \n"
"\n"
"Denk daran, das wir für solche Fälle `exfalso` haben, dass beliebige \n"
"Ziele in `false` umwandelt. (Das ist logisch in Ordnung, da `false`\n"
"jede andere logische Aussage, egal ob wahr oder falsch, impliziert). \n"
"Von hier aus solltest du vermutlich alleine zurecht kommen. \n"

#: Advanced Addition world level 10
msgid ""
"If $a$ and $b$ are natural numbers such that \n"
"$$ a + b = 0, $$\n"
"then $b = 0$.\n"
msgstr ""
"Sind $a$ und $b$ natürliche Zahlen mit $$ a + b = 0, $$\n"
"dann gilt $b=0$. \n"

#: Advanced Addition world level 11
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 11: `add_right_eq_zero`\n"
"\n"
"We just proved `add_left_eq_zero (a b : mynat) : a + b = 0 → b = 0`.\n"
"Hopefully `add_right_eq_zero` shouldn't be too hard now.\n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Addition\n"
"\n"
"## Level 11: `add_right_eq_zero`\n"
"\n"
"Wir haben gerade `add_left_eq_zero (a b : mynat) : a + b = 0 → b = 0` "
"bewiesen.\n"
"`add_right_eq_zero` sollte dann hoffentlich nicht zu schwer sein. \n"

#: Advanced Addition world level 11
msgid ""
"If $a$ and $b$ are natural numbers such that \n"
"$$ a + b = 0, $$\n"
"then $a = 0$.\n"
msgstr ""
"Sind $a$ und $b$ natürliche Zahlen mit $$ a + b = 0,$$ \n"
"dann gilt $a = 0$. \n"

#: Advanced Addition world level 12
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 12: `add_one_eq_succ`\n"
"\n"
"We have\n"
"\n"
"  * `succ_eq_add_one (n : mynat) : succ n = n + 1`\n"
"\n"
"but sometimes the other way is also convenient.\n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Addition\n"
"\n"
"## Level 12: `add_one_eq_succ`\n"
"\n"
"Wir haben: \n"
"\n"
"  * `succ_eq_add_one (n : mynat) : succ n = n + 1`\n"
"\n"
"Manchmal ist die Rückrichtung aber auch nützlich. \n"

#: Advanced Addition world level 12
msgid ""
"For any natural number $d$, we have\n"
"$$ d+1 = \\operatorname{succ}(d). $$\n"
msgstr ""
"Für eine natürliche Zahl $d$ gilt: $$ d+1 = \\operatorname{succ}(d). $$\n"

#: Advanced Addition world level 13
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 13: `ne_succ_self`\n"
"\n"
"The last level in Advanced Addition World is the statement\n"
"that $n\\not=\\operatorname{succ}(n)$. When you've done this\n"
"you've completed Advanced Addition World and can move on\n"
"to Advanced Multiplication World (after first doing\n"
"Multiplication World, if you didn't do it already). \n"
msgstr ""
"\n"
"# Fortgeschrittene Welt der Addition\n"
"\n"
"## Level 13: `ne_succ_self`\n"
"\n"
"Im letzten Level der fortgeschrittenen Welt der Addition geht \n"
"es um die Aussage $n\\not=\\operatorname{succ}(n)$. \n"
"Wenn du hiermit fertig bist, has du die fortgeschrittene Welt \n"
"der Addition abgeschlossen und kannst in die fortgeschrittene Welt \n"
"der Multiplikation vorrücken. (Wenn du die Welt der Multiplikation schon "
"hast). \n"

#: Advanced Addition world level 13
msgid ""
"For any natural number $n$, we have\n"
"$$ n \\neq \\operatorname{succ}(n). $$\n"
msgstr ""
"Für eine natürliche Zahl $n$ gilt $$ n \\neq \\operatorname{succ}(n). $$\n"

#: world_config
msgid "Advanced Multiplication world"
msgstr "Fortgeschrittene Welt der Multiplikation"

#: Advanced Multiplication world level 1
msgid ""
"# Advanced Multiplication World\n"
"\n"
"## Level 1: `mul_pos`\n"
"\n"
"Welcome to Advanced Multiplication World! Before attempting this\n"
"world you should have completed seven other worlds, including\n"
"Multiplication World and Advanced Addition World. There are four\n"
"levels in this world.\n"
"\n"
"Recall that if `b : mynat` is a hypothesis and you do `cases b with n`,\n"
"your one goal will split into two goals, \n"
"namely the cases `b = 0` and `b = succ(n)`. So `cases` here is like\n"
"a weaker version of induction (you don't get the inductive hypothesis).\n"
"\n"
"## Tricks\n"
"\n"
"1) if your goal is `⊢ X ≠ Y` then `intro h` will give you `h : X = Y` and\n"
"a goal of `⊢ false`. This is because `X ≠ Y` *means* `(X = Y) → false`.\n"
"Conversely if your goal is `false` and you have `h : X ≠ Y` as a hypothesis\n"
"then `apply h` will turn the goal into `X = Y`.\n"
"\n"
"2) if `hab : succ (3 * x + 2 * y + 1) = 0` is a hypothesis and your goal is "
"`⊢ false`,\n"
"then `exact succ_ne_zero _ hab` will solve the goal, because Lean will "
"figure\n"
"out that `_` is supposed to be `3 * x + 2 * y + 1`.\n"
"\n"
msgstr ""
"# Fortgeschrittene Welt der Multiplikation\n"
"\n"
"## Level 1: `mul_pos`\n"
"\n"
"Willkommen in der fortgeschrittenen Welt der Multiplikation! Bevor du dich \n"
"an dieser Welt versuchst solltest du sieben andere Welten besucht haben. \n"
"Das gilt insbesondere für die Welt der Multiplikation und der "
"fortgeschrittenen \n"
"Addition. Es gibt nur vier Level in dieser Welt. \n"
"\n"
"Erinnere dich daran, dass die Hypothese `b : mynat` mit `cases b with n` \n"
"in zwei Ziele aufgeteilt werden kann, nämlich `b=0` und `b= succ(n)`. \n"
"`cases` ist demnach eine schwächere Version der Induktion (man bekommt \n"
"keine Induktionsvoraussetzung). \n"
"\n"
"## Tricks\n"
"\n"
"1) Wenn dein Ziel `⊢ X ≠ Y` lautet, dann wird `intro h` dir `h : X = Y` "
"liefern \n"
"und ein Ziel `⊢ false`. Das liegt daran, dass `X ≠ Y` eben `(X = Y) → false` "
"*bedeutet*. \n"
"Umgekehrt gilt: ist dein Ziel `false`und du hast eine Hypothese  `h : X ≠ "
"Y`, dann wird \n"
"`apply h` das Ziel in `X = Y` verwandeln. \n"
"\n"
"2) Ist `hab : succ (3 * x + 2 * y + 1) = 0` eine Hypothese und dein Ziel "
"ist \n"
"`⊢ false`, dann wird `exact succ_ne_zero _ hab` das Ziel erfüllen, da Lean \n"
"von selbst herausfindet, dass  `_`  `3 * x + 2 * y + 1` sein soll. \n"
"\n"

#: Advanced Multiplication world level 1
msgid "The product of two non-zero natural numbers is non-zero.\n"
msgstr ""
"Das Produkt zweier natürlichen Zahlen ungleich Null ist ungleich null. \n"

#: Advanced Multiplication world level 2
msgid ""
"# Advanced Multiplication World\n"
"\n"
"## Level 2: `eq_zero_or_eq_zero_of_mul_eq_zero`\n"
"\n"
"A variant on the previous level.\n"
msgstr ""
"# Fortgeschrittene Welt der Multiplikation\n"
"\n"
"## Level 2: `eq_zero_or_eq_zero_of_mul_eq_zero`\n"
"\n"
"Eine Variation des vorherigen Levels.\n"

#: Advanced Multiplication world level 2
msgid "If $ab = 0$, then at least one of $a$ or $b$ is equal to zero.\n"
msgstr "Wenn $ab=0$ ist, dann ist $a=0$ und/oder $b=0$. \n"

#: Advanced Multiplication world level 3
msgid ""
"# Advanced Multiplication World\n"
"\n"
"## Level 3: `mul_eq_zero_iff`\n"
"\n"
"Now you have `eq_zero_or_eq_zero_of_mul_eq_zero` this is pretty "
"straightforward.\n"
msgstr ""
"# Fortgeschrittene Welt der Multiplikation\n"
"\n"
"## Level 3: `mul_eq_zero_iff`\n"
"\n"
"Da du `eq_zero_or_eq_zero_of_mul_eq_zero` hast ist dieses Level einfach. \n"

#: Advanced Multiplication world level 3
msgid "$ab = 0$, if and only if at least one of $a$ or $b$ is equal to zero.\n"
msgstr "$ab = 0$ gilt genau dann, wenn $a=0$ und/oder $b=0$. \n"

#: Advanced Multiplication world level 4
msgid ""
"# Advanced Multiplication World\n"
"\n"
"## Level 4: `mul_left_cancel`\n"
"\n"
"This is the last of the bonus multiplication levels.\n"
"`mul_left_cancel` will be useful in inequality world.\n"
"\n"
"People find this level hard. I have probably had more questions about this\n"
"level than all the other levels put together, in fact. Many levels in this\n"
"game can just be solved by \"running at it\" -- do induction on one of the\n"
"variables, keep your head, and you're done. In fact, if you like a "
"challenge,\n"
"it might be instructive if you stop reading after the end of this paragraph "
"and try solving this level now by induction,\n"
"seeing the trouble you run into, and reading the rest of these comments "
"afterwards. This level\n"
"has a sting in the tail. If you are a competent mathematician, try\n"
"and figure out what is going on. Write down a maths proof of the\n"
"theorem in this level. Exactly what statement do you want to prove\n"
"by induction? It is subtle.\n"
"\n"
"Ok so here are some spoilers. The problem with naively running at it, is "
"that if you try induction on,\n"
"say, $c$, then you are imagining a and b as fixed, and your inductive\n"
"hypothesis $P(c)$ is $ab=ac \\implies b=c$. So for your inductive step\n"
"you will be able to assume $ab=ad \\implies b=d$ and your goal will\n"
"be to show $ab=a(d+1) \\implies b=d+1$. When you also assume $ab=a(d+1)$\n"
"you will realise that your inductive hypothesis is *useless*, because\n"
"$ab=ad$ is not true! The statement $P(c)$ (with $a$ and $b$ regarded\n"
"as constants) is not provable by induction.\n"
"\n"
"What you *can* prove by induction is the following *stronger* statement.\n"
"Imagine $a\\not=0$ as fixed, and then prove \"for all $b$, if $ab=ac$ then "
"$b=c$\"\n"
"by induction on $c$. This gives us the extra flexibility we require.\n"
"Note that we are quantifying over all $b$ in the inductive hypothesis -- it\n"
"is essential that $b$ is not fixed. \n"
"\n"
"You can do this in two ways in Lean -- before you start the induction\n"
"you can write `revert b,`. The `revert` tactic is the opposite of the "
"`intro`\n"
"tactic; it replaces the `b` in the hypotheses with \"for all $b$\" in the "
"goal.\n"
"\n"
"Alternatively, you can write `induction c with d hd\n"
"generalizing b` as the first line of the proof. \n"
"\n"
"If you do not modify your technique in this way, then this level seems\n"
"to be impossible (judging by the comments I've had about it!)\n"
msgstr ""
"# Fortgeschrittene Welt der Multiplikation\n"
"\n"
"## Level 4: `mul_left_cancel`\n"
"\n"
"Dies ist das letzte der Bonus Level der Multiplikation. \n"
"`mul_left_cancel` wird in der Welt der Ungleichheit nützlich sein. \n"
"\n"
"Dieses Level scheint schwer zu sein. Ich habe wahrscheinlich mehr Fragen "
"zu \n"
"diesem Level erhalten, als zu allen anderen leveln zusammen. Viele Level \n"
"in diesem Spiel können durch \"mit dem Kopf dagegen hämmern\" gelöst werden "
"-- \n"
"Wende Induktion auf eine der Variablen an, denke ein wenig und fertig. \n"
"Wenn du also eine Herausforderung möchtest, dann höre nach diesem Abschnitt "
"auf \n"
"zu lesen und versuche es mit Induktion. Wenn du Probleme bekommst, dann lies "
"den \n"
"Rest dieser Anweisungen danach. \n"
"Dieses Level ist stachlig, wenn du ein kompetenter Mathematiker bist, dann "
"versuche \n"
"herauszufinden was hier los ist. Schreibe einen mathematischen Beweis auf. \n"
"Was genau willst du hier mit Induktion beweisen? Es ist subtil! \n"
"\n"
"Ok, also einige Spoiler. Das Problem mit dem naiven Ansatz ist hier, dass \n"
"die Anwendung von Induktion auf z.B. $c$ bedeutet, dass du dir vorstellst, "
"dass \n"
"$a$ und $b$ fixiert sind und die Induktionsvoraussetzung $P(c)$$ bedeutet: \n"
"$ab=ac \\implies b=c$. Für den Induktionsschritt wirst du dann $ab=ad "
"\\implies b=d$ \n"
"nutzen können und dein Ziel wird sein $ab=a(d+1) \\implies b=d+1$ zu "
"zeigen. \n"
"Nimmst du auch noch  $ab=a(d+1)$ an wirst du feststellen, dass die "
"Induktions- \n"
"voraussetzung *nutzlos* ist, da $ab=ad$ nicht wahr ist! Die Aussage $P(c)$ \n"
"(mit $a$ und $b$ als Konstanten) ist nicht mit Induktion beweisbar. \n"
"\n"
"Was du aber mit Induktion beweisen *kannst* ist die folgende, sogar \n"
"*stärkere* Aussage. Nimm $a\\not=0$ als fixiert an und beweise dann \n"
"\"für alle $b$ ist $b=c$, wenn $ab=ac$ gilt\" mit Induktion auf $c$. \n"
"Das liefert uns die zusätzliche Flexibilität, die wir benötigen. \n"
"Beachte außerdem, dass wir unsere Induktionsvoraussetzung für alle \n"
"$b$ setzen -- es ist wichtig, dass $b$ nicht fixiert ist. \n"
"\n"
"In Lean kannst du das auf zwei Arten rreichen -- bevor du die Induktion \n"
"startest kannst du `revert b,` schreiben. Die `revert` Taktik ist das \n"
"Gegenteil von `intro`; sie ersetzt die `b`s in der Hypothese mit \n"
"\" für alle $b$ gilt\" im Ziel. \n"
"\n"
"Alternativ kannst du auch `induction c with d hd generalizing b`als \n"
"erste Zeile im Beweis schreiben. \n"
"\n"
"Falls du dein Vorgehen nicht in dieser Weise anpasst, dann scheint \n"
"dieses Level unmöglich (zumindest wenn man den Kommentaren glaibt!) \n"

#: Advanced Multiplication world level 4
msgid ""
"If $a \\neq 0$, $b$ and $c$ are natural numbers such that\n"
"$ ab = ac, $\n"
"then $b = c$.\n"
msgstr ""
"Seien $\\neq 0$, $b$ und $c$ natürliche Zahlen mit $ab = ac,$ \n"
"dann gilt $b = c$. \n"

#: Advanced Multiplication world level 4
msgid "You should now be ready for inequality world.\n"
msgstr "Du solltest jetzt für die Welt der Ungleichheit bereit sein. \n"

#: Advanced Multiplication world level 4
msgid ""
"\n"
"## Summary\n"
"\n"
"`revert x` is the opposite to `intro x`.\n"
"\n"
"## Details\n"
"\n"
"If the tactic state looks like this\n"
"\n"
"```\n"
"P Q : Prop,\n"
"h : P\n"
"⊢ Q\n"
"```\n"
"\n"
"then `revert h` will change it to\n"
"\n"
"```\n"
"P Q : Prop\n"
"⊢ P → Q\n"
"```\n"
"\n"
"`revert` also works with things like natural numbers: if\n"
"the tactic state looks like this\n"
"\n"
"```\n"
"m : mynat\n"
"⊢ m + 1 = succ m\n"
"```\n"
"\n"
"then `revert m` will turn it into\n"
"\n"
"```\n"
"⊢ ∀ (m : mynat), m + 1 = mynat.succ m\n"
"```\n"
"\n"
msgstr ""
"\n"
"## Zusammenfassung\n"
"\n"
"`revert x` ist das Gegenteil von `intro x`.\n"
"\n"
"## Details\n"
"\n"
"Wenn dein Zustand wie folgt aussieht,\n"
"```\n"
"P Q : Prop,\n"
"h : P\n"
"⊢ Q\n"
"```\n"
"\n"
"dann wird `revert h` folgenden Effekt haben:\n"
"```\n"
"P Q : Prop\n"
"⊢ P → Q\n"
"```\n"
"\n"
"`revert`funktioniert auch mit natürlichen Zahlen: \n"
"\n"
"```\n"
"m : mynat\n"
"⊢ m + 1 = succ m\n"
"```\n"
"\n"
"`revert m` wird dies umschreiben zu: \n"
"\n"
"```\n"
"⊢ ∀ (m : mynat), m + 1 = mynat.succ m\n"
"```\n"
"\n"

#: world_config
msgid "Inequality world"
msgstr "Welt der Ungleichheit"

#: Inequality world level 1
msgid "import mynat.le -- import definition of ≤"
msgstr "import mynat.le -- importiere die Definition von of ≤"

#: Inequality world level 1
msgid ""
"## Summary\n"
"\n"
"`use` works on the goal. If your goal is `⊢ ∃ c : mynat, 1 + x = x + c`\n"
"then `use 1` will turn the goal into `⊢ 1 + x = x + 1`, and the rather\n"
"more unwise `use 0` will turn it into the impossible-to-prove\n"
"`⊢ 1 + x = x + 0`.\n"
"\n"
"## Details\n"
"\n"
"`use` is a tactic which works on goals of the form `⊢ ∃ c, P(c)` where\n"
"`P(c)` is some proposition which depends on `c`. With a goal of this\n"
"form, `use 0` will turn the goal into `⊢ P(0)`, `use x + y` (assuming\n"
"`x` and `y` are natural numbers in your local context) will turn\n"
"the goal into `P(x + y)` and so on.\n"
msgstr ""
"##Zusammenfassung \n"
"\n"
"`use` arbeitet auf dem Ziel. Wenn dein Ziel aussieht wie `⊢ ∃ c : mynat, 1 + "
"x = x + c`, \n"
"dann wird `use 1` es in `⊢ 1 + x = x + 1` verwandeln und das wesentlich \n"
"weniger weise `use 0` erzeugt das unmöglich zu beweisende `⊢ 1 + x = x + "
"0`. \n"
"\n"
"## Details\n"
"\n"
"`use` ist eine Taktik, die für Ziele der Form `⊢ ∃ c, P(c)` funktioniert, \n"
"bei denen `P(c)` eine Aussage ist, die von `c`abhängt. Mit einem Ziel \n"
"dieser Form wird `use 0` `⊢ P(0)` erzeugen und `use x + y` wird \n"
" `P(x + y)` erzeugen (wenn `x` und `y` natürliche Zahlen sind), usw. \n"

#: Inequality world level 1
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"A new import, giving us a new definition. If `a` and `b` are naturals,\n"
"`a ≤ b` is *defined* to mean\n"
"\n"
"`∃ (c : mynat), b = a + c`\n"
"\n"
"The upside-down E means \"there exists\". So in words, $a\\le b$\n"
"if and only if there exists a natural $c$ such that $b=a+c$. \n"
"\n"
"If you really want to change an `a ≤ b` to `∃ c, b = a + c` then\n"
"you can do so with `rw le_iff_exists_add`:\n"
"\n"
"```\n"
"le_iff_exists_add (a b : mynat) :\n"
"  a ≤ b ↔ ∃ (c : mynat), b = a + c\n"
"```\n"
"\n"
"But because `a ≤ b` is *defined as* `∃ (c : mynat), b = a + c`, you\n"
"do not need to `rw le_iff_exists_add`, you can just pretend when you see `a "
"≤ b`\n"
"that it says `∃ (c : mynat), b = a + c`. You will see a concrete\n"
"example of this below.\n"
"\n"
"A new construction like `∃` means that we need to learn how to manipulate "
"it.\n"
"There are two situations. Firstly we need to know how to solve a goal\n"
"of the form `⊢ ∃ c, ...`, and secondly we need to know how to use a "
"hypothesis\n"
"of the form `∃ c, ...`. \n"
"\n"
"## Level 1: the `use` tactic.\n"
"\n"
"The goal below is to prove $x\\le 1+x$ for any natural number $x$. \n"
"First let's turn the goal explicitly into an existence problem with\n"
"\n"
"`rw le_iff_exists_add,`\n"
"\n"
"and now the goal has become `∃ c : mynat, 1 + x = x + c`. Clearly\n"
"this statement is true, and the proof is that $c=1$ will work (we also\n"
"need the fact that addition is commutative, but we proved that a long\n"
"time ago). How do we make progress with this goal?\n"
"\n"
"The `use` tactic can be used on goals of the form `∃ c, ...`. The idea\n"
"is that we choose which natural number we want to use, and then we use it.\n"
"So try\n"
"\n"
"`use 1,`\n"
"\n"
"and now the goal becomes `⊢ 1 + x = x + 1`. You can solve this by\n"
"`exact add_comm 1 x`, or if you are lazy you can just use the `ring` "
"tactic,\n"
"which is a powerful AI which will solve any equality in algebra which can\n"
"be proved using the standard rules of addition and multiplication. Now\n"
"look at your proof. We're going to remove a line.\n"
"\n"
"## Important\n"
"\n"
"An important time-saver here is to note that because `a ≤ b` is *defined*\n"
"as `∃ c : mynat, b = a + c`, you *do not need to write* `rw "
"le_iff_exists_add`.\n"
"The `use` tactic will work directly on a goal of the form `a ≤ b`. Just\n"
"use the difference `b - a` (note that we have not defined subtraction so\n"
"this does not formally make sense, but you can do the calculation in your "
"head).\n"
"If you have written `rw le_iff_exists_add` below, then just put two minus "
"signs `--`\n"
"before it and comment it out. See that the proof still compiles.\n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"Ein neuer Import gibt uns eine neue Definition. Wenn `a`und `b` natürliche \n"
"Zahlen sind, dann ist `a ≤ b` *definiert* als \n"
"\n"
"`∃ (c : mynat), b = a + c`\n"
"\n"
"Das umgekehrte E bedeutet \"ex existiert\", also bedeutet $a\\le b$ \n"
"in Prinzip: a ist kleiner als b, genau dann wenn es eine natürliche \n"
"Zahl $c$ gibt, mit $b=a+c$.\n"
"\n"
"Wenn du wirklich ein `a ≤ b` verwandeln willst in `∃ c, b = a + c`, \n"
"dann kannst du das mit `rw le_iff_exists_add` erledigen:\n"
"\n"
"```\n"
"le_iff_exists_add (a b : mynat) :\n"
"  a ≤ b ↔ ∃ (c : mynat), b = a + c\n"
"```\n"
"\n"
"Da `a ≤ b` aber als `∃ (c : mynat), b = a + c` *definiert ist* musst du \n"
"`rw le_iff_exists_add` nicht verwenden, sondern einfach annehmen, dass "
"dort \n"
"`∃ (c : mynat), b = a + c` steht. Ein genaues Beispiel steht unten. \n"
"\n"
"Ein neuer Operator wie `∃` bedeutet, dass wir lernen müssen ihn zu "
"manipulieren. \n"
"Es gibt zwei Situationen. Die eine ist: wir müssen wissen, wie wir ein "
"Ziel \n"
"der Form `⊢ ∃ c, ...` erfüllen können, und die zweite ist: wir müssen "
"wissen,\n"
"wie wir eine Hypothese der Form `∃ c, ...` verwenden. \n"
"\n"
"## Level 1: die `use` Taktik.\n"
"\n"
"Das Ziel in diesem Level ist es, $x\\le 1+x$ für eine beliebge natürliche "
"Zahl \n"
"$x$ zu beweisen. \n"
"Lass uns zuerst das Ziel in ein Existenzproblem verändern:\n"
"`rw le_iff_exists_add,`\n"
"\n"
"Jetzt haben wir: `∃ c : mynat, 1 + x = x + c`. Diese Aussage ist "
"offensichtlich \n"
"wahr und der Beweis $c=1$ wird funktionieren (wir brauchen auch die "
"Tatsache, \n"
"dass die Addition kommutativ ist, aber wir haben das schon lange "
"bewiesen). \n"
"Wie geht es jetzt aber weiter? \n"
"\n"
"Die `use` Taktik kann auf Ziele der Form `∃ c, ...` angewendet werden. Die "
"Idee \n"
"ist, dass wir die natürliche Zahl auswählen, die wir verwenden wollen. \n"
"Versuch: \n"
"\n"
"`use 1,`\n"
"\n"
"Jetzt haben wir das Ziel `⊢ 1 + x = x + 1`. Weiter geht es mit \n"
"`exact add_comm 1 x`, oder wenn du faul bist kannst du die `ring` \n"
"Taktik verwenden, die eine mächtige künstliche Intelligenz ist, die \n"
"eine beliebige Gleichheit der Algebra lösen kann, die mit den \n"
"klassischen Regeln der Addition und Multiplikation bewiesen werden kann. \n"
"Sieh dir jetzt den Beweis an. Wir werden eine Zeile entfernen. \n"
"\n"
"## Important\n"
"## Wichtig \n"
"\n"
"Um Zeit zu sparen brauchen wir hier nicht `rw le_iff_exists_add` zu "
"schreiben, \n"
"da `a ≤ b` als `∃ c : mynat, b = a + c` *definiert ist*.\n"
"Die `use`Taktik arbeitet direkt auf einem Ziel der Form `a ≤ b`. \n"
"Verwende die Differenz `b-a` (wir haben die Subtraktion nicht definiert, \n"
"also macht es formal keinen Sinn, aber du kannst die Berechnung auch \n"
"im Kopf durchführen).\n"
"Wenn du `rw le_iff_exists_add` verwendet hast, dann schreibe zwei Minus-\n"
"zeichen davor und kommentiere es aus. Der Beweis kompiliert immer noch! \n"

#: Inequality world level 1
msgid "If $x$ is a natural number, then $x\\le 1+x$.\n"
msgstr "Ist $x$ eine natürliche Zahl, dann gilt $x\\le 1+x$.\n"

#: Inequality world level 2
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"Here's a nice easy one.\n"
"\n"
"## Level 2: le_refl \n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"Hier kommt ein schönes, leichtes Level.\n"
"\n"
"## Level 2: le_refl \n"

#: Inequality world level 2
msgid ""
"The $\\le$ relation is reflexive. In other words, if $x$ is a natural "
"number,\n"
"then $x\\le x$.\n"
msgstr ""
"Die $\\le$ Relation ist reflexiv. Mit anderen Worten: ist $x$ eine "
"natürliche Zahl,\n"
" dann gilt: $x\\le x$. \n"

#: Inequality world level 2
msgid ""
"## Upgrading the `refl` tactic \n"
"\n"
"Now with the following incantation (NB thanks to master wizard Reid Barton\n"
"for correcting my spell)...\n"
msgstr ""
"## Verbesserung der `refl` Taktik \n"
"\n"
"Mit der folgenden Beschwörung (Vielen Dank an den Erzmagier Reid Barton für "
"die \n"
"Verbesserung des Spruchs)... \n"

#: Inequality world level 2
msgid ""
"...we find that the `refl` tactic will close all goals\n"
"of the form `a ≤ a` as well as all goals of the form `a = a`.\n"
msgstr ""
"... erfahren wir, dass die `refl` Taktik alle Ziele der Form \n"
"`a ≤ a` und `a=a` erfüllen kann. \n"

#: Inequality world level 2
msgid ""
"## Pro tip\n"
"\n"
"Did you skip `rw le_iff_exists_add` in your proof of `le_refl` above?\n"
"Instead of `rw add_zero` or `ring` or `exact add_zero x` at the end there,\n"
"what happens if you just try `refl`? The *definition* of `x + 0` is `x`,\n"
"so you don't need to `rw add_zero` either! The proof\n"
"\n"
"```\n"
"use 0,\n"
"refl,\n"
"```\n"
"\n"
"works.\n"
"\n"
"The same remarks are true of\n"
"`add_succ`, `mul_zero`, `mul_succ`, `pow_zero` and `pow_succ`. All of those\n"
"theorems are true *by definition*. The same is *not* true however of "
"`zero_add`; \n"
"the theorem `0 + x = x` was proved by induction on `x`,\n"
"and in particular it is not true by *definition*.\n"
"\n"
"Definitional equality is of great importance\n"
"to computer scientists, but mathematicians are much more fluid with their "
"idea\n"
"of a definition -- a concept can simultaneously have three equivalent "
"definitions\n"
"in a maths talk, as long as they're all logically equivalent. In Lean, a "
"definition\n"
"is *one thing*, and definitional equality is a subtle concept which depends "
"on\n"
"exactly which definition you chose. `add_comm` is certainly not true by "
"definition,\n"
"which means that if we had decided to define `a ≤ b` by `∃ c, b = c + a` "
"(rather\n"
"than `a + c`) all the same theorems would be true, but `refl` would work in\n"
"different places. `refl` closes a goal of the form `X = Y` if `X` and `Y` "
"are\n"
"definitionally equal.\n"
msgstr ""
"## Profi Tipp\n"
"\n"
"Hast du `rw le_iff_exists_add` in deinem beweis für `le_refl` "
"pbersprungen= \n"
"Wenn du statt `rw add_zero` oder ` ring` oder `exact_zero x` am Ende nur \n"
"`refl` verwendest, was passiert dann? Die Definition von `x+0`ist ?x?, \n"
"also brauchst du auch kein `rw add_zero`! Folgender Beweis funktioniert: \n"
"\n"
"```\n"
"use 0,\n"
"refl,\n"
"```\n"
"\n"
"\n"
"Dasselbe gilt auch für `add_succ`, `mul_zero` , `pow_zero` und `pow_succ`. "
"Alle diese \n"
"Sätze sind wahr nach *Definition*. Das gleiche gilt aber *nicht* für "
"`zero_add`; \n"
"Der Satz `0+x=x` wurde durch Induktion über `x` bewiesen, es ist also "
"nicht \n"
"wahr nur nach der *Definition*. \n"
"\n"
"Die Gleichheit nach Definition ist von großer Bedeutung für Informatiker, "
"aber \n"
"Mathematiker sehen dies etwas weniger strikt -- ein Konzept kann "
"gleichzeitig \n"
"drei äquivalente Definitionen in der Mathematik haben, solange diese auch \n"
"logisch äquivalent sind. In Lean ist eine Definition *eine* Sache. Und die \n"
"die Gleichheit nach Definition ist ein subtiles Konzept, das auf der "
"Definition \n"
"basiert, die gewählt wurde. \n"
"`add_comm`z.B. ist sicherlich nicht nach Definition wahr, was bedeutet, \n"
"dass wir auch `a ≤ b` durch `∃ c, b = c + a` hätten definieren können \n"
"(Im Gegensatz zu `a + c`). Dann wären alle Sätze immer noch wahr, aber "
"`refl` würde \n"
" an anderen Stellen verwendet werden. `refl` erfüllt ein Ziel der Form `X = "
"Y` wenn `X` und `Y`gleich sind nach Definition. \n"

#: Inequality world level 3
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 3: `le_succ_of_le`\n"
"\n"
"We have seen how the `use` tactic makes progress on goals of the form `⊢ ∃ "
"c, ...`.\n"
"But what do we do when we have a *hypothesis* of the form `h : ∃ c, ...`?\n"
"The hypothesis claims that there exists some natural number `c` with some\n"
"property. How are we going to get to that natural number `c`? It turns out\n"
"that the `cases` tactic can be used (just like it was used to extract\n"
"information from `∧` and `∨` and `↔` hypotheses). Let me talk you through\n"
"the proof of $a\\le b\\implies a\\le\\operatorname{succ}(b)$.\n"
"\n"
"The goal is an implication so we clearly want to start with \n"
"\n"
"`intro h,`\n"
"\n"
". After this, if you *want*, you can do something like\n"
"\n"
"`rw le_iff_exists_add at h ⊢,`\n"
"\n"
"(get the sideways T with `\\|-` then space). This changes the `≤` into\n"
"its `∃` form in `h` and the goal -- but if you are happy with just\n"
"*imagining* the `∃` whenever you read a `≤` then you don't need to do this "
"line.\n"
"\n"
"Our hypothesis `h` is now `∃ (c : mynat), b = a + c` (or `a ≤ b` if you\n"
"elected not to do the definitional rewriting) so\n"
"\n"
"`cases h with c hc,`\n"
"\n"
"gives you the natural number `c` and the hypothesis `hc : b = a + c`.\n"
"Now use `use` wisely and you're home.\n"
"\n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"## Level 3: `le_succ_of_le`\n"
"\n"
"Wir haben gesehen, dass die `use` Taktik gute Fortschritte macht bei Zielen "
"von \n"
"der Form `⊢ ∃ c, ...`. Aber was, wenn wir eine *Hypothese* dieser Form "
"haben. \n"
"Die Hypothese behauptet dann, dass es eine natürliche Zahl `c` gibt, die "
"eine \n"
"gewisse Eigenschaft erfüllt. Wie bekommen wir diese speziele natürliche Zahl "
"`c`? \n"
"Hier kann auch wieder die `cases` Taktik verwendet werden (genau so, wie sie "
"schon \n"
"beim Extrahieren von Information aus `∧`, `∨` und `↔` Hypothesen verwendet "
"wurde). \n"
" Sehen wir uns den Beweis von $a\\le b\\implies a\\le\\operatorname{succ}"
"(b)$ an. \n"
"\n"
"Das Ziel ist eine Implikation, also starten wir mit\n"
"`intro h,`\n"
"\n"
"Danach kannst du, wenn du *willst*, folgendes machen: \n"
"\n"
"`rw le_iff_exists_add at h ⊢,`\n"
"\n"
"(das \"gekippte T\" bekommst du mit `\\|-` und dann Eingabe). Das wird das \n"
"`≤` in die  `∃` Form bringen, sowohl in der Hypothese als auch im Ziel -- \n"
"aber wenn du damit zufrieden bist, dir das `∃` *vorzustellen*, wenn du ein \n"
"`≤` liest, dann brauchst du diese Zeile nicht. \n"
"\n"
"Unsere Hypothese `h` sieht jetzt so aus: `∃ (c : mynat), b = a + c` (oder `a "
"≤ b`, \n"
"wenn du das Umschreiben nach Definition nicht verwendet hast. \n"
"Weiter geht es mit: \n"
"\n"
"`cases h with c hc,`\n"
"\n"
"Jetzt haben wir die natürliche Zahl `c` und die Hypothese `hc : b = a + c`.\n"
"Verwende jetzt `use` weise und du bist am Ziel. \n"
"\n"

#: Inequality world level 3
msgid ""
"For all naturals $a$, $b$, if $a\\leq b$ then $a\\leq \\operatorname{succ}"
"(b)$. \n"
msgstr ""
"Für alle natürlichen Zahlen $a$ und $b$ gilt: ist $a\\leq b$, dann ist \n"
"$a\\leq \\operatorname{succ}(b)$. \n"

#: Inequality world level 3
msgid ""
"\n"
"\n"
"Did you use `succ c` or `c + 1` or `1 + c`? Those numbers are all\n"
"equal, right? So it doesn't matter which one you use, right?\n"
"\n"
"Here's an interesting question. If you copy the proof below into\n"
"the box above, and then fill in the `???`\n"
"below with `succ c`, will this proof compile? (move your cursor to\n"
"after the final comma to see what Lean thinks). What about if you\n"
"`use 1 + c`? What about if you `use c + 1`? Can you work out\n"
"what is going on? Does it help if I tell you that the *definition*\n"
"of `1` is `succ 0`?\n"
"\n"
"```\n"
"theorem le_succ (a b : mynat) : a ≤ b → a ≤ (succ b) :=\n"
"begin [nat_num_game]\n"
"  intro h,\n"
"  cases h with c hc,\n"
"  rw hc,\n"
"  use ???,\n"
"  refl,\n"
"\n"
"\n"
"end\n"
"```\n"
"\n"
msgstr ""
"\n"
"\n"
"Hast du `succ c` oder `c+1` oder `1+c` verwendet? All diese Zahlen sind \n"
"identisch, oder? Es spielt also keine Rolle, welche man verwendet, oder? \n"
"\n"
"Eine interessante Frage: wenn du den Beweis unten in die Box oben \n"
"kopierst und dann die `???` mit `succ c` ersetzt, wird der Beweis "
"kompilieren? \n"
"(Bewege deine Maus hinter die letzte Zeile, um zu sehen, was Lean denkt). \n"
"Was passiert wenn du `use 1 + c` verwendest? Oder `use c + 1`? Kannst \n"
"du herausfinden, was passiert?. Vielleicht hilft es zu verstehen, dass die \n"
"*Definition* von `1` gerade `succ 0` ist. \n"
"of `1` is `succ 0`?\n"
"\n"
"```\n"
"theorem le_succ (a b : mynat) : a ≤ b → a ≤ (succ b) :=\n"
"begin [nat_num_game]\n"
"  intro h,\n"
"  cases h with c hc,\n"
"  rw hc,\n"
"  use ???,\n"
"  refl,\n"
"\n"
"\n"
"end\n"
"```\n"
"\n"

#: Inequality world level 4
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 4: `zero_le`\n"
"\n"
"Another easy one. \n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"## Level 4: `zero_le`\n"
"\n"
"Noch ein einfaches Level. \n"

#: Inequality world level 4
msgid "For all naturals $a$, $0\\leq a$.\n"
msgstr "Für alle natürlichen Zahlen $a$ gilt $0\\leq a$.\n"

#: Inequality world level 5
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 5: `le_trans`\n"
"\n"
"Another straightforward one. \n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"## Level 5: `le_trans`\n"
"\n"
"Geradeaus durch!. \n"

#: Inequality world level 5
msgid ""
"≤ is transitive. In other words, if $a\\leq b$ and $b\\leq c$ then $a\\leq c"
"$. \n"
msgstr ""
"≤ ist transitiv. Mit anderen Worten, wenn $a\\leq b$ und $b\\leg c$ gilt, \n"
"dann gilt auch $a \\leq c$. \n"

#: Inequality world level 5
msgid ""
"Congratulations -- you just got a collectible. You proved that the\n"
"natural numbers are a preorder.\n"
msgstr ""
"Herzlichen Glückwunsch -- du hast gerade etwas für die Sammlung bekommen. \n"
"Du hast bewiesen, dass die natürlichen Zahlen eine Quasiordnung sind. \n"

#: Inequality world level 6
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 6: `le_antisymm`\n"
"\n"
"In Advanced Addition World you proved\n"
"\n"
"`eq_zero_of_add_right_eq_self (a b : mynat) : a + b = a → b = 0`.\n"
"\n"
"This might be useful in this level.\n"
"\n"
"Another tip: if you want to create a new hypothesis, you can use the `have` "
"tactic.\n"
"For example, if you have a hypothesis `hd : a + (c + d) = a` and you want \n"
"a hypothesis `h : c + d = 0` then you can write\n"
"\n"
"`have h := eq_zero_of_add_right_eq_self hd,`\n"
"\n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"## Level 6: `le_antisymm`\n"
"\n"
"In der fortgeschrittenen Welt der Addition hast du folgendes bewiesen: \n"
"\n"
"`eq_zero_of_add_right_eq_self (a b : mynat) : a + b = a → b = 0`.\n"
"\n"
"Das könnte dir hier nützen! \n"
"\n"
"Noch ein Tipp: wenn du eine neue Hypothese erzeugen willst, kannst du `have` "
"benutzen. \n"
"Zum Beispiel: wenn du die Hypothese `hd : a + (c + d) = a` hast und noch "
"eine der Form \n"
"`h : c + d = 0` haben willst, dann kannst du schreiben: \n"
"\n"
"`have h := eq_zero_of_add_right_eq_self hd,`\n"
"\n"

#: Inequality world level 6
msgid ""
"$\\le$ is antisymmetric. In other words, if $a\\le b$ and $b\\le a$ then $a "
"= b$. \n"
msgstr ""
"$\\le$ ist antisymmetrisch. Mit anderen Worten: gilt $a\\le b$ und $b\\le a"
"$, dann ist$a=b$. \n"

#: Inequality world level 6
msgid ""
"Congratulations -- you just proved that the natural numbers are a partial "
"order!\n"
msgstr ""
"Glückwunsch -- du hast gerade bewiesen, dass die natürlichen Zahlen partiell "
"geordnet sind! \n"

#: Inequality world level 7
msgid ""
"# Inequality world \n"
"\n"
"## Level 7: `le_zero`\n"
"\n"
"We proved `add_right_eq_zero` back in advanced addition world.\n"
"Remember that you can do things like `have h2 := add_right_eq_zero h1`\n"
"if `h1 : a + c = 0`.\n"
msgstr ""
"# Welt der Ungleichheit. \n"
"\n"
"## Level 7: `le_zero`\n"
"\n"
"Wir haben in der fortgeschrittenen Welt der Addition `add_right_eq_zero` "
"bewiesen. \n"
"Denk daran, dass du folgendes tun kannst: `have h2 := add_right_eq_zero h1`, "
"wenn gilt: \n"
"`h1 : a + c = 0`.\n"

#: Inequality world level 7
msgid "For all naturals $a$, if $a\\le 0$ then $a = 0$.\n"
msgstr ""
"Für alle natürlichen zahlen $a$ gilt: ist $a\\le 0$, dann ist $a=0$- \""

#: Inequality world level 8
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 8: `succ_le_succ`\n"
"\n"
"Another straightforward one. \n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"## Level 8: `succ_le_succ`\n"
"\n"
"Wieder eins der Art: mit dem Kopf durch die Tür. \n"

#: Inequality world level 8
msgid ""
"For all naturals $a$ and $b$, if $a\\le b$, then $\\operatorname{succ}(a)\\le"
"\\operatorname{succ}(b)$. \n"
msgstr ""
"Für alle natürlichen zahlen $a$ und $b$ gilt: ist $a\\le b$, dann gilt: \n"
" $\\operatorname{succ}(a)\\le \\operatorname{succ}(b)$. \n"

#: Inequality world level 9
msgid ""
"# Inequality world. \n"
"\n"
"## Level 9: `le_total`\n"
msgstr ""
"# Welt der Ungleichheit. \n"
"\n"
"## Level 9: `le_total`\n"

#: Inequality world level 9
msgid "For all naturals $a$ and $b$, either $a\\le b$ or $b\\le a$. \n"
msgstr ""
"Für alle natürlichen Zahlen $a$ und $b$ gilt entweder $a\\le b$ oder $b\\le a"
"$. \n"

#: Inequality world level 9
msgid "-- Another collectible: the naturals are a linear order."
msgstr "-- Wieder eine Trophäe: die natürlichen Zahlen sind total geordnet. \n"

#: Inequality world level 10
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 10: `le_succ_self`\n"
"\n"
"Can you find the two-line proof?\n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"## Level 10: `le_succ_self`\n"
"\n"
"Kannst du den Zweizeiler für diesen beweis finden? \n"

#: Inequality world level 10
msgid "For all naturals $a$, $a\\le\\operatorname{succ}(a).$\n"
msgstr ""
"Für alle natürlichen Zahlen $a$ gilt: $a\\le\\operatorname{succ}(a).$\n"

#: Inequality world level 11
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 11: `add_le_add_right`\n"
"\n"
"If you're faced with a goal of the form `forall t, ...`, then the next\n"
"line is \"so let $t$ be arbitrary\". The way to do this in Lean is `intro "
"t`.\n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"## Level 11: `add_le_add_right`\n"
"\n"
"Wenn du mit einem Ziel der Form `forall t, ...` konfrontiert wirst, dann "
"sollte \n"
"die nächste Zeile \"lass $t$ beliebig sein\" lauten. Das kannst du mit "
"`intro t` erreichen .\n"

#: Inequality world level 11
msgid ""
"For all naturals $a$ and $b$, $a\\le b$ implies that for all naturals $t$,\n"
"$a+t\\le b+t$.\n"
msgstr ""
"Für alle natürlichen Zahlen $a$ und $b$ gilt: $a\\le b$ impliziert, dass für "
"alle \n"
"natürlichen Zahlen $t$ gilt: $a+t\\le b+t$.\n"

#: Inequality world level 12
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 12: `le_of_succ_le_succ`\n"
"\n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"## Level 12: `le_of_succ_le_succ`\n"
"\n"

#: Inequality world level 12
msgid ""
"For all naturals $a$ and $b$,\n"
"$\\operatorname{succ}(a)\\le\\operatorname{succ}(b)\\implies a\\le b.$\n"
msgstr ""
"Für alle natürlichen Zahlen $a$ und $b$ gilt: $\\operatorname{succ}(a)\\le"
"\\operatorname{succ}(b)\\implies a\\le b.$\n"

#: Inequality world level 13
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 13: `not_succ_le_self`\n"
"\n"
"Turns out that `¬ P` is *by definition* `P → false`, so you can just\n"
"start this one with `intro h` if you like. \n"
"\n"
"## Pro tip:\n"
"\n"
"```\n"
"  conv begin\n"
"    to_lhs,\n"
"    rw hc,\n"
"  end,\n"
"```\n"
"\n"
"is an incantation which rewrites `hc` only on the left hand side of the "
"goal.\n"
"Look carefully at the commas. You don't need to use `conv` to solve this,\n"
"but it's a helpful trick when `rw` is rewriting too much.\n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"## Level 13: `not_succ_le_self`\n"
"\n"
"Wir wissen, dass `¬ P` *nach Definition* gleich `P → false` ist. Du kannst "
"hier \n"
"also einfach mit `intro h` starten, wenn du möchtest. \n"
"\n"
"## Profi Tipp:\n"
"\n"
"```\n"
"  conv begin\n"
"    to_lhs,\n"
"    rw hc,\n"
"  end,\n"
"```\n"
"\n"
"Das ist eine Beschwörung, die `hc` nur auf der linken Seite des Ziels "
"umschreibt. \n"
"Schau dir die Kommata genau an. Du brauchst `conv` nicht, um das zu lösen, "
"aber \n"
"es ist ein nütlicher Trick, wenn `rw` zuviel umschreibt. \n"

#: Inequality world level 13
msgid "For all naturals $a$, $\\operatorname{succ}(a)$ is not at most $a$.\n"
msgstr ""
"Für alle natürlichen Zahlen $a$ ist $\\operatorname{succ}(a)$ nicht "
"höchstens $a$. \n"

#: Inequality world level 14
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 14: `add_le_add_left`\n"
"\n"
"I know these are easy and we've done several already, but this is one\n"
"of the axioms for an ordered commutative monoid! The nature of formalising\n"
"is that we should formalise all \"obvious\" lemmas, and then when we're\n"
"actually using $\\le$ in real life, everything will be there. Note also,\n"
"of course, that all of these lemmas are already formalised in Lean's\n"
"maths library already, for Lean's inbuilt natural numbers. \n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"## Level 14: `add_le_add_left`\n"
"\n"
"Ich weiß, dass dieses Level einfach ist und wir davon schon einige gemacht "
"haben. \n"
"Dieses Level ist aber eines der Axiome für einen geordneten, kommutativen "
"Monoiden! \n"
"Es liegt in der Natur des Formalisierens, dass wir alle \"offensichtlichen"
"\" \n"
"Lemmata formalisieren sollten. Wenn wir dann tatsächlich $\\le$ verwenden, \n"
"sind alle Werkzeuge da. Beachte natürliche auch, dass alle diese Lemmata "
"schon \n"
"in Leans mathlib formalisiert sind, für die eingebauten natürlichen "
"Zahlen. \n"

#: Inequality world level 14
msgid "If $a\\le b$ then for all $t$, $t+a\\le t+b$. \n"
msgstr "Ist $a\\le b$, dann gilt für alle $t$: $t+a\\le t+b$. \n"

#: Inequality world level 15
msgid "--import mynat.lt -- definition of <"
msgstr "-- import mynat.lt -- die Definition von <"

#: Inequality world level 15
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 15: introducing `<`\n"
"\n"
"To get the remaining collectibles in this world, we need to\n"
"give a definition of `<`. By default, the definition of `a < b`\n"
"in Lean, once `≤` is defined, is this:\n"
"\n"
"`a < b := a ≤ b ∧ ¬ (b ≤ a)`\n"
"\n"
". But a much more usable definition would be this:\n"
"\n"
"`a < b := succ(a) ≤ b`\n"
"\n"
". Let's prove that these two definitions are the same\n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"## Level 15: das neue `<`\n"
"\n"
"Um die restlichen Trophäen dieser Welt einsammeln zu können, brauchen wir \n"
"eine Definition für `<`. Standardmäßig ist die Definition von `a < b` in "
"Lean \n"
"(wenn `≤` definiert ist): \n"
"\n"
"`a < b := a ≤ b ∧ ¬ (b ≤ a)`\n"
"\n"
"Noch nützlicher ist aber folgende Definition: \n"
"\n"
"`a < b := succ(a) ≤ b`\n"
"\n"
"Lass uns beweisen, dass diese beiden Definitionen äquivalent sind. \n"

#: Inequality world level 15
msgid ""
"For all naturals $a$ and $b$,\n"
"$$a\\le b\\land\\lnot(b\\le a)\\implies\\operatorname{succ}(a)\\le b.$$\n"
msgstr ""
"Für alle natürlichen Zahlen $a$ und $b$ gilt: \n"
"$$a\\le b\\land\\lnot(b\\le a)\\implies\\operatorname{succ}(a)\\le b.$$\n"

#: Inequality world level 16
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 16: equivalence of two definitions of `<`\n"
"\n"
"Now let's go the other way. \n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"## Level 16: Äquivalenz der zwei Definitionen von `<`\n"
"\n"
"Jetzt die andere Richtung. \n"

#: Inequality world level 16
msgid ""
"For all naturals $a$ and $b$,\n"
"$$\n"
"\\operatorname{succ}(a)\\le b\n"
"\\implies\n"
"a\\le b\\land\\lnot(b\\le a).$$\n"
msgstr ""
"Für alle natürlichen Zahlen $a$ und $b$ gilt: \n"
"$$\n"
"\\operatorname{succ}(a)\\le b\n"
"\\implies\n"
"a\\le b\\land\\lnot(b\\le a).$$\n"

#: Inequality world level 16
msgid "Now for the payoff.\n"
msgstr "Und jetzt holen wir unseren Preis ab. \n"

#: Inequality world level 17
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 17: definition of `<`\n"
"\n"
"OK so we are going to *define* `a < b` by `a ≤ b ∧ ¬ (b ≤ a)`,\n"
"and given `lt_aux_one a b` and `lt_aux_two a b` it should now just\n"
"be a few lines to prove `a < b ↔ succ(a) ≤ b`. \n"
"\n"
msgstr ""
"\n"
"# Welt der Ungleichheit. \n"
"\n"
"## Level 17: Die Definition von `<`\n"
"\n"
"Endlichen werden wir `a < b` durch `a ≤ b ∧ ¬ (b ≤ a)` *definieren* . \n"
"Da wir auch schon `lt_aux_one a b` und `lt_aux_two a b` haben, sollte \n"
"es nur ein paar Zeilen Arbeit erfordern, dass `a < b ↔ succ(a) ≤ b` gilt. \n"
"\n"

#: Inequality world level 17
msgid "-- incantation so that we can use `<` notation: "
msgstr "-- eine Beschwörung, sodass wir die `<` Notation benutzen können:"

#: Inequality world level 17
msgid ""
"For all naturals $a$ and $b$,\n"
"$$a<b\\iff\\operatorname{succ}(a)\\le b.$$\n"
msgstr ""
"Für alle natürlichen Zahlen $a$ und $b$ gilt: \n"
"$$a<b\\iff\\operatorname{succ}(a)\\le b.$$\n"

#: Inequality world level 17
msgid ""
"For now -- that's it. In the next version of the natural number game we will "
"go on and make\n"
"the natural numbers into an `ordered_cancel_comm_monoid`, which is the most\n"
"exotic of all the structures defined on the natural numbers in Lean 3.4.2.\n"
"\n"
"Interested in playing levels involving other kinds of mathematics?\n"
"Look <a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/"
"blob/master/WHATS_NEXT.md\"\n"
"  target=\"blank\">here</a> for more ideas about what to do next.\n"
"\n"
"Interested in learning more? Join us on the\n"
"<a href=\"https://leanprover.zulipchat.com/\" target=\"blank\">Zulip Lean "
"chat</a>\n"
"and ask questions in the `#new members` stream. Real names preferred. Be "
"nice.\n"
msgstr ""
"Und jetzt -- wars das. In der nächsten Version des Spiels werden wir "
"weitergehen und \n"
"die natürlichen Zahlen in einen `ordered_cancel_comm_monoid` verwandeln, was "
"der \n"
"exotischsten aller Strukturen entspricht, die auf den natürlichen Zahlen in "
"Lean 3.4.2 \n"
"definiert sind. \n"
"Wenn du daran interessiert bist andere Level zu speielen, die eine andere "
"Art von \n"
"Mathematik behandeln, dann sieh doch <a href=\"https://github.com/"
"ImperialCollegeLondon/natural_number_game/blob/master/WHATS_NEXT.md\"\n"
"  target=\"blank\">hier</a> nach, wenn du Ideen brauchst wo es hingehen "
"soll. \n"
"\n"
"Willst du mehr lernen? Dann tritt unserem <a href=\"https://leanprover."
"zulipchat.com/\" target=\"blank\">Zulip Lean chat</a> bei.\n"
"Du kannst Fragem im `new members`stream stellen. Reale Namen werden "
"bevorzugt. Sei nett! \n"

#~ msgid "-- World name : Tutorial world"
#~ msgstr "-- Weltname: Tutorial Welt"

#~ msgid "-- World name : Addition world"
#~ msgstr "-- Name: Welt der Addition"

#~ msgid "-- World name : Multiplication world"
#~ msgstr "-- Name: Welt der Multiplikation"

#~ msgid "-- World name : Power world"
#~ msgstr "-- Name : Welt der Potenzen"

#~ msgid "-- World name : Function world"
#~ msgstr "-- Name : Welt der Funktionen"

#~ msgid "-- World name : Proposition world"
#~ msgstr "-- Weltname: Welt der Aussagen"

#~ msgid "-- World name : Advanced Proposition world"
#~ msgstr "-- Name der Welt: Fortgeschrittene Welt der Aussagen"

#~ msgid "-- World name : Inequality world"
#~ msgstr "-- Weltname: Welt der Ungleichheit"
