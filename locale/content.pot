#
msgid ""
msgstr ""
"Project-Id-Version: 1.3.3\n"
"POT-Creation-Date: 2023-06-05 15:26:40.661267\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"

#: game_config
msgid "Natural number game"
msgstr ""

#: intro
msgid ""
"# The Linear Algebra Game, version 1.0.0\n"
"\n"
"## By Anoushka Sinha, Annapurna Bhattacharya, Kurt Ma, Ricardo Prado Cunha, "
"Stavan Jain, Yannan Bai\n"
"\n"
"\n"
"\n"
"# What is this game?\n"
"\n"
"Welcome to the linear algebra game! TODO\n"
"\n"
"\n"
"\n"
"# Thanks\n"
"TODO\n"
msgstr ""

#: world_config
msgid "Tutorial world"
msgstr ""

#: Tutorial world level 1
msgid "import mynat.definition -- imports the natural numbers {0,1,2,3,4,...}."
msgstr ""

#: Tutorial world level 1
msgid ""
"import mynat.add -- imports definition of addition on the natural numbers."
msgstr ""

#: Tutorial world level 1
msgid ""
"import mynat.mul -- imports definition of multiplication on the natural "
"numbers."
msgstr ""

#: Tutorial world level 1
msgid ""
"# Tutorial World\n"
"\n"
"## Level 1: the `refl` tactic.\n"
"\n"
"Let us start by learning some tactics! Let's start with the `refl` tactic. "
"`refl` stands for \"reflexivity\", which is a fancy\n"
"way of saying that it will prove any goal of the form `A = A`. It doesn't "
"matter how\n"
"complicated `A` is, all that matters is that the left hand side is *exactly "
"equal* to the\n"
"right hand side (a computer scientist would say \"definitionally equal\"). I "
"really mean\n"
"\"press the same buttons on your computer in the same order\" equal.\n"
"For example, `x * y + z = x * y + z` can be proved by `refl`, but `x + y = y "
"+ x` cannot.\n"
"\n"
"Each level in this game involves proving a theorem or a lemma (a lemma is "
"just a baby theorem).\n"
"The goal of the theorem will be a mathematical statement with a `⊢` just "
"before it.\n"
"We will use tactics to manipulate and ultimately close (i.e. prove) these "
"goals.\n"
"\n"
"Let's see `refl` in action! At the bottom of the text in this box, there's a "
"lemma,\n"
"which says that if $x$, $y$ and $z$ are natural numbers then $xy + z = xy + z"
"$.\n"
"Locate this lemma (if you can't see the lemma and these instructions at the "
"same time, make this box wider\n"
"by dragging the sides). Let's supply the proof. Click on the word `sorry` "
"and then delete it.\n"
"When the system finishes being busy, you'll be able to see your goal -- the "
"objective\n"
"of this level -- in the box on the top right. [NB if your system never "
"finishes being busy, then\n"
"your computer is not running the javascript Lean which powers everything "
"behind the scenes. \n"
"Try Chrome? Try not using private browsing?] \n"
"\n"
"Remember that the goal is\n"
"the thing with the weird `⊢` thing just before it. The goal in this case is "
"`x * y + z = x * y + z`,\n"
"where `x`, `y` and `z` are some of your very own natural numbers.\n"
"That's a pretty easy goal to prove -- you can just prove it with the `refl` "
"tactic.\n"
"Where it used to say `sorry`, write\n"
"\n"
"`refl,`\n"
"\n"
"**and don't forget the comma**. Then hit enter to go onto the next line.\n"
"If all is well, Lean should tell you \"Proof complete!\" in the top right "
"box, and there\n"
"should be no errors in the bottom right box. You just did the first\n"
"level of the tutorial! And you also learnt how to avoid by *far* the most\n"
"common mistake that beginner users make -- **every line must end with a "
"comma**.\n"
"If things go weird and you don't understand why the top right box is empty,\n"
"check for missing commas. Also check if you've spelt `refl` correctly: it's "
"REFL\n"
"for \"reflexivity\"!\n"
"\n"
"For each level, the idea is to get Lean into this state: with the top right\n"
"box saying \"Proof complete!\" and the bottom right box empty (i.e. with no "
"errors in).\n"
"\n"
"If you want to be reminded about the `refl` tactic, you can click on the "
"\"Tactics\" drop\n"
"down menu on the left. Resize the window if it's too small! \n"
"\n"
"Now click on \"next level\" in the top right of your browser to go onto the "
"second level of\n"
"tutorial world, where we'll learn about the `rw` tactic.\n"
msgstr ""

#: Tutorial world level 1
msgid "For all natural numbers $x$, $y$ and $z$, we have $xy + z = xy + z$.\n"
msgstr ""

#: Tutorial world level 1
msgid ""
"\n"
"## Summary\n"
"\n"
"`refl` proves goals of the form `X = X`.\n"
"\n"
"## Details\n"
"\n"
"The `refl` tactic will close any goal of the form `A = B`\n"
"where `A` and `B` are *exactly the same thing*.\n"
"\n"
"### Example:\n"
"If it looks like this in the top right hand box:\n"
"```\n"
"a b c d : mynat\n"
"⊢ (a + b) * (c + d) = (a + b) * (c + d)\n"
"```\n"
"\n"
"then\n"
"\n"
"`refl,`\n"
"\n"
"will close the goal and solve the level. Don't forget the comma.\n"
"\n"
msgstr ""

#: Tutorial world level 2
msgid ""
"# Tutorial world\n"
"\n"
"## level 2: The rewrite (`rw`) tactic.\n"
"\n"
"The rewrite tactic is the way to \"substitute in\" the value\n"
"of a variable. In general, if you have a hypothesis of the form `A = B`, and "
"your\n"
"goal mentions the left hand side `A` somewhere, then\n"
"the `rewrite` tactic will replace the `A` in your goal with a `B`.\n"
"Below is a theorem which cannot be\n"
"proved using `refl` -- you need a rewrite first.\n"
"\n"
"Delete the sorry and take a look in the top right box at what we have.\n"
"The variables $x$ and $y$ are natural numbers, and we have\n"
"a proof `h` that $y = x + 7$. Our goal\n"
"is to prove that $2y=2(x+7)$. This goal is obvious -- we just\n"
"substitute in $y = x+7$ and we're done. In Lean, we do\n"
"this substitution using the `rw` tactic. So start your proof with \n"
"\n"
"`rw h,`\n"
"\n"
"and then hit enter. **Don't forget the comma.**\n"
"Did you see what happened to the goal? The goal doesn't close,\n"
"but it *changes* from `⊢ 2 * y = 2 * (x + 7)` to `⊢ 2 * (x + 7) = 2 * (x + "
"7)`.\n"
"We can just close this goal with\n"
"\n"
"`refl,`\n"
"\n"
"by writing it on the line after `rw h,`. Don't forget the comma, hit\n"
"enter, and enjoy seeing the \"Proof complete!\" message in the\n"
"top right window. The other reason you'll know you're\n"
"done is that the bottom right window (the error window)\n"
"becomes empty. When you've finished reading the comments below\n"
"the proof, click \"Next Level\" in the top right to proceed to the next\n"
"level in this world.\n"
"\n"
msgstr ""

#: Tutorial world level 2
msgid ""
"If $x$ and $y$ are natural numbers, \n"
"and $y=x+7$, then $2y=2(x+7)$. \n"
msgstr ""

#: Tutorial world level 2
msgid ""
"\n"
"## Summary\n"
"\n"
"If `h` is a proof of `X = Y`, then `rw h,` will change\n"
"all `X`s in the goal to `Y`s. Variants: `rw ← h` (changes\n"
"`Y` to `X`) and\n"
"`rw h at h2` (changes `X` to `Y` in hypothesis `h2` instead\n"
"of the goal).\n"
"\n"
"## Details\n"
"\n"
"The `rw` tactic is a way to do \"substituting in\". There\n"
"are two distinct situations where use this tactics.\n"
"\n"
"1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\n"
"in your local context (the box in the top right)\n"
"and if your goal contains one or more `A`s, then `rw h`\n"
"will change them all to `B`'s. \n"
"\n"
"2) The `rw` tactic will also work with proofs of theorems\n"
"which are equalities (look for them in the drop down\n"
"menu on the left, within Theorem Statements).\n"
"For example, in world 1 level 4\n"
"we learn about `add_zero x : x + 0 = x`, and `rw add_zero`\n"
"will change `x + 0` into `x` in your goal (or fail with\n"
"an error if Lean cannot find `x + 0` in the goal).\n"
"\n"
"Important note: if `h` is not a proof of the form `A = B`\n"
"or `A ↔ B` (for example if `h` is a function, an implication,\n"
"or perhaps even a proposition itself rather than its proof),\n"
"then `rw` is not the tactic you want to use. For example,\n"
"`rw (P = Q)` is never correct: `P = Q` is the true-false\n"
"statement itself, not the proof.\n"
"If `h : P = Q` is its proof, then `rw h` will work.\n"
"\n"
"Pro tip 1: If `h : A = B` and you want to change\n"
"`B`s to `A`s instead, try `rw ←h` (get the arrow with `\\l` and\n"
"note that this is a small letter L, not a number 1).\n"
"\n"
"### Example:\n"
"If it looks like this in the top right hand box:\n"
"```\n"
"x y : mynat\n"
"h : x = y + y\n"
"⊢ succ (x + 0) = succ (y + y)\n"
"```\n"
"\n"
"then\n"
"\n"
"`rw add_zero,`\n"
"\n"
"will change the goal into `⊢ succ x = succ (y + y)`, and then\n"
"\n"
"`rw h,`\n"
"\n"
"will change the goal into `⊢ succ (y + y) = succ (y + y)`, which\n"
"can be solved with `refl,`.\n"
"\n"
"### Example: \n"
"You can use `rw` to change a hypothesis as well. \n"
"For example, if your local context looks like this:\n"
"```\n"
"x y : mynat\n"
"h1 : x = y + 3\n"
"h2 : 2 * y = x\n"
"⊢ y = 3\n"
"```\n"
"then `rw h1 at h2` will turn `h2` into `h2 : 2 * y = y + 3`.\n"
msgstr ""

#: Tutorial world level 2
msgid ""
"\n"
"## Exploring your proof.\n"
"\n"
"Click on `refl,` and then use the arrow keys to move\n"
"your cursor around the proof. Go up and down and note that\n"
"the goal changes -- indeed you can inspect Lean's \"state\" at each\n"
"line of the proof (the hypotheses, and the goal).\n"
"Try to figure out the exact place where the goal changes.\n"
"The comma tells Lean \"I've finished writing this tactic now,\n"
"please process it.\" Lean ignores newlines, but pays great\n"
"attention to commas.\n"
"\n"
"## The tactic index\n"
"\n"
"The documentation for `rw` just appeared in the list of tactics\n"
"in the box on the left. Play around with the menus on the left\n"
"and see what is there currently. More information will appear as you "
"progress.\n"
"\n"
"## Bewildered?\n"
"\n"
"Doesn't work? Weird error that won't go away? You can check out\n"
"the \n"
"<a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/"
"master/SOLUTIONS.md\"\n"
"  target=\"blank\">solutions</a> (github.com, opens in new window).\n"
"  Solutions to every level are here.\n"
msgstr ""

#: Tutorial world level 3
msgid ""
"We just restarted Lean behind the scenes,\n"
"so let's re-import the natural numbers, but this time without\n"
"addition and multiplication.\n"
msgstr ""

#: Tutorial world level 3
msgid ""
"import mynat.definition -- import Peano's definition of the natural numbers "
"{0,1,2,3,4,...}"
msgstr ""

#: Tutorial world level 3
msgid ""
"\n"
"# Tutorial world\n"
"\n"
"## Level 3: Peano's axioms.\n"
"\n"
"The import above gives us the type `mynat` of natural numbers. But it\n"
"also gives us some other things, which we'll take a look at now:\n"
"\n"
"  * a term `0 : mynat`, interpreted as the number zero.\n"
"  * a function `succ : mynat → mynat`, with `succ n` interpreted as \"the "
"number after $n$\".\n"
"  * The principle of mathematical induction.\n"
"\n"
"These axioms are essentially the axioms isolated by Peano which uniquely "
"characterise\n"
"the natural numbers (we also need recursion, but we can ignore it for now).\n"
"The first axiom says that $0$ is a natural number. The second says that "
"there\n"
"is a `succ` function which eats a number and spits out the number after it,\n"
"so $\\operatorname{succ}(0)=1$, $\\operatorname{succ}(1)=2$ and so on.\n"
"\n"
"Peano's last axiom is the principle of mathematical induction. This is a "
"deeper\n"
"fact. It says that if we have infinitely many true/false statements $P(0)$, "
"$P(1)$,\n"
"$P(2)$ and so on, and if $P(0)$ is true, and if for every natural number $d"
"$\n"
"we know that $P(d)$ implies $P(\\operatorname{succ}(d))$, then $P(n)$ must "
"be true for every\n"
"natural number $n$. It's like saying that if you have a long line of "
"dominoes, and if\n"
"you knock the first one down, and if you know that if a domino falls down "
"then the one\n"
"after it will fall down too, then you can deduce that all the dominos will "
"fall down.\n"
"One can also think of it as saying that every natural number\n"
"can be built by starting at `0` and then applying `succ` a finite number of "
"times.\n"
"\n"
"Peano's insights were firstly that these axioms completely characterise\n"
"the natural numbers, and secondly that these axioms alone can be used to "
"build\n"
"a whole bunch of other structure on the natural numbers, for example\n"
"addition, multiplication and so on.\n"
"\n"
"This game is all about seeing how far these axioms of Peano can take us.\n"
"\n"
"Let's practice our use of the `rw` tactic in the following example.\n"
"Our hypothesis `h` is a proof that `succ(a) = b` and we want to prove that\n"
"`succ(succ(a))=succ(b)`. In words, we're going to prove that if\n"
"`b` is the number after `a` then `succ(b)` is the number after `succ(a)`. \n"
"Now here's a tricky question. If our goal is `⊢ succ (succ a) = succ b`,\n"
"and our hypothesis is `h : succ a = b`, then what will the goal change\n"
"to when we type\n"
"\n"
"`rw h,`\n"
"\n"
"and hit enter whilst not forgetting the comma? Remember that `rw h` will\n"
"look for the *left* hand side of `h` in the goal, and will replace it with\n"
"the *right* hand side. Try and figure out how the goal will change, and\n"
"then try it.\n"
"\n"
"The answer: Lean changed `succ a` into `b`, so the goal became `succ b = "
"succ b`.\n"
"That goal is of the form `X = X`, so you can prove this new goal with\n"
"\n"
"`refl,`\n"
"\n"
"on the line after `rw h,`. Don't forget the commas!\n"
"\n"
"**Important note** : the tactic `rw` expects\n"
"a proof afterwards (e.g. `rw h1`). But `refl` is just `refl`.\n"
"Note also that the system sometimes drops brackets when they're not\n"
"necessary, and `succ b` just means `succ(b)`. \n"
"\n"
"You may be wondering whether we could have just substituted in the "
"definition of `b`\n"
"and proved the goal that way. To do that, we would want to replace the right "
"hand\n"
"side of `h` with the left hand side. You do this in Lean by writing `rw ← "
"h`. You get the\n"
"left-arrow by typing `\\l` and then a space; note that this is a small "
"letter L,\n"
"not a number 1. You can just edit your proof and try it. \n"
"\n"
"You may also be wondering why we keep writing `succ(b)` instead of `b+1`. "
"This\n"
"is because we haven't defined addition yet! On the next level, the final "
"level\n"
"of Tutorial World, we will introduce addition, and then\n"
"we'll be ready to enter Addition World.\n"
msgstr ""

#: Tutorial world level 3
msgid ""
"If $\\operatorname{succ}(a) = b$, then\n"
"$$\\operatorname{succ}(\\operatorname{succ}(a)) = \\operatorname{succ}(b).$"
"$\n"
msgstr ""

#: Tutorial world level 4
msgid "import mynat.add -- definition of addition"
msgstr ""

#: Tutorial world level 4
msgid ""
"# Tutorial world\n"
"\n"
"## Level 4: addition\n"
"\n"
"We have a new import -- the definition of addition.\n"
"\n"
"Peano defined addition `a + b` by induction on `b`, or,\n"
"more precisely, by *recursion* on `b`. He first explained how to add 0 to a "
"number:\n"
"this is the base case.\n"
"\n"
"* `add_zero (a : mynat) : a + 0 = a`\n"
"\n"
"We will call this theorem `add_zero`. More precisely, `add_zero` is the "
"name\n"
"of the *proof* of the theorem. **Note the name of this proof**.\n"
"Mathematicians sometimes call it \"Lemma 2.1\" or \"Hypothesis P6\" or "
"something. But\n"
"computer scientists call it `add_zero` because it tells you\n"
"what the answer to \"$x$ add zero\" is. It's a *much* better name than "
"\"Lemma 2.1\".\n"
"Even better, we can use the rewrite tactic with `add_zero`.\n"
"If you ever see `x + 0` in your goal, `rw add_zero` should simplify it to "
"`x`.\n"
"This is because `add_zero` is a proof that `x + 0 = x` (more precisely,\n"
"`add_zero x` is a proof that `x + 0 = x` but Lean can figure out the `x` "
"from the context).\n"
"\n"
"Now here's the inductive step. If you know how to add `d` to `a`, then\n"
"Peano tells you how to add `succ(d)` to `a`. It looks like this:\n"
"\n"
"* `add_succ (a d : mynat) : a + succ(d) = succ (a + d)`\n"
"\n"
"What's going on here is that we assume `a + d` is already\n"
"defined, and we define `a + succ(d)` to be the number after it.\n"
"**Note the name of this proof too** -- `add_succ` tells you\n"
"how to add a successor to something. If you ever see `... + succ ...`\n"
"in your goal, you should be able to use `rw add_succ,` to make\n"
"progress. Here is a simple example where we shall see both. Let's prove\n"
"that $x$ add the number after $0$ is the number after $x$.\n"
"\n"
"Delete `sorry` (don't forget you can widen this box if you can't see the "
"sorry).\n"
"Observe that the goal mentions `... + succ ...`. So type\n"
"\n"
"`rw add_succ,`\n"
"\n"
"and hit enter; see the goal change. **Don't forget the commma**.\n"
"Do you see that the goal now mentions ` ... + 0 ...`? So type\n"
"\n"
"`rw add_zero,`\n"
"\n"
"and then observe that you can close the goal with\n"
"\n"
"`refl,`\n"
"\n"
"and you're done. You have finished tutorial world! There are important "
"things\n"
"written below the lemma, including what to do next.\n"
"\n"
msgstr ""

#: Tutorial world level 4
msgid ""
"For all natural numbers $a$, we have\n"
"$$a + \\operatorname{succ}(0) = \\operatorname{succ}(a).$$\n"
msgstr ""

#: Tutorial world level 4
msgid ""
"## Examining proofs.\n"
"\n"
"You might want to review this proof now; at\n"
"three lines long it is our current record. Click on a line in the proof\n"
"and use the L/R arrow keys to put your cursor as far left as it will go.\n"
"Then use the U/D arrow keys to move your cursor\n"
"up and down from line to line, and you can see what\n"
"Lean is thinking on each line of the proof.\n"
"\n"
"## No problems?\n"
"\n"
"When you're happy, let's move onto Addition World, and\n"
"learn about proof by induction. Go back to the main menu and select addition "
"world.\n"
"\n"
"## Problems?\n"
"\n"
"Question: why has the top right hand box gone blank?\n"
"\n"
"Answer: Maybe you tried a tactic which didn't work. Or maybe you're\n"
"in the middle of typing a tactic. Try deleting up to the last\n"
"comma, *or adding a comma at the end of your code*. Look at the\n"
"error message. What line is the first error on? Perhaps\n"
"Lean thinks you're in the middle of writing a tactic command that you\n"
"think you finished. If Lean is still attempting to process a tactic\n"
"command it won't display anything. You can get it to stop processing by\n"
"adding a comma. \n"
"\n"
"If the worst comes to the worst, just delete what you wrote. Most people\n"
"with problems have written random stuff in the proof box. The only thing\n"
"you're supposed to be writing is lines like\n"
"\n"
"`rw add_zero,`\n"
"`rw h,`\n"
"`refl,`\n"
"\n"
"One line of code with a comma at the end. Nothing else at all goes in the "
"box.\n"
"\n"
"If you cannot see what you have done wrong, you can always\n"
"<a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/"
"master/SOLUTIONS.md\"\n"
"  target=\"blank\">take a look at the solutions</a> (github.com, opens in "
"new window).\n"
msgstr ""

#: world_config
msgid "Addition world"
msgstr ""

#: Addition world level 1
msgid "import mynat.definition -- Imports the natural numbers."
msgstr ""

#: Addition world level 1
msgid "import mynat.add -- imports addition."
msgstr ""

#: Addition world level 1
msgid ""
"\n"
"## Summary\n"
"\n"
"if `n : mynat` is in our assumptions, then `induction n with d hd`\n"
"attempts to prove the goal by induction on `n`, with the inductive\n"
"assumption in the `succ` case being `hd`.\n"
"\n"
"## Details\n"
"\n"
"If you have a natural number `n : mynat` in your context\n"
"(above the `⊢`) then `induction n with d hd` turns your\n"
"goal into two goals, a base case with `n = 0` and\n"
"an inductive step where `hd` is a proof of the `n = d`\n"
"case and your goal is the `n = succ(d)` case.\n"
"\n"
"### Example:\n"
"If this is our local context:\n"
"```\n"
"n : mynat\n"
"⊢ 2 * n = n + n\n"
"```\n"
"\n"
"then\n"
"\n"
"`induction n with d hd`\n"
"\n"
"will give us two goals:\n"
"\n"
"```\n"
"⊢ 2 * 0 = 0 + 0\n"
"```\n"
"\n"
"and\n"
"```\n"
"d : mynat,\n"
"hd : 2 * d = d + d\n"
"⊢ 2 * succ d = succ d + succ d\n"
"```\n"
"\n"
msgstr ""

#: Addition world level 1
msgid ""
"# Addition World. \n"
"\n"
"Welcome to Addition World. If you've done all four levels in tutorial world\n"
"and know about `rw` and `refl`, then you're in the right place. Here's\n"
"a reminder of the things you're now equipped with which we'll need in this "
"world.\n"
"\n"
"## Data:\n"
"\n"
"  * a type called `mynat`\n"
"  * a term `0 : mynat`, interpreted as the number zero.\n"
"  * a function `succ : mynat → mynat`, with `succ n` interpreted as \"the "
"number after `n`\".\n"
"  * Usual numerical notation 0,1,2 etc (although 2 onwards will be of no use "
"to us until much later ;-) ).\n"
"  * Addition (with notation `a + b`).\n"
"\n"
"## Theorems:\n"
"\n"
"  * `add_zero (a : mynat) : a + 0 = a`. Use with `rw add_zero`.\n"
"  * `add_succ (a b : mynat) : a + succ(b) = succ(a + b)`. Use with `rw "
"add_succ`.\n"
"  * The principle of mathematical induction. Use with `induction` (see "
"below)\n"
"  \n"
"\n"
"## Tactics:\n"
"\n"
"  * `refl` :  proves goals of the form `X = X`\n"
"  * `rw h` : if h is a proof of `A = B`, changes all A's in the goal to "
"B's.\n"
"  * `induction n with d hd` : we're going to learn this right now.\n"
"\n"
"# Important thing: \n"
"\n"
"This is a *really* good time to check you understand about the box on the "
"left with the drop down\n"
"menus. All the theorems and all the tactics above are documented there. You "
"can find\n"
"all you need to know about what theorems you have collected in Theorem "
"statements -> Addition world.\n"
"Have a click around and check that you can find statements of the theorems "
"above, and explanations of\n"
"the tactics above. As we go through the game, these lists will grow. The box "
"on the left\n"
"will prove invaluable as the number of theorems we prove gets bigger. On the "
"other hand,\n"
"we only need to learn one more tactic to really start going places, so let's "
"learn about\n"
"that tactic right now.\n"
"\n"
"## Level 1: the `induction` tactic.\n"
"\n"
"OK so let's see induction in action. We're going to prove\n"
"\n"
"  `zero_add (n : mynat) : 0 + n = n`. \n"
"\n"
"That is: for all natural numbers $n$, $0+n=n$. Wait $-$ what is going on "
"here?\n"
"Didn't we already prove that adding zero to $n$ gave us $n$?\n"
"No we didn't! We proved $n + 0 = n$, and that proof was called `add_zero`. "
"We're now\n"
"trying to establish `zero_add`, the proof that $0 + n = n$. But aren't these "
"two theorems\n"
"the same? No they're not! It is *true* that `x + y = y + x`, but we haven't\n"
"*proved* it yet, and in fact we will need both `add_zero` and `zero_add` in "
"order\n"
"to prove this. In fact `x + y = y + x` is the boss level for addition "
"world,\n"
"and `induction` is the only other tactic you'll need to beat it.\n"
"\n"
"Now `add_zero` is one of Peano's axioms, so we don't need to prove it, we "
"already have it\n"
"(indeed, if you've opened the Addition World theorem statements on the left, "
"you can even see it).\n"
"To prove `0 + n = n` we need to use induction on $n$. While we're here,\n"
"  note that `zero_add` is about zero add something, and `add_zero` is about "
"something add zero.\n"
"  The names of the proofs tell you what the theorems are. Anyway, let's "
"prove `0 + n = n`.\n"
"\n"
"  Delete `sorry` and replace it with `induction n with d hd,`\n"
"and **don't forget the comma**. Hit enter, wait for Lean to finish "
"thinking,\n"
"and let's see what we have.\n"
"\n"
"When Lean has finished thinking, we see that we now have *two goals*! The\n"
"induction tactic has generated for us a base case with `n = 0` (the goal at "
"the top)\n"
"and an inductive step (the goal underneath). The golden rule: **Tactics "
"operate on the first goal** --\n"
"the goal at the top. So let's just worry about that top goal now, the base "
"case `⊢ 0 + 0 = 0`.\n"
"\n"
"Remember that `add_zero` (the proof we have already) is the proof of `x + 0 "
"= x`\n"
"(for any $x$) so we can try\n"
"\n"
"`rw add_zero,`\n"
"\n"
". What do you think the goal will\n"
"change to? Remember to just keep\n"
"focussing on the top goal, ignore the other one for now, it's not changing\n"
"and we're not working on it. You should be able to solve the top goal "
"yourself\n"
"now with `refl`.\n"
"\n"
"When you solved this base case goal, we are now be back down\n"
"to one goal -- the inductive step. Take a look at the\n"
"text below the lemma to see an explanation of this goal.\n"
msgstr ""

#: Addition world level 1
msgid ""
"For all natural numbers $n$, we have\n"
"$$0 + n = n.$$\n"
msgstr ""

#: Addition world level 1
msgid ""
"We're in the successor case, and your top right box should look\n"
"something like this:\n"
"\n"
"```\n"
"case mynat.succ\n"
"d : mynat,\n"
"hd : 0 + d = d\n"
"⊢ 0 + succ d = succ d\n"
"```\n"
"\n"
"*Important:* make sure that you only have one goal at this point. You\n"
"should have proved `0 + 0 = 0` by now. Tactics only operate on the top "
"goal.\n"
"\n"
"The first line just reminds us we're doing the inductive step.\n"
"We have a fixed natural number `d`, and the inductive hypothesis `hd : 0 + d "
"= d`\n"
"saying that we have a proof of `0 + d = d`.  \n"
"Our goal is to prove `0 + succ d = succ d`. In words, we're showing that\n"
"if the lemma is true for `d`, then it's also true for the number after `d`.\n"
"That's the inductive step. Once we've proved this inductive step, we will "
"have proved\n"
"`zero_add` by the principle of mathematical induction.\n"
"\n"
"To prove our goal, we need to use `add_succ`. We know that `add_succ 0 d`\n"
"is the result that `0 + succ d = succ (0 + d)`, so the first thing\n"
"we need to do is to replace the left hand side `0 + succ d` of our\n"
"goal with the right hand side. We do this with the `rw` command. You can "
"write\n"
"\n"
"`rw add_succ,`\n"
"\n"
"(or even `rw add_succ 0 d,` if you want to give Lean all the inputs instead "
"of making it\n"
"figure them out itself). Don't forget the comma though. Hit enter. The goal "
"should change to\n"
"\n"
"`⊢ succ (0 + d) = succ d`\n"
"\n"
"Now remember our inductive hypothesis `hd : 0 + d = d`. We need\n"
"to rewrite this too! Type \n"
"\n"
"`rw hd,`\n"
"\n"
"(don't forget the comma). The goal will now change to\n"
"\n"
"`⊢ succ d = succ d`\n"
"\n"
"This goal can be solved with the `refl` tactic. After you apply it,\n"
"Lean will inform you that there are no goals left. You are done!\n"
"\n"
"## Now venture off on your own.\n"
"\n"
"Those three tactics -- \n"
"\n"
"* `induction n with d hd,` \n"
"* `rw h,`\n"
"* `refl,`\n"
"\n"
"will get you quite a long way through this game. Using only these tactics\n"
"you can beat Addition World level 4 (the boss level of Addition World),\n"
"all of Multiplication World including the boss level `a * b = b * a`,\n"
"and even all of Power World including the fiendish final boss. This route "
"will\n"
"give you a good grounding in these three basic tactics; after that, if you\n"
"are still interested, there are other worlds to master, where you can learn\n"
"more tactics.\n"
"\n"
"But we're getting ahead of ourselves, you still have to beat the rest of "
"Addition World. \n"
"We're going to stop explaining stuff carefully now. If you get stuck or "
"want\n"
"to know more about Lean (e.g. how to do much harder maths in Lean),\n"
"ask in `#new members` at\n"
"<a href=\"https://leanprover.zulipchat.com\" target=\"blank\">the Lean chat</"
"a>\n"
"(login required, real name preferred). Kevin or Mohammad or one of the "
"other\n"
"people there might be able to help.\n"
"\n"
"Good luck! Click on \"next level\" to solve some levels on your own.\n"
"\n"
msgstr ""

#: Addition world level 2
msgid ""
"# Addition world\n"
"\n"
"Don't forget to use the drop down boxes on the left to see your tactics and\n"
"what you have proved so far.\n"
"\n"
"## Level 2: `add_assoc` -- associativity of addition.\n"
"\n"
"It's well-known that (1 + 2) + 3 = 1 + (2 + 3) -- if we have three numbers\n"
"to add up, it doesn't matter which of the additions we do first. This fact\n"
"is called *associativity of addition* by mathematicians, and it is *not*\n"
"obvious. For example, subtraction really is not associative: $(6 - 2) - 1$\n"
"is really not equal to $6 - (2 - 1)$. We are going to have to prove\n"
"that addition, as defined the way we've defined it, is associative. \n"
" \n"
"See if you can prove associativity of addition. Hint: because addition was "
"defined\n"
"by recursion on the right-most variable, use induction on the right-most\n"
"variable (try other variables at your peril!). Note that when Lean writes `a "
"+ b + c`,\n"
"it means `(a + b) + c`. If it wants to talk about `a + (b + c)` it will put "
"the brackets\n"
"in explictly.\n"
"\n"
"Reminder: you are done when you see \"Proof complete!\" in the top right, "
"and an empty\n"
"box (no errors) in the bottom right. You can move between levels and worlds "
"(i.e. you\n"
"can go back and review old stuff) without losing anything.\n"
"\n"
"Once you're done with associativity (sub-boss), we can move on to "
"commutativity (boss).\n"
msgstr ""

#: Addition world level 2
msgid ""
"On the set of natural numbers, addition is associative.\n"
"In other words, for all natural numbers $a, b$ and $c$, we have\n"
"$$ (a + b) + c = a + (b + c). $$\n"
msgstr ""

#: Addition world level 3
msgid ""
"# Addition World\n"
"\n"
"## Level 3: `succ_add`\n"
"\n"
"Oh no! On the way to `add_comm`, a wild `succ_add` appears. `succ_add`\n"
"is the proof that `succ(a) + b = succ(a + b)` for `a` and `b` in your\n"
"natural number type. We need to prove this now, because we will need\n"
"to use this result in our proof that `a + b = b + a` in the next level.\n"
"\n"
"NB: think about why computer scientists called this result `succ_add` .\n"
"There is a logic to all the names.\n"
"\n"
"Note that if you want to be more precise about exactly where you want\n"
"to rewrite something like `add_succ` (the proof you already have),\n"
"you can do things like `rw add_succ (succ a)` or\n"
"`rw add_succ (succ a) d`, telling Lean explicitly what to use for\n"
"the input variables for the function `add_succ`. Indeed, `add_succ`\n"
"is a function -- it takes as input two variables `a` and `b` and outputs a "
"proof\n"
"that `a + succ(b) = succ(a + b)`. The tactic `rw add_succ` just says to Lean "
"\"guess\n"
"what the variables are\". \n"
msgstr ""

#: Addition world level 3
msgid ""
"For all natural numbers $a, b$, we have\n"
"$$ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b). $$\n"
msgstr ""

#: Addition world level 4
msgid ""
"# Addition World\n"
"\n"
"## Level 4: `add_comm` (boss level)\n"
"\n"
"[boss battle music]\n"
"\n"
"Look in Theorem statements -> Addition world to see the proofs you have.\n"
"These should be enough.\n"
msgstr ""

#: Addition world level 4
msgid ""
"On the set of natural numbers, addition is commutative.\n"
"In other words, for all natural numbers $a$ and $b$, we have\n"
"$$ a + b = b + a. $$\n"
msgstr ""

#: Addition world level 4
msgid ""
"\n"
"If you got this far -- nice! You're nearly ready to make a choice:\n"
"Multiplication World or Function World. But there are just a couple\n"
"more useful lemmas in Addition World which you should prove first.\n"
"Press on to level 5.\n"
"\n"
msgstr ""

#: Addition world level 5
msgid ""
"\n"
"# Addition World\n"
"\n"
"## Level 5: `succ_eq_add_one`\n"
"\n"
"I've just added `one_eq_succ_zero` (a proof of `1 = succ(0)`) to your list "
"of theorems; this is true\n"
"by definition of $1$, but we didn't need it until now.\n"
"\n"
"Levels 5 and 6 are the two last levels in Addition World.\n"
"Level 5 involves the number $1$. When you see a $1$ in your goal,\n"
"you can write `rw one_eq_succ_zero` to get back\n"
"to something which only mentions `0`. This is a good move because $0$ is "
"easier for us to\n"
"manipulate than $1$ right now, because we have\n"
"some theorems about $0$ (`zero_add`, `add_zero`), but, other than `1 = "
"succ(0)`,\n"
"no theorems at all which mention $1$. Let's prove one now.\n"
msgstr ""

#: Addition world level 5
msgid ""
"For any natural number $n$, we have\n"
"$$ \\operatorname{succ}(n) = n+1. $$\n"
msgstr ""

#: Addition world level 6
msgid ""
"\n"
"# Addition World\n"
"\n"
"## Level 6: `add_right_comm`\n"
"\n"
"Lean sometimes writes `a + b + c`. What does it mean? The convention is\n"
"that if there are no brackets displayed in an addition formula, the "
"brackets\n"
"are around the left most `+` (Lean's addition is \"left associative\"). \n"
"So the goal in this level is `(a + b) + c = (a + c) + b`. This isn't\n"
"quite `add_assoc` or `add_comm`, it's something you'll have to prove\n"
"by putting these two theorems together.\n"
"\n"
"If you hadn't picked up on this already, `rw add_assoc` will\n"
"change `(x + y) + z` to `x + (y + z)`, but to change it back\n"
"you will need `rw ← add_assoc`. Get the left arrow by typing `\\l`\n"
"then the space bar (note that this is L for left, not a number 1).\n"
"Similarly, if `h : a = b` then `rw h` will change `a`'s to `b`'s\n"
"and `rw ← h` will change `b`'s to `a`'s.\n"
"\n"
"Also, you can be (and will need to be, in this level) more precise\n"
"about where to rewrite theorems. `rw add_comm,` will just find the\n"
"first `? + ?` it sees and swap it around. You can target more specific\n"
"additions like this: `rw add_comm a` will swap around\n"
"additions of the form `a + ?`, and `rw add_comm a b,` will only\n"
"swap additions of the form `a + b`.\n"
"\n"
"## Where next?\n"
"\n"
"There are thirteen more levels about addition after this one, but before\n"
"you can attempt them you need to learn some more tactics. So after this\n"
"level you have a choice -- either move on to Multiplication World (which you "
"can\n"
"solve with the tactics you know) or try Function World (and learn some new "
"ones).\n"
"After solving this level, click \"Main Menu\" in the top left to take you "
"back\n"
"to the overworld, and make your choice. Other things, perhaps of interest\n"
"to some players, are mentioned below the lemma. \n"
msgstr ""

#: Addition world level 6
msgid ""
"For all natural numbers $a, b$ and $c$, we have\n"
"$$ a + b + c = a + c + b. $$\n"
msgstr ""

#: Addition world level 6
msgid ""
"If you have got this far, then you have become very good at\n"
"manipulating equalities in Lean. You can also now collect\n"
"four collectibles (or `instance`s, as Lean calls them)\n"
"\n"
"```\n"
"mynat.add_semigroup -- (after level 2)\n"
"mynat.add_monoid -- (after level 2)\n"
"mynat.add_comm_semigroup mynat (after level 4)\n"
"mynat.add_comm_monoid -- (after level 4)\n"
"```\n"
"\n"
"In Multiplication World you will be able to collect such\n"
"advanced collectibles as `mynat.comm_semiring` and\n"
"`mynat.distrib`, and then move on to power world and\n"
"the famous collectible at the end of it.\n"
"\n"
"One last thing -- didn't you think that solving this level\n"
"`add_right_comm` was boring? Check out this AI that can do it for us.\n"
"\n"
"First we have to get the `add_comm_monoid` collectible,\n"
"which we do by saying the magic words which make Lean's type class "
"inference\n"
"system give it to us.\n"
msgstr ""

#: Addition world level 6
msgid ""
"Now the `simp` AI becomes accessible (it's just an advanced\n"
"tactic really), and can nail some really tedious-for-a-human-to-solve\n"
"goals. For example check out this one-line proof:\n"
msgstr ""

#: Addition world level 6
msgid ""
"Imagine having to do that one by hand! The AI closes the goal\n"
"because it knows how to use associativity and commutativity\n"
"sensibly in a commutative monoid.\n"
"\n"
"You are now done with addition world. Go back to the main menu (top left)\n"
"and decide whether to press on with multiplication world and power world\n"
"(which can be solved with `rw`, `refl` and `induction`), or to go on\n"
"to Function World where you can learn the tactics needed to prove\n"
"goals of the form $P\\implies Q$, thus enabling you to solve more\n"
"advanced addition world levels such as $a+t=b+t\\implies a=b$. Note that\n"
"Function World is more challenging mathematically; but if you can do "
"Addition\n"
"World you can surely do Multiplication World and Power World.\n"
msgstr ""

#: Addition world level 6
msgid ""
"\n"
"## Summary\n"
"\n"
"The `simp` tactic is a high-level tactic which tries\n"
"to prove equalities using facts in its database (such\n"
"as `add_assoc` and `add_comm`).\n"
"\n"
"## Details\n"
"\n"
"The `simp` tactic does basic automation. By level 6 of\n"
"Addition World you\n"
"have proved enough about addition for `simp` to be able\n"
"to solve all equalities whose proofs involve a tedious number\n"
"of rewrites of `add_assoc` and `add_comm`, and by\n"
"level 9 of Multiplication World the same is true of `mul_assoc` and "
"`mul_comm`.\n"
"\n"
"### Example:\n"
"If our goal is this:\n"
"```\n"
"⊢ a + b + c + d + e = c + (b + e + a) + d\n"
"```\n"
"\n"
"and you have completed addition world, then you've proved\n"
"enough about addition to solve this level with `simp`. \n"
"Note however that you can't prove `add_assoc` with `simp`,\n"
"because `add_assoc` is an ingredient to get `simp` working.\n"
"\n"
"### Example:\n"
"If our goal is this:\n"
"```\n"
"⊢ a * b * c = c * b * a\n"
"```\n"
"then as long as you've completed Multiplication World, `simp` will close "
"this\n"
"goal.\n"
msgstr ""

#: world_config
msgid "Multiplication world"
msgstr ""

#: Multiplication world level 1
msgid "import mynat.mul -- import the definition of multiplication on mynat"
msgstr ""

#: Multiplication world level 1
msgid ""
"\n"
"# Multiplication World\n"
"\n"
"A new import! This import gives you the definition of multiplication on "
"your\n"
"natural numbers. It is defined by recursion, just like addition.\n"
"Here are the two new axioms:\n"
"\n"
"  * `mul_zero (a : mynat) : a * 0 = 0`\n"
"  * `mul_succ (a b : mynat) : a * succ(b) = a * b + a`\n"
"\n"
"In words, we define multiplication by \"induction on the second variable\",\n"
"with `a * 0` defined to be `0` and, if we know `a * b`, then `a` times\n"
"the number after `b` is defined to be `a * b + a`. \n"
"\n"
"You can keep all the theorems you proved about addition, but \n"
"for multiplication, those two results above are you've got right now.\n"
"I would recommend that you sort out the bar on the left. Fold up "
"everything,\n"
"and then unfold just Theorem Statements -> Multiplication World. This will\n"
"remind you of your two new theorems, both of which are true by definition.\n"
"If you want to be reminded of the theorems you have proved about addition,\n"
"you can just open up the Addition World theorem statements and take a "
"look. \n"
"If you don't want to keep opening and closing these menus, why not think\n"
"a bit about the logic behind the naming of the proofs? After a while you\n"
"might find that you can guess the name of the proof you want.\n"
"\n"
"Anyway, what's going on in multiplication world? Like addition, we need to "
"go\n"
"for the proofs that multiplication\n"
"is commutative and associative, but as well as that we will\n"
"need to prove facts about the relationship between multiplication\n"
"and addition, for example `a * (b + c) = a * b + a * c`, so now\n"
"there is a lot more to do. Good luck! \n"
"\n"
"We are given `mul_zero`, and the first thing to prove is `zero_mul`.\n"
"Like `zero_add`, we of course prove it by induction.\n"
"\n"
"## Level 1: `zero_mul`\n"
msgstr ""

#: Multiplication world level 1
msgid ""
"For all natural numbers $m$, we have\n"
"$$ 0 \\times m = 0. $$\n"
msgstr ""

#: Multiplication world level 2
msgid ""
"# Multiplication World\n"
"\n"
"## Level 2: `mul_one`\n"
"\n"
"Remember that you can see everything you have proved so far about "
"multiplication in\n"
"the drop-down box on the left (and that this list will grow as we proceed).\n"
"\n"
"In this level we'll need to use\n"
"\n"
"* `one_eq_succ_zero : 1 = succ(0)`\n"
"\n"
"which was mentioned back in Addition World and\n"
"which will be a useful thing to rewrite right now, as we\n"
"begin to prove a couple of lemmas about how `1` behaves\n"
"with respect to multiplication.\n"
msgstr ""

#: Multiplication world level 2
msgid ""
"For any natural number $m$, we have\n"
"$$ m \\times 1 = m. $$\n"
msgstr ""

#: Multiplication world level 3
msgid ""
"# Multiplication World\n"
"\n"
"## Level 3: `one_mul`\n"
"\n"
"These proofs from addition world might be useful here:\n"
"\n"
"* `one_eq_succ_zero : 1 = succ(0)`\n"
"* `succ_eq_add_one a : succ(a) = a + 1` \n"
"\n"
"We just proved `mul_one`, now let's prove `one_mul`. \n"
"Then we will have proved, in fancy terms,\n"
"that 1 is a \"left and right identity\"\n"
"for multiplication (just like we showed that\n"
"0 is a left and right identity for addition\n"
"with `add_zero` and `zero_add`).\n"
msgstr ""

#: Multiplication world level 3
msgid ""
"For any natural number $m$, we have\n"
"$$ 1 \\times m = m. $$\n"
msgstr ""

#: Multiplication world level 4
msgid ""
"# Multiplication World\n"
"\n"
"## Level 4: `mul_add`\n"
"\n"
"Where are we going? Well we want to prove `mul_comm`\n"
"and `mul_assoc`, i.e. that `a * b = b * a` and\n"
"`(a * b) * c = a * (b * c)`. But we *also* want to\n"
"establish the way multiplication interacts with addition,\n"
"i.e. we want to prove that we can \"expand out the brackets\"\n"
"and show `a * (b + c) = (a * b) + (a * c)`.\n"
"The technical term for this is \"left distributivity of\n"
"multiplication over addition\" (there is also right distributivity,\n"
"which we'll get to later).\n"
"\n"
"Note the name of this proof -- `mul_add`. And note the left\n"
"hand side -- `a * (b + c)`, a multiplication and then an addition.\n"
"I think `mul_add` is much easier to remember than \"left_distrib\",\n"
"an alternative name for the proof of this lemma.\n"
msgstr ""

#: Multiplication world level 4
msgid ""
"Multiplication is distributive over addition.\n"
"In other words, for all natural numbers $a$, $b$ and $t$, we have\n"
"$$ t(a + b) = ta + tb. $$\n"
msgstr ""

#: Multiplication world level 4
msgid "def left_distrib := mul_add -- the \"proper\" name for this lemma"
msgstr ""

#: Multiplication world level 5
msgid ""
"# Multiplication World\n"
"\n"
"## Level 5: `mul_assoc`\n"
"\n"
"We now have enough to prove that multiplication is associative.\n"
"\n"
"## Random tactic hints\n"
"\n"
"1) Did you know you can do `repeat {rw mul_succ}`?\n"
"\n"
"2) Did you know you can do `rwa [hd, mul_add]`?\n"
"I learnt that trick from Ken Lee. Ken spotted that\n"
"`rwa` will do the rewrites and will then check to\n"
"see if the goal can be proved by `refl`, and if it\n"
"can, it will close it! [It will also close goals which\n"
"are exactly equal to hypotheses, which will be helpful later on.]\n"
msgstr ""

#: Multiplication world level 5
msgid ""
"Multiplication is associative.\n"
"In other words, for all natural numbers $a$, $b$ and $c$, we have\n"
"$$ (ab)c = a(bc). $$\n"
msgstr ""

#: Multiplication world level 5
msgid ""
"A mathematician could now remark that you have proved that the natural\n"
"numbers form a monoid under multiplication.\n"
msgstr ""

#: Multiplication world level 6
msgid ""
"# Multiplication World\n"
"\n"
"## Level 6: `succ_mul`\n"
"\n"
"We now begin our journey to `mul_comm`, the proof that `a * b = b * a`. \n"
"We'll get there in level 8. Until we're there, it is frustrating\n"
"but true that we cannot assume commutativity. We have `mul_succ`\n"
"but we're going to need `succ_mul` (guess what it says -- maybe you\n"
"are getting the hang of Lean's naming conventions). \n"
"\n"
"Remember also that we have tools like\n"
"\n"
"* `add_right_comm a b c : a + b + c = a + c + b` \n"
"\n"
"These things are the tools we need to slowly build up the results\n"
"which we will need to do mathematics \"normally\". \n"
"We also now have access to Lean's `simp` tactic,\n"
"which will solve any goal which just needs a bunch\n"
"of rewrites of `add_assoc` and `add_comm`. Use if\n"
"you're getting lazy!\n"
msgstr ""

#: Multiplication world level 6
msgid ""
"For all natural numbers $a$ and $b$, we have\n"
"$$ \\operatorname{succ}(a) \\times b = ab + b. $$\n"
msgstr ""

#: Multiplication world level 7
msgid ""
"# Multiplication World\n"
"\n"
"## Level 7: `add_mul`\n"
"\n"
"We proved `mul_add` already, but because we don't have commutativity yet\n"
"we also need to prove `add_mul`. We have a bunch of tools now, so this "
"won't\n"
"be too hard. You know what -- you can do this one by induction on any of\n"
"the variables. Try them all! Which works best? If you can't face\n"
"doing all the commutativity and associativity, remember the high-powered\n"
"`simp` tactic mentioned at the bottom of Addition World level 6,\n"
"which will solve any puzzle which needs only commutativity\n"
"and associativity. If your goal looks like `a+(b+c)=c+b+a` or something,\n"
"don't mess around doing it explicitly with `add_comm` and `add_assoc`,\n"
"just try `simp`.\n"
msgstr ""

#: Multiplication world level 7
msgid ""
"Addition is distributive over multiplication.\n"
"In other words, for all natural numbers $a$, $b$ and $t$, we have\n"
"$$ (a + b) \\times t = at + bt. $$\n"
msgstr ""

#: Multiplication world level 7
msgid ""
"A mathematician would now say that you have proved that the natural\n"
"numbers are a semiring. This sounds like a respectable result.\n"
msgstr ""

#: Multiplication world level 7
msgid "def right_distrib := add_mul -- alternative name"
msgstr ""

#: Multiplication world level 7
msgid ""
"Lean would add that you have also proved that they are a `distrib`. \n"
"However this concept has no mathematical name at all -- this says something\n"
"about the regard with which mathematicians hold this collectible.\n"
"This is an artefact of the set-up of collectibles in Lean. You consider "
"politely\n"
"declining Lean's offer of a `distrib` collectible.\n"
"You are dreaming of the big collectible at the end of power world.\n"
msgstr ""

#: Multiplication world level 7
msgid "instance : distrib mynat := by structure_helper -- "
msgstr ""

#: Multiplication world level 8
msgid ""
"# Multiplication World\n"
"\n"
"## Level 8: `mul_comm`\n"
"\n"
"Finally, the boss level of multiplication world. But (assuming you\n"
"didn't cheat) you are well-prepared for it -- you have `zero_mul`\n"
"and `mul_zero`, as well as `succ_mul` and `mul_succ`. After this\n"
"level you can of course throw away one of each pair if you like,\n"
"but I would recommend you hold on to them, sometimes it's convenient\n"
"to have exactly the right tools to do a job.\n"
msgstr ""

#: Multiplication world level 8
msgid "Multiplication is commutative.\n"
msgstr ""

#: Multiplication world level 8
msgid ""
"You've now proved that the natural numbers are a commutative semiring!\n"
"That's the last collectible in Multiplication World. \n"
msgstr ""

#: Multiplication world level 8
msgid ""
"But don't leave multiplication just yet -- prove `mul_left_comm`, the last\n"
"level of the world, and then we can beef up the power of `simp`. \n"
msgstr ""

#: Multiplication world level 9
msgid ""
"# Multiplication World\n"
"\n"
"## Level 9: `mul_left_comm`\n"
"\n"
"You are equipped with\n"
"\n"
"* `mul_assoc (a b c : mynat) : (a * b) * c = a * (b * c)`\n"
"* `mul_comm (a b : mynat) : a * b = b * a`\n"
"\n"
"Re-read the docs for `rw` so you know all the tricks.\n"
"You can see them in the \"tactics\" drop-down menu on the left.\n"
msgstr ""

#: Multiplication world level 9
msgid ""
"For all natural numbers $a$ $b$ and $c$, we have\n"
"$$a(bc)=b(ac)$$\n"
msgstr ""

#: Multiplication world level 9
msgid "And now I whisper a magic incantation\n"
msgstr ""

#: Multiplication world level 9
msgid ""
"and all of a sudden Lean can automatically do levels which are\n"
"very boring for a human, for example\n"
msgstr ""

#: Multiplication world level 9
msgid ""
"If you feel like attempting Advanced Multiplication world\n"
"you'll have to do Function World and the Proposition Worlds first.\n"
"These worlds assume a certain amount of mathematical maturity\n"
"(perhaps 1st year undergraduate level). \n"
"Your other possibility is Power World, with the \"final boss\".\n"
msgstr ""

#: world_config
msgid "Power world"
msgstr ""

#: Power world level 1
msgid "import mynat.pow -- new import"
msgstr ""

#: Power world level 1
msgid ""
"\n"
"# Power World\n"
"\n"
"A new world with seven levels. And a new import!\n"
"This import gives you the power to make powers of your\n"
"natural numbers. It is defined by recursion, just like addition and "
"multiplication.\n"
"Here are the two new axioms:\n"
"\n"
"  * `pow_zero (a : mynat) : a ^ 0 = 1`\n"
"  * `pow_succ (a b : mynat) : a ^ succ(b) = a ^ b * a`\n"
"\n"
"The power function has various relations to addition and multiplication.\n"
"If you have gone through levels 1--6 of addition world and levels 1--9 of\n"
"multiplication world, you should have no trouble with this world:\n"
"The usual tactics `induction`, `rw` and `refl` should see you through.\n"
"You might want to fiddle with the\n"
"drop-down menus on the left so you can see which theorems of Power World\n"
"you have proved at any given time. Addition and multiplication -- we\n"
"have a solid API for them now, i.e. if you need something about addition\n"
"or multiplication, it's probably already in the library we have built.\n"
"Collectibles are indication that we are proving the right things.\n"
"\n"
"The levels in this world were designed by Sian Carey, a UROP student\n"
"at Imperial College London, funded by a Mary Lister McCammon Fellowship,\n"
"in the summer of 2019. Thanks Sian!\n"
"\n"
"## Level 1: `zero_pow_zero`\n"
msgstr ""

#: Power world level 1
msgid "$0 ^ 0 = 1$.\n"
msgstr ""

#: Power world level 2
msgid ""
"\n"
"# Power World\n"
"\n"
"## Level 2: `zero_pow_succ`\n"
msgstr ""

#: Power world level 2
msgid "For all naturals $m$, $0 ^{succ (m)} = 0$.\n"
msgstr ""

#: Power world level 3
msgid ""
"\n"
"# Power World\n"
"\n"
"## Level 3: `pow_one`\n"
msgstr ""

#: Power world level 3
msgid "For all naturals $a$, $a ^ 1 = a$.\n"
msgstr ""

#: Power world level 4
msgid ""
"\n"
"# Power World\n"
"\n"
"## Level 4: `one_pow`\n"
msgstr ""

#: Power world level 4
msgid "For all naturals $m$, $1 ^ m = 1$.\n"
msgstr ""

#: Power world level 5
msgid ""
"\n"
"# Power World\n"
"\n"
"## Level 5: `pow_add`\n"
msgstr ""

#: Power world level 5
msgid "For all naturals $a$, $m$, $n$, we have $a^{m + n} = a ^ m  a ^ n$.\n"
msgstr ""

#: Power world level 6
msgid ""
"\n"
"# Power World\n"
"\n"
"## Level 6: `mul_pow`\n"
"\n"
"You might find the tip at the end of level 9 of Multiplication World\n"
"useful in this one. You can go to the main menu and pop back into\n"
"Multiplication World and take a look -- you won't lose any of your\n"
"proofs. You'll only lose proofs if you reload the page.\n"
msgstr ""

#: Power world level 6
msgid "For all naturals $a$, $b$, $n$, we have $(ab) ^ n = a ^ nb ^ n$.\n"
msgstr ""

#: Power world level 7
msgid ""
"\n"
"# Power World\n"
"\n"
"## Level 7: `pow_pow`\n"
msgstr ""

#: Power world level 7
msgid "Boss level! What will the collectible be?\n"
msgstr ""

#: Power world level 7
msgid "For all naturals $a$, $m$, $n$, we have $(a ^ m) ^ n = a ^ {mn}$.\n"
msgstr ""

#: Power world level 7
msgid ""
"Apparently Lean can't find a collectible, even though you feel like you\n"
"just finished power world so you must have proved *something*. What should "
"the\n"
"collectible for this level be called? \n"
msgstr ""

#: Power world level 7
msgid ""
"But what is this? It's one of those twists where there's another\n"
"boss after the boss you thought was the final boss! Go to the next\n"
"level!\n"
msgstr ""

#: Power world level 8
msgid "# Power World\n"
msgstr ""

#: Power world level 8
msgid ""
"## Level 8: `add_squared`\n"
"\n"
"[final boss music] \n"
"\n"
"You see something written on the stone dungeon wall:\n"
"```\n"
"begin\n"
"  rw two_eq_succ_one,\n"
"  rw one_eq_succ_zero,\n"
"  repeat {rw pow_succ},\n"
"  ...\n"
"```\n"
"\n"
"and you can't make out the last two lines because there's a kind\n"
"of thing in the way that will magically disappear\n"
"but only when you've beaten the boss.\n"
"\n"
msgstr ""

#: Power world level 8
msgid ""
"For all naturals $a$ and $b$, we have\n"
"$$(a+b)^2=a^2+b^2+2ab.$$\n"
msgstr ""

#: Power world level 8
msgid ""
"As the boss lies smouldering, you notice on the dungeon wall that\n"
"<a href=\"https://twitter.com/XenaProject/status/1190453646904958976?s=20/\" "
"target=\"blank\">\n"
"two more lines of code are now visible under the first three...</a> (Twitter."
"com)\n"
"\n"
"I just beat this level with 27 single rewrites followed by a `refl`. \n"
"Can you do any better? (The current rewrite record is 25 -- see <a href="
"\"https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/"
"function.20with.20random.20definition/near/179723073\" target=\"blank"
"\">here</a>\n"
"(needs zulip login)).\n"
"If you beat it then well done! Do you\n"
"fancy doing $(a+b)^3$ now? You might want to read \n"
"<a href=\"https://xenaproject.wordpress.com/2018/06/13/ab3/\" target=\"blank"
"\">\n"
"this Xena Project blog post</a> before you start though.\n"
msgstr ""

#: Power world level 8
msgid ""
"If you got this far -- very well done! If you only learnt the three\n"
"tactics `rw`, `induction` and `refl` then there are now more tactics to\n"
"learn; go back to the main menu and choose Function World. \n"
"\n"
"The main thing we really want to impress upon people is that we believe\n"
"that *all of pure mathematics* can be done in this new way.\n"
"A system called Coq (which is very like Lean) has\n"
"<a href=\"https://hal.inria.fr/hal-00816699\" target=\"blank\">\n"
"checked the proof of the Feit-Thompson theorem</a> (hundreds of pages of\n"
"group theory) and Lean has a\n"
"<a href=\"https://leanprover-community.github.io/lean-perfectoid-spaces/\"\n"
"  target=\"blank\">\n"
"definition of perfectoid spaces</a> (a very complex modern\n"
"mathematical structure). I believe that these systems will one day\n"
"cause a paradigm shift in the way mathematics is done, but first we need\n"
"to build what we know, or at least build enough to state what we\n"
"mathematicians believe. If you want to get involved, come and join\n"
"us at the <a href=\"https://leanprover.zulipchat.com\" target=\"blank"
"\">Zulip Lean chat</a>.\n"
"The #new members stream is a great place to start asking questions.\n"
"\n"
"To come (possibly): the real number game, the group theory game,\n"
"the integer game, the natural number game 2,... . Alternatively\n"
"see <a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/"
"FAQ.html\" target=\"blank\">the FAQ</a>\n"
"for some more ideas about what to do next.\n"
"\n"
msgstr ""

#: world_config
msgid "Function world"
msgstr ""

#: Function world level 1
msgid ""
"\n"
"# Function world. \n"
"\n"
"If you have beaten Addition World, then you have got\n"
"quite good at manipulating equalities in Lean using the `rw` tactic.\n"
"But there are plenty of levels later on which will require you\n"
"to manipulate functions, and `rw` is not the tool for you here.\n"
"\n"
"To manipulate functions effectively, we need to learn about a new "
"collection\n"
"of tactics, namely `exact`, `intro`, `have` and `apply`. These tactics\n"
"are specially designed for dealing with functions. Of course we are\n"
"ultimately interested in using these tactics to prove theorems\n"
"about the natural numbers &ndash; but in this\n"
"world there is little point in working with specific sets like `mynat`,\n"
"everything works for general sets.\n"
"\n"
"So our notation for this level is: $P$, $Q$, $R$ and so on denote general "
"sets,\n"
"and $h$, $j$, $k$ and so on denote general\n"
"functions between them. What we will learn in this world is how to use "
"functions\n"
"in Lean to push elements from set to set. A word of warning &ndash; \n"
"even though there's no harm at all in thinking of $P$ being a set and $p$\n"
"being an element, you will not see Lean using the notation $p\\in P$, "
"because\n"
"internally Lean stores $P$ as a \"Type\" and $p$ as a \"term\", and it uses "
"`p : P`\n"
"to mean \"$p$ is a term of type $P$\", Lean's way of expressing the idea "
"that $p$\n"
"is an element of the set $P$. You have seen this already &ndash; Lean has\n"
"been writing `n : mynat` to mean that $n$ is a natural number.\n"
"\n"
"## A new kind of goal.\n"
"\n"
"All through addition world, our goals have been theorems,\n"
"and it was our job to find the proofs. \n"
"**The levels in function world aren't theorems**. This is the only world "
"where\n"
"the levels aren't theorems in fact. In function world the object of a level\n"
"is to create an element of the set in the goal. The goal will look like `⊢ "
"X`\n"
"with $X$ a set and you get rid of the goal by constructing an element of $X"
"$. \n"
"I don't know if you noticed this, but you finished\n"
"essentially every goal of Addition World (and Multiplication World and Power "
"World,\n"
"if you played them) with `refl`.\n"
"This tactic is no use to us here.\n"
"We are going to have to learn a new way of solving goals &ndash; the `exact` "
"tactic.\n"
"\n"
"If you delete the sorry below then your local context will look like this:\n"
"\n"
"```\n"
"P Q : Type,\n"
"p : P,\n"
"h : P → Q\n"
"⊢ Q\n"
"```\n"
"\n"
"In this situation, we have sets $P$ and $Q$ (but Lean calls them types),\n"
"and an element $p$ of $P$ (written `p : P`\n"
"but meaning $p\\in P$). We also have a function $h$ from $P$ to $Q$,\n"
"and our goal is to construct an\n"
"element of the set $Q$. It's clear what to do *mathematically* to solve\n"
"this goal -- we can\n"
"make an element of $Q$ by applying the function $h$ to\n"
"the element $p$. But how to do it in Lean? There are at least two ways\n"
"to explain this idea to Lean,\n"
"and here we will learn about one of them, namely the method which\n"
"uses the `exact` tactic.\n"
"\n"
"## The `exact` tactic. \n"
"\n"
"If you can explicitly see how to make an element of your goal set,\n"
"i.e. you have a formula for it, then you can just write `exact <formula>` \n"
"and this will close the goal. \n"
"\n"
"### Example\n"
"\n"
"If your local context looks like this\n"
"\n"
"```\n"
"P Q : Type,\n"
"p : P,\n"
"h : P → Q\n"
"⊢ Q\n"
"```\n"
"\n"
"then $h(p)$ is an element of $Q$ so you can just write\n"
"\n"
"`exact h(p),`\n"
"\n"
"to close the goal. \n"
"\n"
"## Important note\n"
"\n"
"Note that `exact h(P),` won't work (with a capital $P$);\n"
"this is a common error I see from beginners. \n"
"$P$ is not an element of $P$, it's $p$ that is an element of $P$. \n"
"\n"
"## Level 1: the `exact` tactic.\n"
msgstr ""

#: Function world level 1
msgid ""
"Given an element of $P$ and a function from $P$ to $Q$,\n"
"we define an element of $Q$.\n"
msgstr ""

#: Function world level 1
msgid ""
"\n"
"## Summary \n"
"\n"
"If the goal is `⊢ X` then `exact x` will close the goal if\n"
"and only if `x` is a term of type `X`. \n"
"\n"
"## Details\n"
"\n"
"Say $P$, $Q$ and $R$ are types (i.e., what a mathematician\n"
"might think of as either sets or propositions),\n"
"and the local context looks like this: \n"
"\n"
"```\n"
"p : P,\n"
"h : P → Q,\n"
"j : Q → R\n"
"⊢ R\n"
"```\n"
"\n"
"If you can spot how to make a term of type `R`, then you\n"
"can just make it and say you're done using the `exact` tactic\n"
"together with the formula you have spotted. For example the\n"
"above goal could be solved with\n"
"\n"
"`exact j(h(p)),`\n"
"\n"
"because $j(h(p))$ is easily checked to be a term of type $R$\n"
"(i.e., an element of the set $R$, or a proof of the proposition $R$).\n"
"\n"
msgstr ""

#: Function world level 2
msgid "import mynat.add -- + on mynat"
msgstr ""

#: Function world level 2
msgid "import mynat.mul -- * on mynat"
msgstr ""

#: Function world level 2
msgid ""
"\n"
"## Summary:\n"
"\n"
"`intro p` will turn a goal `⊢ P → Q` into a hypothesis `p : P`\n"
"and goal `⊢ Q`. If `P` and `Q` are sets `intro p` means \"let $p$ be an "
"arbitrary element of $P$\".\n"
"If `P` and `Q` are propositions then `intro p` says \"assume $P$ is true"
"\". \n"
"\n"
"## Details\n"
"\n"
"If your goal is a function or an implication `⊢ P → Q` then `intro`\n"
"will always make progress. `intro p` turns\n"
"\n"
"`⊢ P → Q`\n"
"\n"
"into \n"
"\n"
"```\n"
"p : P\n"
"⊢ Q\n"
"```\n"
"\n"
"The opposite tactic to intro is `revert`; given the situation\n"
"just above, `revert p` turns the goal back into `⊢ P → Q`.\n"
"\n"
"There are two points of view with `intro` -- the\n"
"function point of view (Function World) and the proposition\n"
"point of view (Proposition World).\n"
"\n"
"## Example (functions)\n"
"\n"
"What does it mean to define\n"
"a function? Given an arbitrary term of type `P` (or an element\n"
"of the set `P` if you think set-theoretically) you need\n"
"to come up with a term of type `Q`, so your first step is\n"
"to choose `p`, an arbitary element of `P`. \n"
"\n"
"`intro p,` is Lean's way of saying \"let $p\\in P$ be arbitrary\".\n"
"The tactic `intro p` changes\n"
"\n"
"```\n"
"⊢ P → Q\n"
"```\n"
"\n"
"into\n"
"\n"
"```\n"
"p : P\n"
"⊢ Q\n"
"```\n"
"\n"
"So `p` is an arbitrary element of `P` about which nothing is known,\n"
"and our task is to come up with an element of `Q` (which can of\n"
"course depend on `p`).\n"
"\n"
"## Example (propositions)\n"
"\n"
"If your goal is an implication $P\\implies Q$ then Lean writes\n"
"this as `⊢ P → Q`, and `intro p,` can be thought of as meaning\n"
"\"let $p$ be a proof of $P$\", or more informally \"let's assume that\n"
"$P$ is true\". The goal changes to `⊢ Q` and the hypothesis `p : P`\n"
"appears in the local context.\n"
msgstr ""

#: Function world level 2
msgid ""
"# Function world. \n"
"\n"
"## Level 2: the `intro` tactic.\n"
"\n"
"Let's make a function. Let's define the function on the natural\n"
"numbers which sends a natural number $n$ to $3n+2$. If you delete the\n"
"`sorry` you will see that our goal is `mynat → mynat`. A mathematician\n"
"might denote this set with some exotic name such as\n"
"$\\operatorname{Hom}(\\mathbb{N},\\mathbb{N})$,\n"
"but computer scientists use notation `X → Y` to denote the set of\n"
"functions from `X` to `Y` and this name definitely has its merits.\n"
"In type theory, `X → Y` is a type (the type of all functions from $X$ to $Y"
"$),\n"
"and `f : X → Y` means that `f` is a term\n"
"of this type, i.e., $f$ is a function from $X$ to $Y$.\n"
"\n"
"To define a function $X\\to Y$ we need to choose an arbitrary\n"
"element $x\\in X$ and then, perhaps using $x$, make an element of $Y$.\n"
"The Lean tactic for \"let $x\\in X$ be arbitrary\" is `intro x`.\n"
"\n"
"## Rule of thumb: \n"
"\n"
"If your goal is `P → Q` then `intro p` will make progress.\n"
"\n"
"To solve the goal below, you have to come up with a function from `mynat`\n"
"to `mynat`. Start with\n"
"\n"
"`intro n,`\n"
"\n"
"(i.e. \"let $n\\in\\mathbb{N}$ be arbitrary\") and note that our\n"
"local context now looks like this:\n"
"\n"
"```\n"
"n : mynat\n"
"⊢ mynat\n"
"```\n"
"\n"
"Our job now is to construct a natural number, which is\n"
"allowed to depend on $n$. We can do this using `exact` and\n"
"writing a formula for the function we want to define. For example\n"
"we imported addition and multiplication at the top of this file,\n"
"so \n"
"\n"
"`exact 3*n+2,`\n"
"\n"
"will close the goal, ultimately defining the function $f(n)=3n+2$.\n"
"\n"
msgstr ""

#: Function world level 2
msgid "We define a function from mynat to mynat.\n"
msgstr ""

#: Function world level 3
msgid ""
"\n"
"## Summary\n"
"\n"
"`have h : P,` will create a new goal of creating a term of type `P`,\n"
"and will add `h : P` to the hypotheses for the goal you were working on.\n"
"\n"
"## Details\n"
"\n"
"If you want to name a term of some type (because you want it\n"
"in your local context for some reason), and if you have the\n"
"formula for the term, you can use `have` to give the term a name. \n"
"\n"
"## Example (`have q := ...` or `have q : Q := ...`)\n"
"\n"
"If the local context contains\n"
"```\n"
"f : P → Q\n"
"p : P\n"
"```\n"
"\n"
"then the tactic `have q := f(p),` will add `q` to our local context,\n"
"leaving it like this:\n"
"\n"
"```\n"
"f : P → Q\n"
"p : P\n"
"q : Q\n"
"```\n"
"\n"
"If you think about it, you don't ever really need `q`, because whenever you\n"
"think you need it you coudl just use `f(p)` instead. But it's good that\n"
"we can introduce convenient notation like this.\n"
"\n"
"## Example (`have q : Q,`)\n"
"\n"
"A variant of this tactic can be used where you just declare the\n"
"type of the term you want to have, finish the tactic statement with\n"
"a comma and no `:=`, and then Lean just adds it as a new goal.\n"
"The number of goals goes up by one if you use `have` like this.\n"
"\n"
"For example if the local context is\n"
"```\n"
"P Q R : Prop/Type,\n"
"f : P → Q,\n"
"g : Q → R,\n"
"p : P\n"
"⊢ R\n"
"```\n"
"\n"
"then after `have q : Q,`, there will be the new goal\n"
"```\n"
"f : P → Q,\n"
"g : Q → R,\n"
"p : P,\n"
"⊢ Q\n"
"```\n"
"\n"
"and your original goal will have `q : Q` added to the list\n"
"of hypotheses.\n"
msgstr ""

#: Function world level 3
msgid ""
"# Function world. \n"
"\n"
"## Level 3: the `have` tactic.\n"
"\n"
"Say you have a whole bunch of sets and functions between them,\n"
"and your goal is to build a certain element of a certain set.\n"
"If it helps, you can build intermediate elements of other sets\n"
"along the way, using the `have` command. `have` is the Lean analogue\n"
"of saying \"let's define an element $q\\in Q$ by...\" in the middle of a "
"calculation.\n"
"It is often not logically necessary, but on the other hand\n"
"it is very convenient, for example it can save on notation, or\n"
"it can break proofs or calculations up into smaller steps.\n"
"\n"
"In the level below, we have an element of $P$ and we want an element\n"
"of $U$; during the proof we will make several intermediate elements\n"
"of some of the other sets involved. The diagram of sets and\n"
"functions looks like this pictorially:\n"
"\n"
"![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/"
"natural_number_game_images/function_diag.jpg)\n"
"\n"
"and so it's clear how to make the element of $U$ from the element of $P.$\n"
"Indeed, we could solve this level in one move by typing\n"
"\n"
"`exact l(j(h(p))),`\n"
"\n"
"But let us instead stroll more lazily through the level.\n"
"We can start by using the `have` tactic to make an element of $Q$:\n"
"\n"
"`have q := h(p),`\n"
"\n"
"and then we note that $j(q)$ is an element of $T$\n"
"\n"
"`have t : T := j(q),`\n"
"\n"
"(notice how on this occasion we explicitly told Lean what set we thought $t$ "
"was in, with\n"
"that `: T` thing before the `:=`) and we could even define $u$ to be "
"$l(t)$:\n"
"\n"
"`have u : U := l(t),`\n"
"\n"
"and then finish the level with\n"
"\n"
"`exact u,`\n"
"\n"
". \n"
msgstr ""

#: Function world level 3 4
msgid "Given an element of $P$ we can define an element of $U$.\n"
msgstr ""

#: Function world level 3
msgid ""
"If you solved the level using `have`, then click on the last line of your "
"proof\n"
"(you do know you can move your cursor around with the arrow keys\n"
"and explore your proof, right?) and note that the local context at that "
"point\n"
"is in something like the following mess:\n"
"\n"
"```\n"
"P Q R S T U : Type,\n"
"p : P,\n"
"h : P → Q,\n"
"i : Q → R,\n"
"j : Q → T,\n"
"k : S → T,\n"
"l : T → U,\n"
"q : Q,\n"
"t : T,\n"
"u : U\n"
"⊢ U\n"
"```\n"
"\n"
"It was already bad enough to start with, and we added three more\n"
"terms to it. In level 4 we will learn about the `apply` tactic\n"
"which solves the level using another technique, without leaving\n"
"so much junk behind.\n"
msgstr ""

#: Function world level 4
msgid ""
"\n"
"## Summary\n"
"\n"
"If `h : P → Q` is a hypothesis, and the goal is `⊢ Q` then\n"
"`apply h` changes the goal to `⊢ P`. \n"
"\n"
"## Details\n"
"\n"
"If you have a function `h : P → Q` and your goal is `⊢ Q`\n"
"then `apply h` changes the goal to `⊢ P`. The logic is\n"
"simple: if you are trying to create a term of type `Q`,\n"
"but `h` is a function which turns terms of type `P` into\n"
"terms of type `Q`, then it will suffice to construct a\n"
"term of type `P`. A mathematician might say: \"we need\n"
"to construct an element of $Q$, but we have a function $h:P\\to Q$\n"
"so it suffices to construct an element of $P$\". Or alternatively\n"
"\"we need to prove $Q$, but we have a proof $h$ that $P\\implies Q$\n"
"so it suffices to prove $P$\".\n"
"\n"
msgstr ""

#: Function world level 4
msgid ""
"\n"
"# Function world. \n"
"\n"
"## Level 4: the `apply` tactic.\n"
"\n"
"Let's do the same level again:\n"
"\n"
"![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/"
"natural_number_game_images/function_diag.jpg)\n"
"\n"
"We are given $p \\in P$ and our goal is to find an element of $U$, or\n"
"in other words to find a path through the maze that links $P$ to $U$.\n"
"In level 3 we solved this by using `have`s to move forward, from $P$\n"
"to $Q$ to $T$ to $U$. Using the `apply` tactic we can instead construct\n"
"the path backwards, moving from $U$ to $T$ to $Q$ to $P$.\n"
"\n"
"Our goal is to construct an element of the set $U$. But $l:T\\to U$ is\n"
"a function, so it would suffice to construct an element of $T$. Tell\n"
"Lean this by starting the proof below with\n"
"\n"
"`apply l,`\n"
"\n"
"and notice that our assumptions don't change but *the goal changes*\n"
"from `⊢ U` to `⊢ T`. \n"
"\n"
"Keep `apply`ing functions until your goal is `P`, and try not\n"
"to get lost! Now solve this goal\n"
"with `exact p`. Note: you will need to learn the difference between\n"
"`exact p` (which works) and `exact P` (which doesn't, because $P$ is\n"
"not an element of $P$).\n"
msgstr ""

#: Function world level 5
msgid ""
"# Function world. \n"
"\n"
"## Level 5: `P → (Q → P)`.\n"
"\n"
"In this level, our goal is to construct a function, like in level 2.\n"
"\n"
"```\n"
"⊢ P → (Q → P)\n"
"```\n"
"\n"
"So $P$ and $Q$ are sets, and our goal is to construct a function\n"
"which takes an element of $P$ and outputs a function from $Q$ to $P$.\n"
"We don't know anything at all about the sets $P$ and $Q$, so initially\n"
"this seems like a bit of a tall order. But let's give it a go. Delete\n"
"the `sorry` and let's think about how to proceed.\n"
"\n"
"Our goal is `P → X` for some set $X=\\operatorname{Hom}(Q,P)$, and if our\n"
"goal is to construct a function then we almost always want to use the\n"
"`intro` tactic from level 2, Lean's version of \"let $p\\in P$ be arbitrary."
"\"\n"
"So let's start with\n"
"\n"
"`intro p,`\n"
"\n"
"and we then find ourselves in this state:\n"
"\n"
"```\n"
"P Q : Type,\n"
"p : P\n"
"⊢ Q → P\n"
"```\n"
"\n"
"We now have an arbitrary element $p\\in P$ and we are supposed to be "
"constructing\n"
"a function $Q\\to P$. Well, how about the constant function, which sends "
"everything to $p$?\n"
"This will work. So let $q\\in Q$ be arbitrary:\n"
"\n"
"`intro q,`\n"
"\n"
"and then let's output `p`.\n"
"\n"
"`exact p,`\n"
msgstr ""

#: Function world level 5
msgid ""
"We define an element of $\\operatorname{Hom}(P,\\operatorname{Hom}(Q,P))$.\n"
msgstr ""

#: Function world level 5
msgid ""
"A mathematician would treat the set `P → (Q → P)` as the same as the set `P "
"× Q → P`,\n"
"because to give an element of either function space is just to give a rule "
"which takes\n"
"an element of $P$ and an element of $Q$, and returns an element of $P$. "
"Thinking of the\n"
"goal as a function from `P × Q` to `P` we realise that it's just projection "
"onto the first\n"
"factor.\n"
"\n"
"## Did you notice?\n"
"\n"
"I wrote `P → (Q → P)` but Lean just writes `P → Q → P`. This is because\n"
"computer scientists adopt the convention that `→` is *right associative*,\n"
"which is a fancy way of saying \"when we write `P → Q → R`, we mean `P → (Q "
"→ R)`.\"\n"
"Mathematicians use right associativity as a convention for powers: if\n"
"a mathematician says $10^{10^{10}}$ they don't mean $(10^{10})^{10}"
"=10^{100}$, they\n"
"mean $10^{(10^{10})}$. So `10 ^ 10 ^ 10` in Lean means `10 ^ (10 ^ 10)` and "
"not `(10 ^ 10) ^ 10`.\n"
"However they use left associativity as a convention for subtraction: if\n"
"a mathematician writes $6 - 2 - 1$ they mean $(6 - 2) - 1$ and not $6 - (2 - "
"1)$.\n"
"\n"
"## Pro tip\n"
"\n"
"`intros p q,` is the same as `intro p, intro q,`.\n"
msgstr ""

#: Function world level 6
msgid ""
"# Function world. \n"
"\n"
"## Level 6: `(P → (Q → R)) → ((P → Q) → (P → R))`.\n"
"\n"
"You can solve this level completely just using `intro`, `apply` and "
"`exact`,\n"
"but if you want to argue forwards instead of backwards then don't forget\n"
"that you can do things like\n"
"\n"
"`have j : Q → R := f p,`\n"
"\n"
"if `f : P → (Q → R)` and `p : P`. Remember the trick with the colon in "
"`have`:\n"
"we could just write `have j := f p,` but this way we can be sure that `j` "
"is\n"
"what we actually expect it to be.\n"
"\n"
"I recommend that you start with `intro f` rather than `intro p`\n"
"because even though the goal starts `P → ...`, the brackets mean that\n"
"the goal is not a function from `P` to anything, it's a function from\n"
"`P → (Q → R)` to something. In fact you can save time by starting\n"
"with `intros f h p`, which introduces three variables at once, although "
"you'd\n"
"better then look at your tactic state to check that you called all those "
"new\n"
"terms sensible things. \n"
"\n"
"After all the intros, you find that your your goal is `⊢ R`. If you try "
"`have j : Q → R := f p`\n"
"now then you can `apply j`. Alternatively you can `apply (f p)` directly.\n"
"What happens if you just try `apply f`? Can you figure out what just "
"happened? This is a little\n"
"`apply` easter egg. Why is it mathematically valid?\n"
msgstr ""

#: Function world level 6
msgid ""
"Whatever the sets $P$ and $Q$ and $R$ are, we\n"
"make an element of $\\operatorname{Hom}(\\operatorname{Hom}(P,"
"\\operatorname{Hom}(Q,R)),\n"
"\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\\operatorname{Hom}(P,R)))$.\n"
msgstr ""

#: Function world level 7
msgid ""
"# Function world. \n"
"\n"
"## Level 7: `(P → Q) → ((Q → F) → (P → F))` \n"
"\n"
"Have you noticed that, in stark contrast to earlier worlds,\n"
"we are not amassing a large collection of useful theorems? \n"
"We really are just constructing abstract levels with sets and\n"
"functions, and then solving them and never using the results\n"
"ever again. Here's another one, which should hopefully be\n"
"very easy for you now. Advanced mathematician viewers will\n"
"know it as contravariance of $\\operatorname{Hom}(\\cdot,F)$\n"
"functor.\n"
msgstr ""

#: Function world level 7
msgid ""
"Whatever the sets $P$ and $Q$ and $F$ are, we \n"
"make an element of $\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\n"
"\\operatorname{Hom}(\\operatorname{Hom}(Q,F),\\operatorname{Hom}(P,F)))$.\n"
msgstr ""

#: Function world level 8
msgid ""
"# Function world. \n"
"\n"
"## Level 8: `(P → Q) → ((Q → empty) → (P → empty))` \n"
"\n"
"Level 8 is the same as level 7, except we have replaced the\n"
"set $F$ with the empty set $\\emptyset$. The same proof will work (after "
"all, our\n"
"previous proof worked for all sets, and the empty set is a set).\n"
"But note that if you start with `intro f, intro h, intro p,`\n"
"(which can incidentally be shortened to `intros f h p`),\n"
"then the local context looks like this:\n"
"\n"
"```\n"
"P Q : Type,\n"
"f : P → Q,\n"
"h : Q → empty,\n"
"p : P\n"
"⊢ empty\n"
"```\n"
"\n"
"and your job is to construct an element of the empty set!\n"
"This on the face of it seems hard, but what is going on is that\n"
"our hypotheses (we have an element of $P$, and functions $P\\to Q$\n"
"and $Q\\to\\emptyset$) are themselves contradictory, so\n"
"I guess we are doing some kind of proof by contradiction at this point? "
"However,\n"
"if your next line is `apply h` then all of a sudden the goal\n"
"seems like it might be possible again. If this is confusing, note\n"
"that the proof of the previous world worked for all sets $F$, so in "
"particular\n"
"it worked for the empty set, you just probably weren't really thinking "
"about\n"
"this case explicitly beforehand. [Technical note to constructivists: I know\n"
"that we are not doing a proof by contradiction. But how else do you explain\n"
"to a classical mathematician that their goal is to prove something false\n"
"and this is OK because their hypotheses don't add up?]\n"
"\n"
msgstr ""

#: Function world level 8
msgid ""
"Whatever the sets $P$ and $Q$ are, we\n"
"make an element of $\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\n"
"\\operatorname{Hom}(\\operatorname{Hom}(Q,\\emptyset),\\operatorname{Hom}(P,"
"\\emptyset)))$.\n"
msgstr ""

#: Function world level 9
msgid ""
"# Function world. \n"
"\n"
"## Level 9: a big maze. \n"
"\n"
"I asked around on Zulip and apparently there is not a tactic for this, "
"perhaps because\n"
"this level is rather artificial. In world 6 we will see a variant of this "
"example\n"
"which can be solved by a tactic. It would be an interesting project to make "
"a tactic\n"
"which could solve this sort of level in Lean.\n"
"\n"
"You can of course work both forwards and backwards, or you could crack and "
"draw a picture.\n"
"\n"
msgstr ""

#: Function world level 9
msgid "Given a bunch of functions, we can define another one.\n"
msgstr ""

#: Function world level 9
msgid ""
"That's the end of Function World! Next it's Proposition world, and the "
"tactics you've learnt in Function World are enough\n"
"to solve all nine levels! In fact, the levels in Proposition world might "
"look strangely familiar$\\ldots$.\n"
msgstr ""

#: world_config
msgid "Proposition world"
msgstr ""

#: Proposition world level 1
msgid ""
"\n"
"# Proposition world. \n"
"\n"
"A Proposition is a true/false statement, like `2 + 2 = 4` or `2 + 2 = 5`.\n"
"Just like we can have concrete sets in Lean like `mynat`, and abstract\n"
"sets called things like `X`, we can also have concrete propositions like\n"
"`2 + 2 = 5` and abstract propositions called things like `P`. \n"
"\n"
"Mathematicians are very good at conflating a theorem with its proof.\n"
"They might say \"now use theorem 12 and we're done\". What they really\n"
"mean is \"now use the proof of theorem 12...\" (i.e. the fact that we "
"proved\n"
"it already). Particularly problematic is the fact that mathematicians\n"
"use the word Proposition to mean \"a relatively straightforward statement\n"
"which is true\" and computer scientists use it to mean \"a statement of\n"
"arbitrary complexity, which might be true or false\". Computer scientists\n"
"are far more careful about distinguishing between a proposition and a "
"proof.\n"
"For example: `x + 0 = x` is a proposition, and `add_zero x`\n"
"is its proof. The convention we'll use is capital letters for propositions\n"
"and small letters for proofs. \n"
"\n"
"In this world you will see the local context in the following kind of "
"state:\n"
"\n"
"```\n"
"P : Prop\n"
"p : P\n"
"```\n"
"\n"
"Here `P` is the true/false statement (the statement of proposition), and `p` "
"is its proof.\n"
"It's like `P` being the set and `p` being the element. In fact computer "
"scientists\n"
"sometimes think about the following analogy: propositions are like sets,\n"
"and their proofs are like their elements. \n"
"\n"
"## What's going on in this world? \n"
"\n"
"We're going to learn about manipulating propositions and proofs.\n"
"Fortunately, we don't need to learn a bunch of new tactics -- the\n"
"ones we just learnt (`exact`, `intro`, `have`, `apply`) will be perfect.\n"
"\n"
"The levels in proposition world are \"back to normal\", we're proving\n"
"theorems, not constructing elements of sets. Or are we?\n"
"\n"
"If you delete the sorry below then your local context will look like this:\n"
"\n"
"```\n"
"P Q : Prop,\n"
"p : P,\n"
"h : P → Q\n"
"⊢ Q\n"
"```\n"
"\n"
"In this situation, we have true/false statements $P$ and $Q$,\n"
"a proof $p$ of $P$, and $h$ is the hypothesis that $P\\implies Q$.\n"
"Our goal is to construct a proof of $Q$. It's clear what to do\n"
"*mathematically* to solve this goal, $P$ is true and $P$ implies $Q$\n"
"so $Q$ is true. But how to do it in Lean?\n"
"\n"
"Adopting a point of view wholly unfamiliar to many mathematicians,\n"
"Lean interprets the hypothesis $h$ as a function from proofs\n"
"of $P$ to proofs of $Q$, so the rather surprising approach\n"
"\n"
"`exact h(p),`\n"
"\n"
"works to close the goal.\n"
"\n"
"Note that `exact h(P),` (with a capital P) won't work;\n"
"this is a common error I see from beginners. \"We're trying to solve `P`\n"
"so it's exactly `P`\". The goal states the *theorem*, your job is to\n"
"construct the *proof*. $P$ is not a proof of $P$, it's $p$ that is a proof "
"of $P$. \n"
"\n"
"In Lean, Propositions, like sets, are types, and proofs, like elements of "
"sets, are terms.\n"
"\n"
"## Level 1: the `exact` tactic.\n"
msgstr ""

#: Proposition world level 1
msgid "If $P$ is true, and $P\\implies Q$ is also true, then $Q$ is true.\n"
msgstr ""

#: Proposition world level 2
msgid ""
"# Proposition world. \n"
"\n"
"## Level 2: `intro`.\n"
"\n"
"Let's prove an implication. Let $P$ be a true/false statement,\n"
"and let's prove that $P\\implies P$. If you delete the\n"
"`sorry` you will see that our goal is `P → P`. Constructing a term\n"
"of type `P → P` (which is what solving this goal *means*) in this\n"
"case amounts to proving that $P\\implies P$, and computer scientists\n"
"think of this as coming up with a function which sends proofs of $P$\n"
"to proofs of $P$.\n"
"\n"
"To define an implication $P\\implies Q$ we need to choose an arbitrary\n"
"proof $p : P$ of $P$ and then, perhaps using $p$, construct a proof\n"
"of $Q$.  The Lean way to say \"let's assume $P$ is true\" is `intro p`,\n"
"i.e., \"let's assume we have a proof of $P$\".\n"
"\n"
"## Note for worriers.\n"
"\n"
"Those of you who know\n"
"something about the subtle differences between truth and provability\n"
"discovered by Goedel -- these are not relevant here. Imagine we are\n"
"working in a fixed model of mathematics, and when I say \"proof\"\n"
"I actually mean \"truth in the model\", or \"proof in the metatheory\".\n"
"\n"
"## Rule of thumb: \n"
"\n"
"If your goal is to prove `P → Q` (i.e. that $P\\implies Q$)\n"
"then `intro p`, meaning \"assume $p$ is a proof of $P$\", will make "
"progress.\n"
"\n"
"To solve the goal below, you have to come up with a function from\n"
"`P` (thought of as the set of proofs of $P$!) to itself. Start with\n"
"\n"
"`intro p,`\n"
"\n"
"(i.e. \"let $p$ be a proof of $P$\") and note that our\n"
"local context now looks like this:\n"
"\n"
"```\n"
"P : Prop,\n"
"p : P\n"
"⊢ P\n"
"```\n"
"\n"
"Our job now is to construct a proof of $P$. But $p$ is a proof of $P$.\n"
"So\n"
"\n"
"`exact p,`\n"
"\n"
"will close the goal. Note that `exact P` will not work -- don't\n"
"confuse a true/false statement (which could be false!) with a proof.\n"
"We will stick with the convention of capital letters for propositions\n"
"and small letters for proofs.\n"
msgstr ""

#: Proposition world level 2
msgid "If $P$ is a proposition then $P\\implies P$.\n"
msgstr ""

#: Proposition world level 3
msgid ""
"# Proposition world. \n"
"\n"
"## Level 3: `have`.\n"
"\n"
"Say you have a whole bunch of propositions and implications between them,\n"
"and your goal is to build a certain proof of a certain proposition.\n"
"If it helps, you can build intermediate proofs of other propositions\n"
"along the way, using the `have` command. `have q : Q := ...` is the Lean "
"analogue\n"
"of saying \"We now see that we can prove $Q$, because...\"\n"
"in the middle of a proof.\n"
"It is often not logically necessary, but on the other hand\n"
"it is very convenient, for example it can save on notation, or\n"
"it can break proofs up into smaller steps.\n"
"\n"
"In the level below, we have a proof of $P$ and we want a proof\n"
"of $U$; during the proof we will construct proofs of\n"
"of some of the other propositions involved. The diagram of\n"
"propositions and implications looks like this pictorially:\n"
"\n"
"![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/"
"natural_number_game_images/implies_diag.jpg)\n"
"\n"
"and so it's clear how to deduce $U$ from $P$.\n"
"Indeed, we could solve this level in one move by typing\n"
"\n"
"`exact l(j(h(p))),`\n"
"\n"
"But let us instead stroll more lazily through the level.\n"
"We can start by using the `have` tactic to make a proof of $Q$:\n"
"\n"
"`have q := h(p),`\n"
"\n"
"and then we note that $j(q)$ is a proof of $T$:\n"
"\n"
"`have t : T := j(q),`\n"
"\n"
"(note how we explicitly told Lean what proposition we thought $t$ was\n"
"a proof of, with that `: T` thing before the `:=`) \n"
"and we could even define $u$ to be $l(t)$:\n"
"\n"
"`have u : U := l(t),`\n"
"\n"
"and then finish the level with\n"
"\n"
"`exact u,`\n"
"\n"
". \n"
msgstr ""

#: Proposition world level 3
msgid ""
"In the maze of logical implications above, if $P$ is true then so is $U$.\n"
msgstr ""

#: Proposition world level 3
msgid ""
"If you solved the level using `have`, then click on the last line of your "
"proof\n"
"(you do know you can move your cursor around with the arrow keys\n"
"and explore your proof, right?) and note that the local context at that "
"point\n"
"is in something like the following mess:\n"
"\n"
"```\n"
"P Q R S T U : Prop,\n"
"p : P,\n"
"h : P → Q,\n"
"i : Q → R,\n"
"j : Q → T,\n"
"k : S → T,\n"
"l : T → U,\n"
"q : Q,\n"
"t : T,\n"
"u : U\n"
"⊢ U\n"
"```\n"
"\n"
"It was already bad enough to start with, and we added three more\n"
"terms to it. In level 4 we will learn about the `apply` tactic\n"
"which solves the level using another technique, without leaving\n"
"so much junk behind.\n"
msgstr ""

#: Proposition world level 4
msgid ""
"\n"
"# Proposition world. \n"
"\n"
"## Level 4: `apply`.\n"
"\n"
"Let's do the same level again:\n"
"\n"
"![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/"
"natural_number_game_images/implies_diag.jpg)\n"
"\n"
"We are given a proof $p$ of $P$ and our goal is to find a proof of $U$, or\n"
"in other words to find a path through the maze that links $P$ to $U$.\n"
"In level 3 we solved this by using `have`s to move forward, from $P$\n"
"to $Q$ to $T$ to $U$. Using the `apply` tactic we can instead construct\n"
"the path backwards, moving from $U$ to $T$ to $Q$ to $P$.\n"
"\n"
"Our goal is to prove $U$. But $l:T\\implies U$ is\n"
"an implication which we are assuming, so it would suffice to prove $T$.\n"
"Tell Lean this by starting the proof below with\n"
"\n"
"`apply l,`\n"
"\n"
"and notice that our assumptions don't change but *the goal changes*\n"
"from `⊢ U` to `⊢ T`. \n"
"\n"
"Keep `apply`ing implications until your goal is `P`, and try not\n"
"to get lost! Now solve this goal\n"
"with `exact p`. Note: you will need to learn the difference between\n"
"`exact p` (which works) and `exact P` (which doesn't, because $P$ is\n"
"not a proof of $P$).\n"
msgstr ""

#: Proposition world level 4
msgid "We can solve a maze.\n"
msgstr ""

#: Proposition world level 5
msgid ""
"# Proposition world. \n"
"\n"
"## Level 5 : `P → (Q → P)`.\n"
"\n"
"In this level, our goal is to construct an implication, like in level 2.\n"
"\n"
"```\n"
"⊢ P → (Q → P)\n"
"```\n"
"\n"
"So $P$ and $Q$ are propositions, and our goal is to prove\n"
"that $P\\implies(Q\\implies P)$.\n"
"We don't know whether $P$, $Q$ are true or false, so initially\n"
"this seems like a bit of a tall order. But let's give it a go. Delete\n"
"the `sorry` and let's think about how to proceed.\n"
"\n"
"Our goal is `P → X` for some true/false statement $X$, and if our\n"
"goal is to construct an implication then we almost always want to use the\n"
"`intro` tactic from level 2, Lean's version of \"assume $P$\", or more "
"precisely\n"
"\"assume $p$ is a proof of $P$\". So let's start with\n"
"\n"
"`intro p,`\n"
"\n"
"and we then find ourselves in this state:\n"
"\n"
"```\n"
"P Q : Prop,\n"
"p : P\n"
"⊢ Q → P\n"
"```\n"
"\n"
"We now have a proof $p$ of $P$ and we are supposed to be constructing\n"
"a proof of $Q\\implies P$. So let's assume that $Q$ is true and try\n"
"and prove that $P$ is true. We assume $Q$ like this:\n"
"\n"
"`intro q,`\n"
"\n"
"and now we have to prove $P$, but have a proof handy:\n"
"\n"
"`exact p,`\n"
msgstr ""

#: Proposition world level 5
msgid ""
"For any propositions $P$ and $Q$, we always have\n"
"$P\\implies(Q\\implies P)$. \n"
msgstr ""

#: Proposition world level 5
msgid ""
"A mathematician would treat the proposition $P\\implies(Q\\implies P)$\n"
"as the same as the proposition $P\\land Q\\implies P$,\n"
"because to give a proof of either of these is just to give a method which "
"takes\n"
"a proof of $P$ and a proof of $Q$, and returns a proof of $P$. Thinking of "
"the\n"
"goal as $P\\land Q\\implies P$ we see why it is provable.\n"
"\n"
"## Did you notice?\n"
"\n"
"I wrote `P → (Q → P)` but Lean just writes `P → Q → P`. This is because\n"
"computer scientists adopt the convention that `→` is *right associative*,\n"
"which is a fancy way of saying \"when we write `P → Q → R`, we mean `P → (Q "
"→ R)`.\n"
"Mathematicians would never dream of writing something as ambiguous as\n"
"$P\\implies Q\\implies R$ (they are not really interested in proving "
"abstract\n"
"propositions, they would rather work with concrete ones such as Fermat's "
"Last Theorem),\n"
"so they do not have a convention for where the brackets go. It's important "
"to\n"
"remember Lean's convention though, or else you will get confused. If your "
"goal\n"
"is `P → Q → R` then you need to know whether `intro h` will create `h : P` "
"or `h : P → Q`. \n"
"Make sure you understand which one. \n"
msgstr ""

#: Proposition world level 6
msgid ""
"# Proposition world. \n"
"\n"
"## Level 6: `(P → (Q → R)) → ((P → Q) → (P → R))`.\n"
"\n"
"You can solve this level completely just using `intro`, `apply` and "
"`exact`,\n"
"but if you want to argue forwards instead of backwards then don't forget\n"
"that you can do things like `have j : Q → R := f p` if `f : P → (Q → R)`\n"
"and `p : P`. I recommend that you start with `intro f` rather than `intro "
"p`\n"
"because even though the goal starts `P → ...`, the brackets mean that\n"
"the goal is not the statement that `P` implies anything, it's the statement "
"that\n"
"$P\\implies (Q\\implies R)$ implies something. In fact I'd recommend that "
"you started\n"
"with `intros f h p`, which introduces three variables at once.\n"
"You then find that your your goal is `⊢ R`. If you try `have j : Q → R := f "
"p`\n"
"now then you can `apply j`. Alternatively you can `apply (f p)` directly.\n"
"What happens if you just try `apply f`? Can you figure out what just "
"happened? This is a little\n"
"`apply` easter egg. Why is it mathematically valid?\n"
msgstr ""

#: Proposition world level 6
msgid ""
"If $P$ and $Q$ and $R$ are true/false statements, then\n"
"$$(P\\implies(Q\\implies R))\\implies((P\\implies Q)\\implies(P\\implies R))."
"$$\n"
msgstr ""

#: Proposition world level 7
msgid ""
"# Function world. \n"
"\n"
"## Level 7: `(P → Q) → ((Q → R) → (P → R))` \n"
"\n"
"If you start with `intro hpq` and then `intro hqr`\n"
"the dust will clear a bit and the level will look like this:\n"
"```\n"
"P Q R : Prop,\n"
"hpq : P → Q,\n"
"hqr : Q → R\n"
"⊢ P → R\n"
"```\n"
"So this level is really about showing transitivity of $\\implies$,\n"
"if you like that sort of language.\n"
msgstr ""

#: Proposition world level 7
msgid "From $P\\implies Q$ and $Q\\implies R$ we can deduce $P\\implies R$.\n"
msgstr ""

#: Proposition world level 8
msgid ""
"# Proposition world. \n"
"\n"
"## Level 8 : `(P → Q) → (¬ Q → ¬ P)` \n"
"\n"
"There is a false proposition `false`, with no proof. It is\n"
"easy to check that $\\lnot Q$ is equivalent to $Q\\implies {\\tt false}$,\n"
"and in the natural number game we call this\n"
"\n"
"`not_iff_imp_false (P : Prop) : ¬ P ↔ (P → false)`\n"
"\n"
"So you can start the proof of the contrapositive below with\n"
"\n"
"`repeat {rw not_iff_imp_false},`\n"
"\n"
"to get rid of the two occurences of `¬`, and I'm sure you can\n"
"take it from there (note that we just added `not_iff_imp_false` to the\n"
"theorem statements in the menu on the left). At some point your goal might "
"be to prove `false`.\n"
"At that point I guess you must be proving something by contradiction.\n"
"Or are you? \n"
msgstr ""

#: Proposition world level 8
msgid ""
"If $P$ and $Q$ are propositions, and $P\\implies Q$, then\n"
"$\\lnot Q\\implies \\lnot P$. \n"
msgstr ""

#: Proposition world level 8
msgid ""
"## Technical note\n"
"\n"
"\n"
"All of that rewriting you did with `rw` in addition world\n"
"was rewriting hypothesis of the form `h : X = Y`, but\n"
"you can also `rw h` if `h : P ↔ Q` (because propositional\n"
"extensionality says that if $P\\iff Q$ then $P=Q$, and\n"
"mathematicians use this whether or not they notice.)\n"
msgstr ""

#: Proposition world level 9
msgid ""
"# Proposition world. \n"
"\n"
"## Level 9: a big maze. \n"
"\n"
"Lean's \"congruence closure\" tactic `cc` is good at mazes. You might want "
"to try it now.\n"
"Perhaps I should have mentioned it earlier.\n"
msgstr ""

#: Proposition world level 9
msgid "There is a way through the following maze.\n"
msgstr ""

#: Proposition world level 9
msgid ""
"Now move onto advanced proposition world, where you will see\n"
"how to prove goals such as `P ∧ Q` ($P$ and $Q$), `P ∨ Q` ($P$ or $Q$),\n"
"`P ↔ Q` ($P\\iff Q$).\n"
"You will need to learn five more tactics: `split`, `cases`,\n"
"`left`, `right`, and `exfalso`,\n"
"but they are all straightforward, and furthermore they are\n"
"essentially the last tactics you\n"
"need to learn in order to complete all the levels of the Natural Number "
"Game,\n"
"including all the 17 levels of Inequality World. \n"
msgstr ""

#: Proposition world level 9
msgid ""
"\n"
"## Summary:\n"
"\n"
"`cc` will solve certain \"logic\" goals.\n"
"\n"
"## Details\n"
"\n"
"`cc` is a \"congruence closure tactic\". In practice this means that it is\n"
"good at solving certain logic goals. It's worth trying if you think\n"
"that the goal could be solved using truth tables.\n"
msgstr ""

#: world_config
msgid "Advanced Proposition world"
msgstr ""

#: Advanced Proposition world level 1
msgid ""
"\n"
"# Advanced proposition world. \n"
"\n"
"In this world we will learn five key tactics needed to solve all the\n"
"levels of the Natural Number Game, namely `split`, `cases`, `left`, `right`, "
"and `exfalso`.\n"
"These, and `use` (which we'll get to in Inequality World) are all the\n"
"tactics you will need to beat all the levels of the game.\n"
"\n"
"## Level 1: the `split` tactic.\n"
"\n"
"The logical symbol `∧` means \"and\". If $P$ and $Q$ are propositions, then\n"
"$P\\land Q$ is the proposition \"$P$ and $Q$\". If your *goal* is `P ∧ Q` "
"then\n"
"you can make progress with the `split` tactic, which turns one goal `⊢ P ∧ "
"Q`\n"
"into two goals, namely `⊢ P` and `⊢ Q`. In the level below, after a "
"`split`,\n"
"you will be able to finish off the goals with the `exact` tactic.\n"
msgstr ""

#: Advanced Proposition world level 1
msgid "If $P$ and $Q$ are true, then $P\\land Q$ is true.\n"
msgstr ""

#: Advanced Proposition world level 1
msgid ""
"\n"
"## Summary:\n"
"\n"
"If the goal is `P ∧ Q` or `P ↔ Q` then `split` will break it into two "
"goals.\n"
"\n"
"## Details\n"
"\n"
"If `P Q : Prop` and the goal is `⊢ P ∧ Q`, then `split` will change it into\n"
"two goals, namely `⊢ P` and `⊢ Q`. \n"
"\n"
"If `P Q : Prop` and the goal is `⊢ P ↔ Q`, then `split` will change it into\n"
"two goals, namely `⊢ P → Q` and `⊢ Q → P`.  \n"
"\n"
"## Example:\n"
"\n"
"If your local context (the top right window) looks like this\n"
"```\n"
"a b : mynat,\n"
"⊢ a = b ↔ a + 3 = b + 3\n"
"```\n"
"\n"
"then after\n"
"\n"
"`split,`\n"
"\n"
"it will look like this:\n"
"\n"
"```\n"
"2 goals\n"
"a b : mynat\n"
"⊢ a = b → a + 3 = b + 3\n"
"\n"
"a b : mynat\n"
"⊢ a + 3 = b + 3 → a = b\n"
"\n"
msgstr ""

#: Advanced Proposition world level 2
msgid ""
"\n"
"# Advanced proposition world. \n"
"\n"
"## Level 2: the `cases` tactic.\n"
"\n"
"If `P ∧ Q` is in the goal, then we can make progress with `split`.\n"
"But what if `P ∧ Q` is a hypothesis? In this case, the `cases` tactic will "
"enable\n"
"us to extract proofs of `P` and `Q` from this hypothesis.\n"
"\n"
"The lemma below asks us to prove `P ∧ Q → Q ∧ P`, that is,\n"
"symmetry of the \"and\" relation. The obvious first move is\n"
"\n"
"`intro h,`\n"
"\n"
"because the goal is an implication and this tactic is guaranteed\n"
"to make progress. Now `h : P ∧ Q` is a hypothesis, and\n"
"\n"
"`cases h with p q,`\n"
"\n"
"will change `h`, the proof of `P ∧ Q`, into two proofs `p : P`\n"
"and `q : Q`. From there, `split` and `exact` will get you home.\n"
msgstr ""

#: Advanced Proposition world level 2
msgid ""
"If $P$ and $Q$ are true/false statements, then $P\\land Q\\implies Q\\land P"
"$. \n"
msgstr ""

#: Advanced Proposition world level 2
msgid ""
"\n"
"## Summary:\n"
"\n"
"`cases` is a tactic which works on hypotheses.\n"
"If `h : P ∧ Q` or `h : P ↔ Q` is a hypothesis then `cases h with h1 h2` will "
"remove `h`\n"
"from the list of hypotheses and replace it with the \"ingredients\" of `h`,\n"
"i.e. `h1 : P` and `h2 : Q`, or `h1 : P → Q` and `h2 : Q → P`. Also\n"
"works with `h : P ∨ Q` and `n : mynat`. \n"
"\n"
"## Details\n"
"\n"
"How does one prove `P ∧ Q`? The way to do it is to prove `P` and to\n"
"prove `Q`. There are hence two ingredients which go into a proof of\n"
"`P ∧ Q`, and the `cases` tactic extracts them. \n"
"\n"
"More precisely, if the local context contains\n"
"```\n"
"h : P ∧ Q`\n"
"```\n"
"\n"
"then after the tactic `cases h with p q,` the local context will\n"
"change to\n"
"```\n"
"p : P,\n"
"q : Q\n"
"```\n"
"and `h` will disappear. \n"
"\n"
"Similarly `h : P ↔ Q` is proved by proving `P → Q` and `Q → P`,\n"
"and `cases h with hpq hqp` will delete our assumption `h` and\n"
"replace it with\n"
"```\n"
"hpq : P → Q,\n"
"hqp : Q → P\n"
"```\n"
"\n"
"Be warned though -- `rw h` works with `h : P ↔ Q` (`rw` works with\n"
"`=` and `↔`), whereas you cannot rewrite with an implication.\n"
"\n"
"`cases` also works with hypotheses of the form `P ∨ Q` and even\n"
"with `n : mynat`. Here the situation is different however. \n"
"To prove `P ∨ Q` you need to give either a proof of `P` *or* a proof\n"
"of `Q`, so if `h : P ∨ Q` then `cases h with p q` will change one goal\n"
"into two, one with `p : P` and the other with `q : Q`. Similarly, each\n"
"natural is either `0` or `succ(d)` for `d` another natural, so if\n"
"`n : mynat` then `cases n with d` also turns one goal into two,\n"
"one with `n = 0` and the other with `d : mynat` and `n = succ(d)`.\n"
msgstr ""

#: Advanced Proposition world level 3
msgid ""
"\n"
"# Advanced proposition world. \n"
"\n"
"## Level 3: and_trans.\n"
msgstr ""

#: Advanced Proposition world level 3
msgid ""
"If $P$, $Q$ and $R$ are true/false statements, then $P\\land Q$ and\n"
"$Q\\land R$ together imply $P\\land R$.\n"
msgstr ""

#: Advanced Proposition world level 4
msgid ""
"\n"
"# Advanced proposition world. \n"
"\n"
"## Level 4: `iff_trans`.\n"
"\n"
"The mathematical statement $P\\iff Q$ is equivalent to $(P\\implies "
"Q)\\land(Q\\implies P)$. The `cases`\n"
"and `split` tactics work on hypotheses and goals (respectively) of the form "
"`P ↔ Q`. If you need\n"
"to write an `↔` arrow you can do so by typing `\\iff`, but you shouldn't "
"need to. After an initial\n"
"`intro h,` you can type `cases h with hpq hqp` to break `h : P ↔ Q` into its "
"constituent parts.\n"
msgstr ""

#: Advanced Proposition world level 4
msgid ""
"If $P$, $Q$ and $R$ are true/false statements, then\n"
"$P\\iff Q$ and $Q\\iff R$ together imply $P\\iff R$.\n"
msgstr ""

#: Advanced Proposition world level 5
msgid ""
"\n"
"# Advanced proposition world. \n"
"\n"
"## Level 5: `iff_trans` easter eggs.\n"
"\n"
"Let's try `iff_trans` again. Try proving it in other ways.\n"
"\n"
"### A trick.\n"
"\n"
"Instead of using `cases` on `h : P ↔ Q` you can just access the proofs of `P "
"→ Q` and `Q → P`\n"
"directly with `h.1` and `h.2`. So you can solve this level with\n"
"\n"
"```\n"
"intros hpq hqr, \n"
"split,\n"
"intro p,\n"
"apply hqr.1,\n"
"...\n"
"```\n"
"\n"
"### Another trick\n"
"\n"
"Instead of using `cases` on `h : P ↔ Q`, you can just `rw h`, and this will "
"change all `P`s to `Q`s\n"
"in the goal. You can use this to create a much shorter proof. Note that\n"
"this is an argument for *not* running the `cases` tactic on an iff "
"statement;\n"
"you cannot rewrite one-way implications, but you can rewrite two-way "
"implications.\n"
"\n"
"### Another trick\n"
"\n"
"`cc` works on this sort of goal too.\n"
msgstr ""

#: Advanced Proposition world level 5
msgid ""
"If $P$, $Q$ and $R$ are true/false statements, then `P ↔ Q` and `Q ↔ R` "
"together imply `P ↔ R`.\n"
msgstr ""

#: Advanced Proposition world level 6
msgid ""
"# Advanced proposition world. \n"
"\n"
"## Level 6: Or, and the `left` and `right` tactics.\n"
"\n"
"`P ∨ Q` means \"$P$ or $Q$\". So to prove it, you\n"
"need to choose one of `P` or `Q`, and prove that one.\n"
"If `⊢ P ∨ Q` is your goal, then `left` changes this\n"
"goal to `⊢ P`, and `right` changes it to `⊢ Q`.\n"
"Note that you can take a wrong turn here. Let's\n"
"start with trying to prove $Q\\implies (P\\lor Q)$.\n"
"After the `intro`, one of `left` and `right` leads\n"
"to an impossible goal, the other to an easy finish.\n"
msgstr ""

#: Advanced Proposition world level 6
msgid ""
"If $P$ and $Q$ are true/false statements, then\n"
"$$Q\\implies(P\\lor Q).$$ \n"
msgstr ""

#: Advanced Proposition world level 6
msgid ""
"\n"
"## Summary\n"
"\n"
"`left` and `right` work on the goal, and they change\n"
"`⊢ P ∨ Q` to `⊢ P` and `⊢ Q` respectively.\n"
"\n"
"## Details\n"
"\n"
"The tactics `left` and `right` work on a goal which is a type with\n"
"two constructors, the classic example being `P ∨ Q`. \n"
"To prove `P ∨ Q` it suffices to either prove `P` or prove `Q`,\n"
"and once you know which one you are going for you can change\n"
"the goal with `left` or `right` to the appropriate choice.\n"
msgstr ""

#: Advanced Proposition world level 7
msgid ""
"# Advanced proposition world. \n"
"\n"
"## Level 7: `or_symm`\n"
"\n"
"Proving that $(P\\lor Q)\\implies(Q\\lor P)$ involves an element of danger.\n"
"`intro h,` is the obvious start. But now,\n"
"even though the goal is an `∨` statement, both `left` and `right` put\n"
"you in a situation with an impossible goal. Fortunately, after `intro h,`\n"
"you can do `cases h with p q`. Then something new happens: because\n"
"there are two ways to prove `P ∨ Q` (namely, proving `P` or proving `Q`),\n"
"the `cases` tactic turns one goal into two, one for each case. You should\n"
"be able to make it home from there. \n"
msgstr ""

#: Advanced Proposition world level 7
msgid ""
"If $P$ and $Q$ are true/false statements, then\n"
"$$P\\lor Q\\implies Q\\lor P.$$ \n"
msgstr ""

#: Advanced Proposition world level 8
msgid ""
"# Advanced proposition world. \n"
"\n"
"## Level 8: `and_or_distrib_left`\n"
"\n"
"We know that `x(y+z)=xy+xz` for numbers, and this\n"
"is called distributivity of multiplication over addition.\n"
"The same is true for `∧` and `∨` -- in fact `∧` distributes\n"
"over `∨` and `∨` distributes over `∧`. Let's prove one of these.\n"
msgstr ""

#: Advanced Proposition world level 8
msgid ""
"If $P$. $Q$ and $R$ are true/false statements, then\n"
"$$P\\land(Q\\lor R)\\iff(P\\land Q)\\lor (P\\land R).$$ \n"
msgstr ""

#: Advanced Proposition world level 8
msgid ""
"## Pro tip\n"
"\n"
"Did you spot the import? What do you think it does?\n"
"\n"
"If you follow the instructions at\n"
"<a href=\"https://github.com/leanprover-community/mathlib#installation\" "
"target=\"blank\">the mathlib github page</a>\n"
"you will be able to install Lean and mathlib on your own system, and then "
"you can create a new project\n"
"and experiment with such imports yourself.\n"
msgstr ""

#: Advanced Proposition world level 9
msgid "import tactic.tauto -- useful high-powered tactic"
msgstr ""

#: Advanced Proposition world level 9
msgid ""
"# Advanced proposition world. \n"
"\n"
"You already know enough to embark on advanced addition world. But here are "
"just a couple\n"
"more things.\n"
"\n"
"## Level 9: `exfalso` and proof by contradiction. \n"
"\n"
"It's certainly true that $P\\land(\\lnot P)\\implies Q$ for any propositions "
"$P$\n"
"and $Q$, because the left hand side of the implication is false. But how do\n"
"we prove that `false` implies any proposition $Q$? A cheap way of doing it "
"in\n"
"Lean is using the `exfalso` tactic, which changes any goal at all to "
"`false`. \n"
"You might think this is a step backwards, but if you have a hypothesis `h : "
"¬ P`\n"
"then after `rw not_iff_imp_false at h,` you can `apply h,` to make "
"progress. \n"
"Try solving this level without using `cc` or `tauto`, but using `exfalso` "
"instead.\n"
"\n"
msgstr ""

#: Advanced Proposition world level 9
msgid ""
"If $P$ and $Q$ are true/false statements, then\n"
"$$(P\\land(\\lnot P))\\implies Q.$$\n"
msgstr ""

#: Advanced Proposition world level 9
msgid ""
"## Pro tip.\n"
"\n"
"`¬ P` is actually `P → false` *by definition*. Try\n"
"commenting out `rw not_iff_imp_false at ...` by putting two minus signs `--"
"`\n"
"before the `rw`. Does it still compile?\n"
msgstr ""

#: Advanced Proposition world level 9
msgid ""
"\n"
"## Summary\n"
"\n"
"`exfalso` changes your goal to `false`. \n"
"\n"
"## Details\n"
"\n"
"We know that `false` implies `P` for any proposition `P`, and so if your "
"goal is `P`\n"
"then you should be able to `apply` `false → P` and reduce your goal to "
"`false`. This\n"
"is what the `exfalso` tactic does. The theorem that `false → P` is called "
"`false.elim`\n"
"so one can achieve the same effect with `apply false.elim`. \n"
"\n"
"This tactic can be used in a proof by contradiction, where the hypotheses "
"are enough\n"
"to deduce a contradiction and the goal happens to be some random statement "
"(possibly\n"
"a false one) which you just want to simplify to `false`.\n"
msgstr ""

#: Advanced Proposition world level 10
msgid ""
"local attribute [instance, priority 10] classical.prop_decidable -- we are "
"mathematicians"
msgstr ""

#: Advanced Proposition world level 10
msgid ""
"# Advanced proposition world.\n"
"\n"
"\n"
"\n"
"## Level 10: the law of the excluded middle.\n"
"\n"
"We proved earlier that `(P → Q) → (¬ Q → ¬ P)`. The converse,\n"
"that `(¬ Q → ¬ P) → (P → Q)` is certainly true, but trying to prove\n"
"it using what we've learnt so far is impossible (because it is not provable "
"in\n"
"constructive logic). For example, after\n"
"\n"
"```\n"
"intro h,\n"
"intro p,\n"
"repeat {rw not_iff_imp_false at h},\n"
"```\n"
"\n"
"in the below, you are left with\n"
"```\n"
"P Q : Prop,\n"
"h : (Q → false) → P → false\n"
"p : P\n"
"⊢ Q\n"
"```\n"
"\n"
"The tools you have are not sufficient to continue. But you can just\n"
"prove this, and any other basic lemmas of this form like `¬ ¬ P → P`,\n"
"using the `by_cases` tactic. Instead of starting with all the `intro`s,\n"
"try this instead:\n"
"\n"
"`by_cases p : P; by_cases q : Q,`\n"
"\n"
"**Note the semicolon**! It means \"do the next tactic to all the goals, not "
"just the top one\".\n"
"After it, there are four goals, one for each of the four possibilities "
"PQ=TT, TF, FT, FF.\n"
"You can see that `p` is a proof of `P` in some of the goals, and a proof of "
"`¬ P` in others.\n"
"Similar comments apply to `q`. \n"
"\n"
"`repeat {cc}` then finishes the job.\n"
"\n"
"This approach assumed that `P ∨ ¬ P` was true; the `by_cases` tactic just "
"does `cases` on\n"
"this result. This is called the law of the excluded middle, and it cannot be "
"proved just\n"
"using tactics such as `intro` and `apply`.\n"
"\n"
msgstr ""

#: Advanced Proposition world level 10
msgid ""
"If $P$ and $Q$ are true/false statements, then\n"
"$$(\\lnot Q\\implies \\lnot P)\\implies(P\\implies Q).$$ \n"
msgstr ""

#: Advanced Proposition world level 10
msgid ""
"OK that's enough logic -- now perhaps it's time to go on to Advanced "
"Addition World!\n"
"Get to it via the main menu.\n"
msgstr ""

#: Advanced Proposition world level 10
msgid ""
"## Pro tip\n"
"\n"
"In fact the tactic `tauto!` just kills this goal (and many other logic "
"goals) immediately.\n"
msgstr ""

#: Advanced Proposition world level 10
msgid ""
"\n"
"## Summary\n"
"\n"
"`by_cases h : P` does a cases split on whether `P` is true or false.\n"
"\n"
"## Details\n"
"\n"
"Some logic goals cannot be proved with `intro` and `apply` and `exact`.\n"
"The simplest example is the law of the excluded middle `¬ ¬ P → P`.\n"
"You can prove this using truth tables but not with `intro`, `apply` etc.\n"
"To do a truth table proof, the tactic `by_cases h : P` will turn a goal of\n"
"`⊢ ¬ ¬ P → P` into two goals\n"
"\n"
"```\n"
"P : Prop,\n"
"h : P\n"
"⊢ ¬¬P → P\n"
"\n"
"P : Prop,\n"
"h : ¬P\n"
"⊢ ¬¬P → P\n"
"```\n"
"\n"
"Each of these can now be proved using `intro`, `apply`, `exact` and "
"`exfalso`.\n"
"Remember though that in these simple logic cases, high-powered logic\n"
"tactics like `cc` and `tauto!` will just prove everything.\n"
"\n"
"\n"
"\n"
msgstr ""

#: Advanced Proposition world level 10
msgid ""
"\n"
"## Summary\n"
"\n"
"The `tauto` tactic (and its variant `tauto!`) will close various logic\n"
"goals.\n"
"\n"
"## Details\n"
"\n"
"`tauto` is an all-purpose logic tactic which will try to solve goals using "
"pure\n"
"logical reasoning -- for example it will close the following goal:\n"
"\n"
"```\n"
"P Q : Prop,\n"
"hP : P,\n"
"hQ : Q\n"
"⊢ P ∧ Q\n"
"```\n"
"\n"
"`tauto` is supposed to only use constructive logic, but its big brother "
"`tauto!` uses classical logic\n"
"and hence closes more goals.\n"
msgstr ""

#: world_config
msgid "Advanced Addition world"
msgstr ""

#: Advanced Addition world level 1
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 1: `succ_inj`. A function.\n"
"\n"
"Peano's original collection of axioms for the natural numbers contained two "
"further\n"
"assumptions, which have not yet been mentioned in the game:\n"
"\n"
"```\n"
"succ_inj {a b : mynat} :\n"
"  succ(a) = succ(b) → a = b\n"
"\n"
"zero_ne_succ (a : mynat) :\n"
"  zero ≠ succ(a)\n"
" ```\n"
"\n"
"The reason they have not been used yet is that they are both implications,\n"
"that is,\n"
"of the form $P\\implies Q$. This is clear for `succ_inj a b`, which\n"
"says that for all $a$ and $b$ we have $succ(a)=succ(b)\\implies a=b$.\n"
"For `zero_ne_succ` the trick is that $X\\ne Y$ is *defined to mean*\n"
"$X = Y\\implies{\\tt false}$. If you have played through Proposition world,\n"
"you now have the required Lean skills (i.e., you know the required\n"
"tactics) to work with these implications.\n"
"Let's finally learn how to use `succ_inj`. You should know a couple\n"
"of ways to prove the below -- one directly using an `exact`,\n"
"and one which uses an `apply` first. But either way you'll need to use "
"`succ_inj`.\n"
msgstr ""

#: Advanced Addition world level 1
msgid ""
"For all naturals $a$ and $b$, if we assume $succ(a)=succ(b)$, then we can\n"
"deduce $a=b$. \n"
msgstr ""

#: Advanced Addition world level 1
msgid ""
"## Important thing.\n"
"\n"
"You can rewrite proofs of *equalities*. If `h : A = B` then `rw h` changes "
"`A`s to `B`s.\n"
"But you *cannot rewrite proofs of implications*. `rw succ_inj` will *never "
"work*\n"
"because `succ_inj` isn't of the form $A = B$, it's of the form $A\\implies B"
"$. This is one\n"
"of the most common mistakes I see from beginners. $\\implies$ and $=$ are "
"*two different things*\n"
"and you need to be clear about which one you are using.\n"
msgstr ""

#: Advanced Addition world level 2
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 2: `succ_succ_inj`.\n"
msgstr ""

#: Advanced Addition world level 2
msgid ""
"In the below theorem, we need to apply `succ_inj` twice. Once to prove\n"
"$succ(succ(a))=succ(succ(b))\\implies succ(a)=succ(b)$, and then again\n"
"to prove $succ(a)=succ(b)\\implies a=b$. However `succ(a)=succ(b)` is\n"
"nowhere to be found, it's neither an assumption or a goal when we start\n"
"this level. You can make it with `have` or you can use `apply`.\n"
msgstr ""

#: Advanced Addition world level 2
msgid ""
"For all naturals $a$ and $b$, if we assume $succ(succ(a))=succ(succ(b))$, "
"then we can\n"
"deduce $a=b$. \n"
msgstr ""

#: Advanced Addition world level 2
msgid ""
"## Sample solutions to this level. \n"
"\n"
"Make sure you understand them all. And remember that `rw` should not be "
"used\n"
"with `succ_inj` -- `rw` works only with equalities or `↔` statements,\n"
"not implications or functions.\n"
"\n"
msgstr ""

#: Advanced Addition world level 3
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 3: `succ_eq_succ_of_eq`.\n"
msgstr ""

#: Advanced Addition world level 3
msgid ""
"We are going to prove something completely obvious: if $a=b$ then\n"
"$succ(a)=succ(b)$. This is *not* `succ_inj`!\n"
"This is trivial -- we can just rewrite our proof of `a=b`.\n"
"But how do we get to that proof? Use the `intro` tactic.\n"
msgstr ""

#: Advanced Addition world level 3
msgid "For all naturals $a$ and $b$, $a=b\\implies succ(a)=succ(b)$. \n"
msgstr ""

#: Advanced Addition world level 4
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 4: `eq_iff_succ_eq_succ`\n"
"\n"
"Here is an `iff` goal. You can split it into two goals (the implications in "
"both\n"
"directions) using the `split` tactic, which is how you're going to have to "
"start.\n"
"\n"
"`split,`\n"
"\n"
"Now you have two goals. The first is exactly `succ_inj` so you can close\n"
"it with\n"
"\n"
"`exact succ_inj,`\n"
"\n"
"and the second one you could solve by looking up the name of the theorem\n"
"you proved in the last level and doing `exact <that name>`, or "
"alternatively\n"
"you could get some more `intro` practice and seeing if you can prove it\n"
"using `intro`, `rw` and `refl`.\n"
msgstr ""

#: Advanced Addition world level 4
msgid ""
"Two natural numbers are equal if and only if their successors are equal.\n"
msgstr ""

#: Advanced Addition world level 5
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 5: `add_right_cancel`\n"
"\n"
"The theorem `add_right_cancel` is the theorem that you can cancel on the "
"right\n"
"when you're doing addition -- if `a + t = b + t` then `a = b`. After `intro "
"h`\n"
"I'd recommend induction on `t`. Don't forget that `rw add_zero at h` can be "
"used\n"
"to do rewriting of hypotheses rather than the goal.\n"
msgstr ""

#: Advanced Addition world level 5
msgid ""
"On the set of natural numbers, addition has the right cancellation "
"property.\n"
"In other words, if there are natural numbers $a, b$ and $c$ such that\n"
"$$ a + t = b + t, $$\n"
"then we have $a = b$.\n"
msgstr ""

#: Advanced Addition world level 6
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 6: `add_left_cancel`\n"
"\n"
"The theorem `add_left_cancel` is the theorem that you can cancel on the "
"left\n"
"when you're doing addition -- if `t + a = t + b` then `a = b`. \n"
"There is a three-line proof which ends in `exact add_right_cancel a t b` (or "
"even\n"
"`exact add_right_cancel _ _ _`); this\n"
"strategy involves changing the goal to the statement of `add_right_cancel` "
"somehow.\n"
"\n"
"\n"
msgstr ""

#: Advanced Addition world level 6
msgid ""
"On the set of natural numbers, addition has the left cancellation property.\n"
"In other words, if there are natural numbers $a, b$ and $t$ such that\n"
"$$ t + a = t + b, $$\n"
"then we have $a = b$.\n"
msgstr ""

#: Advanced Addition world level 7
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 7: `add_right_cancel_iff`\n"
"\n"
"It's sometimes convenient to have the \"if and only if\" version\n"
"of theorems like `add_right_cancel`. Remember that you can use `split`\n"
"to split an `↔` goal into the `→` goal and the `←` goal.\n"
"\n"
"## Pro tip:\n"
"\n"
"`exact add_right_cancel _ _ _` means \"let Lean figure out the missing inputs"
"\"\n"
msgstr ""

#: Advanced Addition world level 7
msgid ""
"For all naturals $a$, $b$ and $t$, \n"
"$$ a + t = b + t\\iff a=b. $$\n"
msgstr ""

#: Advanced Addition world level 8
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 8: `eq_zero_of_add_right_eq_self`\n"
"\n"
"The lemma you're about to prove will be useful when we want to prove that $"
"\\leq$ is antisymmetric.\n"
"There are some wrong paths that you can take with this one.\n"
msgstr ""

#: Advanced Addition world level 8
msgid ""
"If $a$ and $b$ are natural numbers such that \n"
"$$ a + b = a, $$\n"
"then $b = 0$.\n"
msgstr ""

#: Advanced Addition world level 9
msgid ""
"\n"
"## Summary\n"
"\n"
"`symmetry` turns goals of the form `⊢ A = B` to `⊢ B = A`.\n"
"Also works with `≠`. Also works on hypotheses: if `h : a ≠ b`\n"
"then `symmetry at h` gives `h : b ≠ a`.\n"
"\n"
"## Details\n"
"\n"
"`symmetry` works on both goals and hypotheses. By default it\n"
"works on the goal. It will turn a goal of the form `⊢ A = B`\n"
"to `⊢ B = A`. More generally it will work with any symmetric\n"
"binary relation (for example `≠`, or more generally any\n"
"binary relation whose proof of symmetry has been tagged\n"
"with the `symm` attribute).\n"
"\n"
"To get `symmetry` working on a hypothesis, use `symmetry at h`.\n"
"\n"
"## Examples\n"
"\n"
"If the tactic state is\n"
"```\n"
"h : a = b\n"
"⊢ c ≠ d\n"
"```\n"
"\n"
"then `symmetry` changes the goal to `⊢ d ≠ c` and\n"
"`symmetry at h` changes `h` to `h : b = a`.\n"
msgstr ""

#: Advanced Addition world level 9
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 9: `succ_ne_zero`\n"
"\n"
"Levels 9 to 13 introduce the last axiom of Peano, namely\n"
"that $0\\not=\\operatorname{succ}(a)$. The proof of this is called "
"`zero_ne_succ a`. \n"
"\n"
"`zero_ne_succ (a : mynat) : 0 ≠ succ(a)`\n"
"\n"
"The `symmetry` tactic will turn any goal of the form `R x y` into `R y x`,\n"
"if `R` is a symmetric binary relation (for example `=` or `≠`).\n"
"In particular, you can prove `succ_ne_zero` below by first using\n"
"`symmetry` and then `exact zero_ne_succ a`. \n"
msgstr ""

#: Advanced Addition world level 9
msgid "Zero is not the successor of any natural number.\n"
msgstr ""

#: Advanced Addition world level 10
msgid ""
"# Advanced Addition World\n"
"\n"
"## Level 10: `add_left_eq_zero`\n"
"\n"
"## Important: the definition of `≠`\n"
"\n"
"In Lean, `a ≠ b` is *defined to mean* `(a = b) → false`. \n"
"This means that if you see `a ≠ b` you can *literally treat\n"
"it as saying* `(a = b) → false`. Computer scientists would\n"
"say that these two terms are *definitionally equal*. \n"
"\n"
"The following lemma, $a+b=0\\implies b=0$, will be useful in inequality "
"world.\n"
"Let me go through the proof, because it introduces several new\n"
"concepts: \n"
"\n"
"* `cases b`, where `b : mynat`\n"
"* `exfalso`\n"
"* `apply succ_ne_zero`\n"
"\n"
"We're going to prove $a+b=0\\implies b=0$. Here is the\n"
"strategy. Each natural number is either `0` or `succ(d)` for\n"
"some other natural number `d`. So we can start the proof\n"
"with \n"
"\n"
"`cases b with d,`\n"
"\n"
"and then we have two goals, the case `b = 0` (which you can solve easily)\n"
"and the case `b = succ(d)`, which looks like this:\n"
"\n"
"```\n"
"a d : mynat,\n"
"H : a + succ d = 0\n"
"⊢ succ d = 0\n"
"```\n"
"\n"
"Our goal is impossible to prove. However our hypothesis `H`\n"
"is also impossible, meaning that we still have a chance!\n"
"First let's see why `H` is impossible. We can\n"
"\n"
"`rw add_succ at H,`\n"
"\n"
"to turn `H` into `H : succ (a + d) = 0`. Because\n"
"`succ_ne_zero (a + d)` is a proof that `succ (a + d) ≠ 0`,\n"
"it is also a proof of the implication `succ (a + d) = 0 → false`.\n"
"Hence `succ_ne_zero (a + d) H` is a proof of `false`!\n"
"Unfortunately our goal is not `false`, it's a generic\n"
"false statement. \n"
"\n"
"Recall however that the `exfalso` command turns any goal into `false`\n"
"(it's logically OK because `false` implies every proposition, true or "
"false).\n"
"You can probably take it from here.\n"
msgstr ""

#: Advanced Addition world level 10
msgid ""
"If $a$ and $b$ are natural numbers such that \n"
"$$ a + b = 0, $$\n"
"then $b = 0$.\n"
msgstr ""

#: Advanced Addition world level 11
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 11: `add_right_eq_zero`\n"
"\n"
"We just proved `add_left_eq_zero (a b : mynat) : a + b = 0 → b = 0`.\n"
"Hopefully `add_right_eq_zero` shouldn't be too hard now.\n"
msgstr ""

#: Advanced Addition world level 11
msgid ""
"If $a$ and $b$ are natural numbers such that \n"
"$$ a + b = 0, $$\n"
"then $a = 0$.\n"
msgstr ""

#: Advanced Addition world level 12
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 12: `add_one_eq_succ`\n"
"\n"
"We have\n"
"\n"
"  * `succ_eq_add_one (n : mynat) : succ n = n + 1`\n"
"\n"
"but sometimes the other way is also convenient.\n"
msgstr ""

#: Advanced Addition world level 12
msgid ""
"For any natural number $d$, we have\n"
"$$ d+1 = \\operatorname{succ}(d). $$\n"
msgstr ""

#: Advanced Addition world level 13
msgid ""
"\n"
"# Advanced Addition World\n"
"\n"
"## Level 13: `ne_succ_self`\n"
"\n"
"The last level in Advanced Addition World is the statement\n"
"that $n\\not=\\operatorname{succ}(n)$. When you've done this\n"
"you've completed Advanced Addition World and can move on\n"
"to Advanced Multiplication World (after first doing\n"
"Multiplication World, if you didn't do it already). \n"
msgstr ""

#: Advanced Addition world level 13
msgid ""
"For any natural number $n$, we have\n"
"$$ n \\neq \\operatorname{succ}(n). $$\n"
msgstr ""

#: world_config
msgid "Advanced Multiplication world"
msgstr ""

#: Advanced Multiplication world level 1
msgid ""
"# Advanced Multiplication World\n"
"\n"
"## Level 1: `mul_pos`\n"
"\n"
"Welcome to Advanced Multiplication World! Before attempting this\n"
"world you should have completed seven other worlds, including\n"
"Multiplication World and Advanced Addition World. There are four\n"
"levels in this world.\n"
"\n"
"Recall that if `b : mynat` is a hypothesis and you do `cases b with n`,\n"
"your one goal will split into two goals, \n"
"namely the cases `b = 0` and `b = succ(n)`. So `cases` here is like\n"
"a weaker version of induction (you don't get the inductive hypothesis).\n"
"\n"
"## Tricks\n"
"\n"
"1) if your goal is `⊢ X ≠ Y` then `intro h` will give you `h : X = Y` and\n"
"a goal of `⊢ false`. This is because `X ≠ Y` *means* `(X = Y) → false`.\n"
"Conversely if your goal is `false` and you have `h : X ≠ Y` as a hypothesis\n"
"then `apply h` will turn the goal into `X = Y`.\n"
"\n"
"2) if `hab : succ (3 * x + 2 * y + 1) = 0` is a hypothesis and your goal is "
"`⊢ false`,\n"
"then `exact succ_ne_zero _ hab` will solve the goal, because Lean will "
"figure\n"
"out that `_` is supposed to be `3 * x + 2 * y + 1`.\n"
"\n"
msgstr ""

#: Advanced Multiplication world level 1
msgid "The product of two non-zero natural numbers is non-zero.\n"
msgstr ""

#: Advanced Multiplication world level 2
msgid ""
"# Advanced Multiplication World\n"
"\n"
"## Level 2: `eq_zero_or_eq_zero_of_mul_eq_zero`\n"
"\n"
"A variant on the previous level.\n"
msgstr ""

#: Advanced Multiplication world level 2
msgid "If $ab = 0$, then at least one of $a$ or $b$ is equal to zero.\n"
msgstr ""

#: Advanced Multiplication world level 3
msgid ""
"# Advanced Multiplication World\n"
"\n"
"## Level 3: `mul_eq_zero_iff`\n"
"\n"
"Now you have `eq_zero_or_eq_zero_of_mul_eq_zero` this is pretty "
"straightforward.\n"
msgstr ""

#: Advanced Multiplication world level 3
msgid "$ab = 0$, if and only if at least one of $a$ or $b$ is equal to zero.\n"
msgstr ""

#: Advanced Multiplication world level 4
msgid ""
"# Advanced Multiplication World\n"
"\n"
"## Level 4: `mul_left_cancel`\n"
"\n"
"This is the last of the bonus multiplication levels.\n"
"`mul_left_cancel` will be useful in inequality world.\n"
"\n"
"People find this level hard. I have probably had more questions about this\n"
"level than all the other levels put together, in fact. Many levels in this\n"
"game can just be solved by \"running at it\" -- do induction on one of the\n"
"variables, keep your head, and you're done. In fact, if you like a "
"challenge,\n"
"it might be instructive if you stop reading after the end of this paragraph "
"and try solving this level now by induction,\n"
"seeing the trouble you run into, and reading the rest of these comments "
"afterwards. This level\n"
"has a sting in the tail. If you are a competent mathematician, try\n"
"and figure out what is going on. Write down a maths proof of the\n"
"theorem in this level. Exactly what statement do you want to prove\n"
"by induction? It is subtle.\n"
"\n"
"Ok so here are some spoilers. The problem with naively running at it, is "
"that if you try induction on,\n"
"say, $c$, then you are imagining a and b as fixed, and your inductive\n"
"hypothesis $P(c)$ is $ab=ac \\implies b=c$. So for your inductive step\n"
"you will be able to assume $ab=ad \\implies b=d$ and your goal will\n"
"be to show $ab=a(d+1) \\implies b=d+1$. When you also assume $ab=a(d+1)$\n"
"you will realise that your inductive hypothesis is *useless*, because\n"
"$ab=ad$ is not true! The statement $P(c)$ (with $a$ and $b$ regarded\n"
"as constants) is not provable by induction.\n"
"\n"
"What you *can* prove by induction is the following *stronger* statement.\n"
"Imagine $a\\not=0$ as fixed, and then prove \"for all $b$, if $ab=ac$ then "
"$b=c$\"\n"
"by induction on $c$. This gives us the extra flexibility we require.\n"
"Note that we are quantifying over all $b$ in the inductive hypothesis -- it\n"
"is essential that $b$ is not fixed. \n"
"\n"
"You can do this in two ways in Lean -- before you start the induction\n"
"you can write `revert b,`. The `revert` tactic is the opposite of the "
"`intro`\n"
"tactic; it replaces the `b` in the hypotheses with \"for all $b$\" in the "
"goal.\n"
"\n"
"Alternatively, you can write `induction c with d hd\n"
"generalizing b` as the first line of the proof. \n"
"\n"
"If you do not modify your technique in this way, then this level seems\n"
"to be impossible (judging by the comments I've had about it!)\n"
msgstr ""

#: Advanced Multiplication world level 4
msgid ""
"If $a \\neq 0$, $b$ and $c$ are natural numbers such that\n"
"$ ab = ac, $\n"
"then $b = c$.\n"
msgstr ""

#: Advanced Multiplication world level 4
msgid "You should now be ready for inequality world.\n"
msgstr ""

#: Advanced Multiplication world level 4
msgid ""
"\n"
"## Summary\n"
"\n"
"`revert x` is the opposite to `intro x`.\n"
"\n"
"## Details\n"
"\n"
"If the tactic state looks like this\n"
"\n"
"```\n"
"P Q : Prop,\n"
"h : P\n"
"⊢ Q\n"
"```\n"
"\n"
"then `revert h` will change it to\n"
"\n"
"```\n"
"P Q : Prop\n"
"⊢ P → Q\n"
"```\n"
"\n"
"`revert` also works with things like natural numbers: if\n"
"the tactic state looks like this\n"
"\n"
"```\n"
"m : mynat\n"
"⊢ m + 1 = succ m\n"
"```\n"
"\n"
"then `revert m` will turn it into\n"
"\n"
"```\n"
"⊢ ∀ (m : mynat), m + 1 = mynat.succ m\n"
"```\n"
"\n"
msgstr ""

#: world_config
msgid "Inequality world"
msgstr ""

#: Inequality world level 1
msgid "import mynat.le -- import definition of ≤"
msgstr ""

#: Inequality world level 1
msgid ""
"## Summary\n"
"\n"
"`use` works on the goal. If your goal is `⊢ ∃ c : mynat, 1 + x = x + c`\n"
"then `use 1` will turn the goal into `⊢ 1 + x = x + 1`, and the rather\n"
"more unwise `use 0` will turn it into the impossible-to-prove\n"
"`⊢ 1 + x = x + 0`.\n"
"\n"
"## Details\n"
"\n"
"`use` is a tactic which works on goals of the form `⊢ ∃ c, P(c)` where\n"
"`P(c)` is some proposition which depends on `c`. With a goal of this\n"
"form, `use 0` will turn the goal into `⊢ P(0)`, `use x + y` (assuming\n"
"`x` and `y` are natural numbers in your local context) will turn\n"
"the goal into `P(x + y)` and so on.\n"
msgstr ""

#: Inequality world level 1
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"A new import, giving us a new definition. If `a` and `b` are naturals,\n"
"`a ≤ b` is *defined* to mean\n"
"\n"
"`∃ (c : mynat), b = a + c`\n"
"\n"
"The upside-down E means \"there exists\". So in words, $a\\le b$\n"
"if and only if there exists a natural $c$ such that $b=a+c$. \n"
"\n"
"If you really want to change an `a ≤ b` to `∃ c, b = a + c` then\n"
"you can do so with `rw le_iff_exists_add`:\n"
"\n"
"```\n"
"le_iff_exists_add (a b : mynat) :\n"
"  a ≤ b ↔ ∃ (c : mynat), b = a + c\n"
"```\n"
"\n"
"But because `a ≤ b` is *defined as* `∃ (c : mynat), b = a + c`, you\n"
"do not need to `rw le_iff_exists_add`, you can just pretend when you see `a "
"≤ b`\n"
"that it says `∃ (c : mynat), b = a + c`. You will see a concrete\n"
"example of this below.\n"
"\n"
"A new construction like `∃` means that we need to learn how to manipulate "
"it.\n"
"There are two situations. Firstly we need to know how to solve a goal\n"
"of the form `⊢ ∃ c, ...`, and secondly we need to know how to use a "
"hypothesis\n"
"of the form `∃ c, ...`. \n"
"\n"
"## Level 1: the `use` tactic.\n"
"\n"
"The goal below is to prove $x\\le 1+x$ for any natural number $x$. \n"
"First let's turn the goal explicitly into an existence problem with\n"
"\n"
"`rw le_iff_exists_add,`\n"
"\n"
"and now the goal has become `∃ c : mynat, 1 + x = x + c`. Clearly\n"
"this statement is true, and the proof is that $c=1$ will work (we also\n"
"need the fact that addition is commutative, but we proved that a long\n"
"time ago). How do we make progress with this goal?\n"
"\n"
"The `use` tactic can be used on goals of the form `∃ c, ...`. The idea\n"
"is that we choose which natural number we want to use, and then we use it.\n"
"So try\n"
"\n"
"`use 1,`\n"
"\n"
"and now the goal becomes `⊢ 1 + x = x + 1`. You can solve this by\n"
"`exact add_comm 1 x`, or if you are lazy you can just use the `ring` "
"tactic,\n"
"which is a powerful AI which will solve any equality in algebra which can\n"
"be proved using the standard rules of addition and multiplication. Now\n"
"look at your proof. We're going to remove a line.\n"
"\n"
"## Important\n"
"\n"
"An important time-saver here is to note that because `a ≤ b` is *defined*\n"
"as `∃ c : mynat, b = a + c`, you *do not need to write* `rw "
"le_iff_exists_add`.\n"
"The `use` tactic will work directly on a goal of the form `a ≤ b`. Just\n"
"use the difference `b - a` (note that we have not defined subtraction so\n"
"this does not formally make sense, but you can do the calculation in your "
"head).\n"
"If you have written `rw le_iff_exists_add` below, then just put two minus "
"signs `--`\n"
"before it and comment it out. See that the proof still compiles.\n"
msgstr ""

#: Inequality world level 1
msgid "If $x$ is a natural number, then $x\\le 1+x$.\n"
msgstr ""

#: Inequality world level 2
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"Here's a nice easy one.\n"
"\n"
"## Level 2: le_refl \n"
msgstr ""

#: Inequality world level 2
msgid ""
"The $\\le$ relation is reflexive. In other words, if $x$ is a natural "
"number,\n"
"then $x\\le x$.\n"
msgstr ""

#: Inequality world level 2
msgid ""
"## Upgrading the `refl` tactic \n"
"\n"
"Now with the following incantation (NB thanks to master wizard Reid Barton\n"
"for correcting my spell)...\n"
msgstr ""

#: Inequality world level 2
msgid ""
"...we find that the `refl` tactic will close all goals\n"
"of the form `a ≤ a` as well as all goals of the form `a = a`.\n"
msgstr ""

#: Inequality world level 2
msgid ""
"## Pro tip\n"
"\n"
"Did you skip `rw le_iff_exists_add` in your proof of `le_refl` above?\n"
"Instead of `rw add_zero` or `ring` or `exact add_zero x` at the end there,\n"
"what happens if you just try `refl`? The *definition* of `x + 0` is `x`,\n"
"so you don't need to `rw add_zero` either! The proof\n"
"\n"
"```\n"
"use 0,\n"
"refl,\n"
"```\n"
"\n"
"works.\n"
"\n"
"The same remarks are true of\n"
"`add_succ`, `mul_zero`, `mul_succ`, `pow_zero` and `pow_succ`. All of those\n"
"theorems are true *by definition*. The same is *not* true however of "
"`zero_add`; \n"
"the theorem `0 + x = x` was proved by induction on `x`,\n"
"and in particular it is not true by *definition*.\n"
"\n"
"Definitional equality is of great importance\n"
"to computer scientists, but mathematicians are much more fluid with their "
"idea\n"
"of a definition -- a concept can simultaneously have three equivalent "
"definitions\n"
"in a maths talk, as long as they're all logically equivalent. In Lean, a "
"definition\n"
"is *one thing*, and definitional equality is a subtle concept which depends "
"on\n"
"exactly which definition you chose. `add_comm` is certainly not true by "
"definition,\n"
"which means that if we had decided to define `a ≤ b` by `∃ c, b = c + a` "
"(rather\n"
"than `a + c`) all the same theorems would be true, but `refl` would work in\n"
"different places. `refl` closes a goal of the form `X = Y` if `X` and `Y` "
"are\n"
"definitionally equal.\n"
msgstr ""

#: Inequality world level 3
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 3: `le_succ_of_le`\n"
"\n"
"We have seen how the `use` tactic makes progress on goals of the form `⊢ ∃ "
"c, ...`.\n"
"But what do we do when we have a *hypothesis* of the form `h : ∃ c, ...`?\n"
"The hypothesis claims that there exists some natural number `c` with some\n"
"property. How are we going to get to that natural number `c`? It turns out\n"
"that the `cases` tactic can be used (just like it was used to extract\n"
"information from `∧` and `∨` and `↔` hypotheses). Let me talk you through\n"
"the proof of $a\\le b\\implies a\\le\\operatorname{succ}(b)$.\n"
"\n"
"The goal is an implication so we clearly want to start with \n"
"\n"
"`intro h,`\n"
"\n"
". After this, if you *want*, you can do something like\n"
"\n"
"`rw le_iff_exists_add at h ⊢,`\n"
"\n"
"(get the sideways T with `\\|-` then space). This changes the `≤` into\n"
"its `∃` form in `h` and the goal -- but if you are happy with just\n"
"*imagining* the `∃` whenever you read a `≤` then you don't need to do this "
"line.\n"
"\n"
"Our hypothesis `h` is now `∃ (c : mynat), b = a + c` (or `a ≤ b` if you\n"
"elected not to do the definitional rewriting) so\n"
"\n"
"`cases h with c hc,`\n"
"\n"
"gives you the natural number `c` and the hypothesis `hc : b = a + c`.\n"
"Now use `use` wisely and you're home.\n"
"\n"
msgstr ""

#: Inequality world level 3
msgid ""
"For all naturals $a$, $b$, if $a\\leq b$ then $a\\leq \\operatorname{succ}"
"(b)$. \n"
msgstr ""

#: Inequality world level 3
msgid ""
"\n"
"\n"
"Did you use `succ c` or `c + 1` or `1 + c`? Those numbers are all\n"
"equal, right? So it doesn't matter which one you use, right?\n"
"\n"
"Here's an interesting question. If you copy the proof below into\n"
"the box above, and then fill in the `???`\n"
"below with `succ c`, will this proof compile? (move your cursor to\n"
"after the final comma to see what Lean thinks). What about if you\n"
"`use 1 + c`? What about if you `use c + 1`? Can you work out\n"
"what is going on? Does it help if I tell you that the *definition*\n"
"of `1` is `succ 0`?\n"
"\n"
"```\n"
"theorem le_succ (a b : mynat) : a ≤ b → a ≤ (succ b) :=\n"
"begin [nat_num_game]\n"
"  intro h,\n"
"  cases h with c hc,\n"
"  rw hc,\n"
"  use ???,\n"
"  refl,\n"
"\n"
"\n"
"end\n"
"```\n"
"\n"
msgstr ""

#: Inequality world level 4
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 4: `zero_le`\n"
"\n"
"Another easy one. \n"
msgstr ""

#: Inequality world level 4
msgid "For all naturals $a$, $0\\leq a$.\n"
msgstr ""

#: Inequality world level 5
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 5: `le_trans`\n"
"\n"
"Another straightforward one. \n"
msgstr ""

#: Inequality world level 5
msgid ""
"≤ is transitive. In other words, if $a\\leq b$ and $b\\leq c$ then $a\\leq c"
"$. \n"
msgstr ""

#: Inequality world level 5
msgid ""
"Congratulations -- you just got a collectible. You proved that the\n"
"natural numbers are a preorder.\n"
msgstr ""

#: Inequality world level 6
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 6: `le_antisymm`\n"
"\n"
"In Advanced Addition World you proved\n"
"\n"
"`eq_zero_of_add_right_eq_self (a b : mynat) : a + b = a → b = 0`.\n"
"\n"
"This might be useful in this level.\n"
"\n"
"Another tip: if you want to create a new hypothesis, you can use the `have` "
"tactic.\n"
"For example, if you have a hypothesis `hd : a + (c + d) = a` and you want \n"
"a hypothesis `h : c + d = 0` then you can write\n"
"\n"
"`have h := eq_zero_of_add_right_eq_self hd,`\n"
"\n"
msgstr ""

#: Inequality world level 6
msgid ""
"$\\le$ is antisymmetric. In other words, if $a\\le b$ and $b\\le a$ then $a "
"= b$. \n"
msgstr ""

#: Inequality world level 6
msgid ""
"Congratulations -- you just proved that the natural numbers are a partial "
"order!\n"
msgstr ""

#: Inequality world level 7
msgid ""
"# Inequality world \n"
"\n"
"## Level 7: `le_zero`\n"
"\n"
"We proved `add_right_eq_zero` back in advanced addition world.\n"
"Remember that you can do things like `have h2 := add_right_eq_zero h1`\n"
"if `h1 : a + c = 0`.\n"
msgstr ""

#: Inequality world level 7
msgid "For all naturals $a$, if $a\\le 0$ then $a = 0$.\n"
msgstr ""

#: Inequality world level 8
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 8: `succ_le_succ`\n"
"\n"
"Another straightforward one. \n"
msgstr ""

#: Inequality world level 8
msgid ""
"For all naturals $a$ and $b$, if $a\\le b$, then $\\operatorname{succ}(a)\\le"
"\\operatorname{succ}(b)$. \n"
msgstr ""

#: Inequality world level 9
msgid ""
"# Inequality world. \n"
"\n"
"## Level 9: `le_total`\n"
msgstr ""

#: Inequality world level 9
msgid "For all naturals $a$ and $b$, either $a\\le b$ or $b\\le a$. \n"
msgstr ""

#: Inequality world level 9
msgid "-- Another collectible: the naturals are a linear order."
msgstr ""

#: Inequality world level 10
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 10: `le_succ_self`\n"
"\n"
"Can you find the two-line proof?\n"
msgstr ""

#: Inequality world level 10
msgid "For all naturals $a$, $a\\le\\operatorname{succ}(a).$\n"
msgstr ""

#: Inequality world level 11
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 11: `add_le_add_right`\n"
"\n"
"If you're faced with a goal of the form `forall t, ...`, then the next\n"
"line is \"so let $t$ be arbitrary\". The way to do this in Lean is `intro "
"t`.\n"
msgstr ""

#: Inequality world level 11
msgid ""
"For all naturals $a$ and $b$, $a\\le b$ implies that for all naturals $t$,\n"
"$a+t\\le b+t$.\n"
msgstr ""

#: Inequality world level 12
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 12: `le_of_succ_le_succ`\n"
"\n"
msgstr ""

#: Inequality world level 12
msgid ""
"For all naturals $a$ and $b$,\n"
"$\\operatorname{succ}(a)\\le\\operatorname{succ}(b)\\implies a\\le b.$\n"
msgstr ""

#: Inequality world level 13
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 13: `not_succ_le_self`\n"
"\n"
"Turns out that `¬ P` is *by definition* `P → false`, so you can just\n"
"start this one with `intro h` if you like. \n"
"\n"
"## Pro tip:\n"
"\n"
"```\n"
"  conv begin\n"
"    to_lhs,\n"
"    rw hc,\n"
"  end,\n"
"```\n"
"\n"
"is an incantation which rewrites `hc` only on the left hand side of the "
"goal.\n"
"Look carefully at the commas. You don't need to use `conv` to solve this,\n"
"but it's a helpful trick when `rw` is rewriting too much.\n"
msgstr ""

#: Inequality world level 13
msgid "For all naturals $a$, $\\operatorname{succ}(a)$ is not at most $a$.\n"
msgstr ""

#: Inequality world level 14
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 14: `add_le_add_left`\n"
"\n"
"I know these are easy and we've done several already, but this is one\n"
"of the axioms for an ordered commutative monoid! The nature of formalising\n"
"is that we should formalise all \"obvious\" lemmas, and then when we're\n"
"actually using $\\le$ in real life, everything will be there. Note also,\n"
"of course, that all of these lemmas are already formalised in Lean's\n"
"maths library already, for Lean's inbuilt natural numbers. \n"
msgstr ""

#: Inequality world level 14
msgid "If $a\\le b$ then for all $t$, $t+a\\le t+b$. \n"
msgstr ""

#: Inequality world level 15
msgid "--import mynat.lt -- definition of <"
msgstr ""

#: Inequality world level 15
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 15: introducing `<`\n"
"\n"
"To get the remaining collectibles in this world, we need to\n"
"give a definition of `<`. By default, the definition of `a < b`\n"
"in Lean, once `≤` is defined, is this:\n"
"\n"
"`a < b := a ≤ b ∧ ¬ (b ≤ a)`\n"
"\n"
". But a much more usable definition would be this:\n"
"\n"
"`a < b := succ(a) ≤ b`\n"
"\n"
". Let's prove that these two definitions are the same\n"
msgstr ""

#: Inequality world level 15
msgid ""
"For all naturals $a$ and $b$,\n"
"$$a\\le b\\land\\lnot(b\\le a)\\implies\\operatorname{succ}(a)\\le b.$$\n"
msgstr ""

#: Inequality world level 16
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 16: equivalence of two definitions of `<`\n"
"\n"
"Now let's go the other way. \n"
msgstr ""

#: Inequality world level 16
msgid ""
"For all naturals $a$ and $b$,\n"
"$$\n"
"\\operatorname{succ}(a)\\le b\n"
"\\implies\n"
"a\\le b\\land\\lnot(b\\le a).$$\n"
msgstr ""

#: Inequality world level 16
msgid "Now for the payoff.\n"
msgstr ""

#: Inequality world level 17
msgid ""
"\n"
"# Inequality world. \n"
"\n"
"## Level 17: definition of `<`\n"
"\n"
"OK so we are going to *define* `a < b` by `a ≤ b ∧ ¬ (b ≤ a)`,\n"
"and given `lt_aux_one a b` and `lt_aux_two a b` it should now just\n"
"be a few lines to prove `a < b ↔ succ(a) ≤ b`. \n"
"\n"
msgstr ""

#: Inequality world level 17
msgid "-- incantation so that we can use `<` notation: "
msgstr ""

#: Inequality world level 17
msgid ""
"For all naturals $a$ and $b$,\n"
"$$a<b\\iff\\operatorname{succ}(a)\\le b.$$\n"
msgstr ""

#: Inequality world level 17
msgid ""
"For now -- that's it. In the next version of the natural number game we will "
"go on and make\n"
"the natural numbers into an `ordered_cancel_comm_monoid`, which is the most\n"
"exotic of all the structures defined on the natural numbers in Lean 3.4.2.\n"
"\n"
"Interested in playing levels involving other kinds of mathematics?\n"
"Look <a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/"
"blob/master/WHATS_NEXT.md\"\n"
"  target=\"blank\">here</a> for more ideas about what to do next.\n"
"\n"
"Interested in learning more? Join us on the\n"
"<a href=\"https://leanprover.zulipchat.com/\" target=\"blank\">Zulip Lean "
"chat</a>\n"
"and ask questions in the `#new members` stream. Real names preferred. Be "
"nice.\n"
msgstr ""
