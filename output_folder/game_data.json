{"name": "Natural number game", "version": "1.3.3", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Natural number game-1.3.3-library.zip", "introData": {"name": "", "problemIndex": -1, "objects": [{"type": "text", "content": "1"}]}, "worlds": [{"name": "2", "levels": [{"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "3", "hidden": false}, {"type": "lean", "content": "4", "hidden": true}, {"type": "text", "content": "5"}, {"type": "lemma", "text": "6", "lean": "lemma example1 (x y z : mynat) : x * y + z = x * y + z :=\n", "sideBar": false, "firstProofLineNumber": 64, "lastProofLineNumber": 67, "textBefore": "import mynat.definition -- imports the natural numbers {0,1,2,3,4,...}.\nimport mynat.add -- imports definition of addition on the natural numbers.\nimport mynat.mul -- imports definition of multiplication on the natural numbers.\nnamespace mynat -- hide\n\n\n/- \n# Tutorial World\n\n## Level 1: the `refl` tactic.\n\nLet us start by learning some tactics! Let's start with the `refl` tactic. `refl` stands for \"reflexivity\", which is a fancy\nway of saying that it will prove any goal of the form `A = A`. It doesn't matter how\ncomplicated `A` is, all that matters is that the left hand side is *exactly equal* to the\nright hand side (a computer scientist would say \"definitionally equal\"). I really mean\n\"press the same buttons on your computer in the same order\" equal.\nFor example, `x * y + z = x * y + z` can be proved by `refl`, but `x + y = y + x` cannot.\n\nEach level in this game involves proving a theorem or a lemma (a lemma is just a baby theorem).\nThe goal of the theorem will be a mathematical statement with a `\u22a2` just before it.\nWe will use tactics to manipulate and ultimately close (i.e. prove) these goals.\n\nLet's see `refl` in action! At the bottom of the text in this box, there's a lemma,\nwhich says that if $x$, $y$ and $z$ are natural numbers then $xy + z = xy + z$.\nLocate this lemma (if you can't see the lemma and these instructions at the same time, make this box wider\nby dragging the sides). Let's supply the proof. Click on the word `sorry` and then delete it.\nWhen the system finishes being busy, you'll be able to see your goal -- the objective\nof this level -- in the box on the top right. [NB if your system never finishes being busy, then\nyour computer is not running the javascript Lean which powers everything behind the scenes. \nTry Chrome? Try not using private browsing?] \n\nRemember that the goal is\nthe thing with the weird `\u22a2` thing just before it. The goal in this case is `x * y + z = x * y + z`,\nwhere `x`, `y` and `z` are some of your very own natural numbers.\nThat's a pretty easy goal to prove -- you can just prove it with the `refl` tactic.\nWhere it used to say `sorry`, write\n\n`refl,`\n\n**and don't forget the comma**. Then hit enter to go onto the next line.\nIf all is well, Lean should tell you \"Proof complete!\" in the top right box, and there\nshould be no errors in the bottom right box. You just did the first\nlevel of the tutorial! And you also learnt how to avoid by *far* the most\ncommon mistake that beginner users make -- **every line must end with a comma**.\nIf things go weird and you don't understand why the top right box is empty,\ncheck for missing commas. Also check if you've spelt `refl` correctly: it's REFL\nfor \"reflexivity\"!\n\nFor each level, the idea is to get Lean into this state: with the top right\nbox saying \"Proof complete!\" and the bottom right box empty (i.e. with no errors in).\n\nIf you want to be reminded about the `refl` tactic, you can click on the \"Tactics\" drop\ndown menu on the left. Resize the window if it's too small! \n\nNow click on \"next level\" in the top right of your browser to go onto the second level of\ntutorial world, where we'll learn about the `rw` tactic.\n-/\n\n/- Lemma : no-side-bar\nFor all natural numbers $x$, $y$ and $z$, we have $xy + z = xy + z$.\n-/\nlemma example1 (x y z : mynat) : x * y + z = x * y + z :=\nbegin [nat_num_game]\n", "proof": "  refl\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : refl\n\n## Summary\n\n`refl` proves goals of the form `X = X`.\n\n## Details\n\nThe `refl` tactic will close any goal of the form `A = B`\nwhere `A` and `B` are *exactly the same thing*.\n\n### Example:\nIf it looks like this in the top right hand box:\n```\na b c d : mynat\n\u22a2 (a + b) * (c + d) = (a + b) * (c + d)\n```\n\nthen\n\n`refl,`\n\nwill close the goal and solve the level. Don't forget the comma.\n\n-/\n\nend mynat -- hide \n\n", "height": 4, "editorText": "sorry", "lineOffset": 63, "name": "example1", "statement": "(x y z : mynat) : x * y + z = x * y + z"}, {"type": "tactic", "content": "7", "name": "refl", "sideBar": true}, {"type": "lean", "content": "8", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "9", "hidden": true}, {"type": "lean", "content": "10", "hidden": true}, {"type": "text", "content": "11"}, {"type": "lemma", "text": "12", "lean": "lemma example2 (x y : mynat) (h : y = x + 7) : 2 * y = 2 * (x + 7) :=\n", "sideBar": false, "firstProofLineNumber": 48, "lastProofLineNumber": 51, "textBefore": "import mynat.mul -- hide\nnamespace mynat -- hide\n\n/-\n# Tutorial world\n\n## level 2: The rewrite (`rw`) tactic.\n\nThe rewrite tactic is the way to \"substitute in\" the value\nof a variable. In general, if you have a hypothesis of the form `A = B`, and your\ngoal mentions the left hand side `A` somewhere, then\nthe `rewrite` tactic will replace the `A` in your goal with a `B`.\nBelow is a theorem which cannot be\nproved using `refl` -- you need a rewrite first.\n\nDelete the sorry and take a look in the top right box at what we have.\nThe variables $x$ and $y$ are natural numbers, and we have\na proof `h` that $y = x + 7$. Our goal\nis to prove that $2y=2(x+7)$. This goal is obvious -- we just\nsubstitute in $y = x+7$ and we're done. In Lean, we do\nthis substitution using the `rw` tactic. So start your proof with \n\n`rw h,`\n\nand then hit enter. **Don't forget the comma.**\nDid you see what happened to the goal? The goal doesn't close,\nbut it *changes* from `\u22a2 2 * y = 2 * (x + 7)` to `\u22a2 2 * (x + 7) = 2 * (x + 7)`.\nWe can just close this goal with\n\n`refl,`\n\nby writing it on the line after `rw h,`. Don't forget the comma, hit\nenter, and enjoy seeing the \"Proof complete!\" message in the\ntop right window. The other reason you'll know you're\ndone is that the bottom right window (the error window)\nbecomes empty. When you've finished reading the comments below\nthe proof, click \"Next Level\" in the top right to proceed to the next\nlevel in this world.\n\n-/\n\n/- Lemma : no-side-bar\nIf $x$ and $y$ are natural numbers, \nand $y=x+7$, then $2y=2(x+7)$. \n-/\nlemma example2 (x y : mynat) (h : y = x + 7) : 2 * y = 2 * (x + 7) :=\nbegin [nat_num_game]\n", "proof": "  rw h,\n  refl\n  \n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n\n## Summary\n\nIf `h` is a proof of `X = Y`, then `rw h,` will change\nall `X`s in the goal to `Y`s. Variants: `rw \u2190 h` (changes\n`Y` to `X`) and\n`rw h at h2` (changes `X` to `Y` in hypothesis `h2` instead\nof the goal).\n\n## Details\n\nThe `rw` tactic is a way to do \"substituting in\". There\nare two distinct situations where use this tactics.\n\n1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\nin your local context (the box in the top right)\nand if your goal contains one or more `A`s, then `rw h`\nwill change them all to `B`'s. \n\n2) The `rw` tactic will also work with proofs of theorems\nwhich are equalities (look for them in the drop down\nmenu on the left, within Theorem Statements).\nFor example, in world 1 level 4\nwe learn about `add_zero x : x + 0 = x`, and `rw add_zero`\nwill change `x + 0` into `x` in your goal (or fail with\nan error if Lean cannot find `x + 0` in the goal).\n\nImportant note: if `h` is not a proof of the form `A = B`\nor `A \u2194 B` (for example if `h` is a function, an implication,\nor perhaps even a proposition itself rather than its proof),\nthen `rw` is not the tactic you want to use. For example,\n`rw (P = Q)` is never correct: `P = Q` is the true-false\nstatement itself, not the proof.\nIf `h : P = Q` is its proof, then `rw h` will work.\n\nPro tip 1: If `h : A = B` and you want to change\n`B`s to `A`s instead, try `rw \u2190h` (get the arrow with `\\l` and\nnote that this is a small letter L, not a number 1).\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nx y : mynat\nh : x = y + y\n\u22a2 succ (x + 0) = succ (y + y)\n```\n\nthen\n\n`rw add_zero,`\n\nwill change the goal into `\u22a2 succ x = succ (y + y)`, and then\n\n`rw h,`\n\nwill change the goal into `\u22a2 succ (y + y) = succ (y + y)`, which\ncan be solved with `refl,`.\n\n### Example: \nYou can use `rw` to change a hypothesis as well. \nFor example, if your local context looks like this:\n```\nx y : mynat\nh1 : x = y + 3\nh2 : 2 * y = x\n\u22a2 y = 3\n```\nthen `rw h1 at h2` will turn `h2` into `h2 : 2 * y = y + 3`.\n-/\n\n/-\n\n## Exploring your proof.\n\nClick on `refl,` and then use the arrow keys to move\nyour cursor around the proof. Go up and down and note that\nthe goal changes -- indeed you can inspect Lean's \"state\" at each\nline of the proof (the hypotheses, and the goal).\nTry to figure out the exact place where the goal changes.\nThe comma tells Lean \"I've finished writing this tactic now,\nplease process it.\" Lean ignores newlines, but pays great\nattention to commas.\n\n## The tactic index\n\nThe documentation for `rw` just appeared in the list of tactics\nin the box on the left. Play around with the menus on the left\nand see what is there currently. More information will appear as you progress.\n\n## Bewildered?\n\nDoesn't work? Weird error that won't go away? You can check out\nthe \n<a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/SOLUTIONS.md\"\n  target=\"blank\">solutions</a> (github.com, opens in new window).\n  Solutions to every level are here.\n-/\n\nend mynat -- hide", "height": 4, "editorText": "sorry", "lineOffset": 47, "name": "example2", "statement": "(x y : mynat) (h : y = x + 7) : 2 * y = 2 * (x + 7)"}, {"type": "tactic", "content": "13", "name": "rw", "sideBar": true}, {"type": "text", "content": "14"}, {"type": "lean", "content": "15", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "text", "content": "16"}, {"type": "lean", "content": "17", "hidden": false}, {"type": "lean", "content": "18", "hidden": true}, {"type": "text", "content": "19"}, {"type": "lemma", "text": "20", "lean": "lemma example3 (a b : mynat) (h : succ a = b) : succ(succ(a)) = succ(b) :=\n", "sideBar": false, "firstProofLineNumber": 91, "lastProofLineNumber": 95, "textBefore": "/-\nWe just restarted Lean behind the scenes,\nso let's re-import the natural numbers, but this time without\naddition and multiplication.\n-/\n\nimport mynat.definition -- import Peano's definition of the natural numbers {0,1,2,3,4,...}\nnamespace mynat -- hide\n\n/-\n\n# Tutorial world\n\n## Level 3: Peano's axioms.\n\nThe import above gives us the type `mynat` of natural numbers. But it\nalso gives us some other things, which we'll take a look at now:\n\n  * a term `0 : mynat`, interpreted as the number zero.\n  * a function `succ : mynat \u2192 mynat`, with `succ n` interpreted as \"the number after $n$\".\n  * The principle of mathematical induction.\n\nThese axioms are essentially the axioms isolated by Peano which uniquely characterise\nthe natural numbers (we also need recursion, but we can ignore it for now).\nThe first axiom says that $0$ is a natural number. The second says that there\nis a `succ` function which eats a number and spits out the number after it,\nso $\\operatorname{succ}(0)=1$, $\\operatorname{succ}(1)=2$ and so on.\n\nPeano's last axiom is the principle of mathematical induction. This is a deeper\nfact. It says that if we have infinitely many true/false statements $P(0)$, $P(1)$,\n$P(2)$ and so on, and if $P(0)$ is true, and if for every natural number $d$\nwe know that $P(d)$ implies $P(\\operatorname{succ}(d))$, then $P(n)$ must be true for every\nnatural number $n$. It's like saying that if you have a long line of dominoes, and if\nyou knock the first one down, and if you know that if a domino falls down then the one\nafter it will fall down too, then you can deduce that all the dominos will fall down.\nOne can also think of it as saying that every natural number\ncan be built by starting at `0` and then applying `succ` a finite number of times.\n\nPeano's insights were firstly that these axioms completely characterise\nthe natural numbers, and secondly that these axioms alone can be used to build\na whole bunch of other structure on the natural numbers, for example\naddition, multiplication and so on.\n\nThis game is all about seeing how far these axioms of Peano can take us.\n\nLet's practice our use of the `rw` tactic in the following example.\nOur hypothesis `h` is a proof that `succ(a) = b` and we want to prove that\n`succ(succ(a))=succ(b)`. In words, we're going to prove that if\n`b` is the number after `a` then `succ(b)` is the number after `succ(a)`. \nNow here's a tricky question. If our goal is `\u22a2 succ (succ a) = succ b`,\nand our hypothesis is `h : succ a = b`, then what will the goal change\nto when we type\n\n`rw h,`\n\nand hit enter whilst not forgetting the comma? Remember that `rw h` will\nlook for the *left* hand side of `h` in the goal, and will replace it with\nthe *right* hand side. Try and figure out how the goal will change, and\nthen try it.\n\nThe answer: Lean changed `succ a` into `b`, so the goal became `succ b = succ b`.\nThat goal is of the form `X = X`, so you can prove this new goal with\n\n`refl,`\n\non the line after `rw h,`. Don't forget the commas!\n\n**Important note** : the tactic `rw` expects\na proof afterwards (e.g. `rw h1`). But `refl` is just `refl`.\nNote also that the system sometimes drops brackets when they're not\nnecessary, and `succ b` just means `succ(b)`. \n\nYou may be wondering whether we could have just substituted in the definition of `b`\nand proved the goal that way. To do that, we would want to replace the right hand\nside of `h` with the left hand side. You do this in Lean by writing `rw \u2190 h`. You get the\nleft-arrow by typing `\\l` and then a space; note that this is a small letter L,\nnot a number 1. You can just edit your proof and try it. \n\nYou may also be wondering why we keep writing `succ(b)` instead of `b+1`. This\nis because we haven't defined addition yet! On the next level, the final level\nof Tutorial World, we will introduce addition, and then\nwe'll be ready to enter Addition World.\n-/\n\n/- Lemma : no-side-bar\nIf $\\operatorname{succ}(a) = b$, then\n$$\\operatorname{succ}(\\operatorname{succ}(a)) = \\operatorname{succ}(b).$$\n-/\nlemma example3 (a b : mynat) (h : succ a = b) : succ(succ(a)) = succ(b) :=\nbegin [nat_num_game]\n", "proof": "  rw h,\n  refl,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 5, "editorText": "sorry", "lineOffset": 90, "name": "example3", "statement": "(a b : mynat) (h : succ a = b) : succ(succ(a)) = succ(b)"}, {"type": "lean", "content": "21", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "22", "hidden": false}, {"type": "lean", "content": "23", "hidden": true}, {"type": "axiom", "content": "24", "name": "add_zero (a : mynat) :", "sideBar": true}, {"type": "axiom", "content": "25", "name": "add_succ (a b : mynat) :", "sideBar": true}, {"type": "text", "content": "26"}, {"type": "lemma", "text": "27", "lean": "lemma add_succ_zero (a : mynat) : a + succ(0) = succ(a) :=\n", "sideBar": false, "firstProofLineNumber": 73, "lastProofLineNumber": 80, "textBefore": "import mynat.add -- definition of addition\nnamespace mynat -- hide\n\n/- Axiom : add_zero (a : mynat) :\na + 0 = a\n-/\n\n/- Axiom : add_succ (a b : mynat) :\na + succ(b) = succ(a + b)\n-/\n\n/-\n# Tutorial world\n\n## Level 4: addition\n\nWe have a new import -- the definition of addition.\n\nPeano defined addition `a + b` by induction on `b`, or,\nmore precisely, by *recursion* on `b`. He first explained how to add 0 to a number:\nthis is the base case.\n\n* `add_zero (a : mynat) : a + 0 = a`\n\nWe will call this theorem `add_zero`. More precisely, `add_zero` is the name\nof the *proof* of the theorem. **Note the name of this proof**.\nMathematicians sometimes call it \"Lemma 2.1\" or \"Hypothesis P6\" or something. But\ncomputer scientists call it `add_zero` because it tells you\nwhat the answer to \"$x$ add zero\" is. It's a *much* better name than \"Lemma 2.1\".\nEven better, we can use the rewrite tactic with `add_zero`.\nIf you ever see `x + 0` in your goal, `rw add_zero` should simplify it to `x`.\nThis is because `add_zero` is a proof that `x + 0 = x` (more precisely,\n`add_zero x` is a proof that `x + 0 = x` but Lean can figure out the `x` from the context).\n\nNow here's the inductive step. If you know how to add `d` to `a`, then\nPeano tells you how to add `succ(d)` to `a`. It looks like this:\n\n* `add_succ (a d : mynat) : a + succ(d) = succ (a + d)`\n\nWhat's going on here is that we assume `a + d` is already\ndefined, and we define `a + succ(d)` to be the number after it.\n**Note the name of this proof too** -- `add_succ` tells you\nhow to add a successor to something. If you ever see `... + succ ...`\nin your goal, you should be able to use `rw add_succ,` to make\nprogress. Here is a simple example where we shall see both. Let's prove\nthat $x$ add the number after $0$ is the number after $x$.\n\nDelete `sorry` (don't forget you can widen this box if you can't see the sorry).\nObserve that the goal mentions `... + succ ...`. So type\n\n`rw add_succ,`\n\nand hit enter; see the goal change. **Don't forget the commma**.\nDo you see that the goal now mentions ` ... + 0 ...`? So type\n\n`rw add_zero,`\n\nand then observe that you can close the goal with\n\n`refl,`\n\nand you're done. You have finished tutorial world! There are important things\nwritten below the lemma, including what to do next.\n\n-/\n\n/- Lemma : no-side-bar\nFor all natural numbers $a$, we have\n$$a + \\operatorname{succ}(0) = \\operatorname{succ}(a).$$\n-/\nlemma add_succ_zero (a : mynat) : a + succ(0) = succ(a) :=\nbegin [nat_num_game]\n", "proof": "  rw add_succ,\n  rw add_zero,\n  refl,\n\n\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n\n/-\n## Examining proofs.\n\nYou might want to review this proof now; at\nthree lines long it is our current record. Click on a line in the proof\nand use the L/R arrow keys to put your cursor as far left as it will go.\nThen use the U/D arrow keys to move your cursor\nup and down from line to line, and you can see what\nLean is thinking on each line of the proof.\n\n## No problems?\n\nWhen you're happy, let's move onto Addition World, and\nlearn about proof by induction. Go back to the main menu and select addition world.\n\n## Problems?\n\nQuestion: why has the top right hand box gone blank?\n\nAnswer: Maybe you tried a tactic which didn't work. Or maybe you're\nin the middle of typing a tactic. Try deleting up to the last\ncomma, *or adding a comma at the end of your code*. Look at the\nerror message. What line is the first error on? Perhaps\nLean thinks you're in the middle of writing a tactic command that you\nthink you finished. If Lean is still attempting to process a tactic\ncommand it won't display anything. You can get it to stop processing by\nadding a comma. \n\nIf the worst comes to the worst, just delete what you wrote. Most people\nwith problems have written random stuff in the proof box. The only thing\nyou're supposed to be writing is lines like\n\n`rw add_zero,`\n`rw h,`\n`refl,`\n\nOne line of code with a comma at the end. Nothing else at all goes in the box.\n\nIf you cannot see what you have done wrong, you can always\n<a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/SOLUTIONS.md\"\n  target=\"blank\">take a look at the solutions</a> (github.com, opens in new window).\n-/", "height": 8, "editorText": "sorry", "lineOffset": 72, "name": "add_succ_zero", "statement": "(a : mynat) : a + succ(0) = succ(a)"}, {"type": "lean", "content": "28", "hidden": true}, {"type": "text", "content": "29"}]}]}, {"name": "30", "levels": [{"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "31", "hidden": false}, {"type": "lean", "content": "32", "hidden": true}, {"type": "axiom", "content": "33", "name": "add_zero (a : mynat) :", "sideBar": true}, {"type": "axiom", "content": "34", "name": "add_succ (a b : mynat) :", "sideBar": true}, {"type": "tactic", "content": "35", "name": "induction", "sideBar": true}, {"type": "text", "content": "36"}, {"type": "lemma", "text": "37", "lean": "lemma zero_add (n : mynat) : 0 + n = n :=\n", "sideBar": true, "firstProofLineNumber": 148, "lastProofLineNumber": 154, "textBefore": "import mynat.definition -- Imports the natural numbers.\nimport mynat.add -- imports addition.\nnamespace mynat -- hide\n\n\n/- Axiom : add_zero (a : mynat) :\na + 0 = a\n-/\n\n/- Axiom : add_succ (a b : mynat) :\na + succ(b) = succ(a + b)\n-/\n\n/- Tactic : induction\n\n## Summary\n\nif `n : mynat` is in our assumptions, then `induction n with d hd`\nattempts to prove the goal by induction on `n`, with the inductive\nassumption in the `succ` case being `hd`.\n\n## Details\n\nIf you have a natural number `n : mynat` in your context\n(above the `\u22a2`) then `induction n with d hd` turns your\ngoal into two goals, a base case with `n = 0` and\nan inductive step where `hd` is a proof of the `n = d`\ncase and your goal is the `n = succ(d)` case.\n\n### Example:\nIf this is our local context:\n```\nn : mynat\n\u22a2 2 * n = n + n\n```\n\nthen\n\n`induction n with d hd`\n\nwill give us two goals:\n\n```\n\u22a2 2 * 0 = 0 + 0\n```\n\nand\n```\nd : mynat,\nhd : 2 * d = d + d\n\u22a2 2 * succ d = succ d + succ d\n```\n\n-/\n\n\n/- \n# Addition World. \n\nWelcome to Addition World. If you've done all four levels in tutorial world\nand know about `rw` and `refl`, then you're in the right place. Here's\na reminder of the things you're now equipped with which we'll need in this world.\n\n## Data:\n\n  * a type called `mynat`\n  * a term `0 : mynat`, interpreted as the number zero.\n  * a function `succ : mynat \u2192 mynat`, with `succ n` interpreted as \"the number after `n`\".\n  * Usual numerical notation 0,1,2 etc (although 2 onwards will be of no use to us until much later ;-) ).\n  * Addition (with notation `a + b`).\n\n## Theorems:\n\n  * `add_zero (a : mynat) : a + 0 = a`. Use with `rw add_zero`.\n  * `add_succ (a b : mynat) : a + succ(b) = succ(a + b)`. Use with `rw add_succ`.\n  * The principle of mathematical induction. Use with `induction` (see below)\n  \n\n## Tactics:\n\n  * `refl` :  proves goals of the form `X = X`\n  * `rw h` : if h is a proof of `A = B`, changes all A's in the goal to B's.\n  * `induction n with d hd` : we're going to learn this right now.\n\n# Important thing: \n\nThis is a *really* good time to check you understand about the box on the left with the drop down\nmenus. All the theorems and all the tactics above are documented there. You can find\nall you need to know about what theorems you have collected in Theorem statements -> Addition world.\nHave a click around and check that you can find statements of the theorems above, and explanations of\nthe tactics above. As we go through the game, these lists will grow. The box on the left\nwill prove invaluable as the number of theorems we prove gets bigger. On the other hand,\nwe only need to learn one more tactic to really start going places, so let's learn about\nthat tactic right now.\n\n## Level 1: the `induction` tactic.\n\nOK so let's see induction in action. We're going to prove\n\n  `zero_add (n : mynat) : 0 + n = n`. \n\nThat is: for all natural numbers $n$, $0+n=n$. Wait $-$ what is going on here?\nDidn't we already prove that adding zero to $n$ gave us $n$?\nNo we didn't! We proved $n + 0 = n$, and that proof was called `add_zero`. We're now\ntrying to establish `zero_add`, the proof that $0 + n = n$. But aren't these two theorems\nthe same? No they're not! It is *true* that `x + y = y + x`, but we haven't\n*proved* it yet, and in fact we will need both `add_zero` and `zero_add` in order\nto prove this. In fact `x + y = y + x` is the boss level for addition world,\nand `induction` is the only other tactic you'll need to beat it.\n\nNow `add_zero` is one of Peano's axioms, so we don't need to prove it, we already have it\n(indeed, if you've opened the Addition World theorem statements on the left, you can even see it).\nTo prove `0 + n = n` we need to use induction on $n$. While we're here,\n  note that `zero_add` is about zero add something, and `add_zero` is about something add zero.\n  The names of the proofs tell you what the theorems are. Anyway, let's prove `0 + n = n`.\n\n  Delete `sorry` and replace it with `induction n with d hd,`\nand **don't forget the comma**. Hit enter, wait for Lean to finish thinking,\nand let's see what we have.\n\nWhen Lean has finished thinking, we see that we now have *two goals*! The\ninduction tactic has generated for us a base case with `n = 0` (the goal at the top)\nand an inductive step (the goal underneath). The golden rule: **Tactics operate on the first goal** --\nthe goal at the top. So let's just worry about that top goal now, the base case `\u22a2 0 + 0 = 0`.\n\nRemember that `add_zero` (the proof we have already) is the proof of `x + 0 = x`\n(for any $x$) so we can try\n\n`rw add_zero,`\n\n. What do you think the goal will\nchange to? Remember to just keep\nfocussing on the top goal, ignore the other one for now, it's not changing\nand we're not working on it. You should be able to solve the top goal yourself\nnow with `refl`.\n\nWhen you solved this base case goal, we are now be back down\nto one goal -- the inductive step. Take a look at the\ntext below the lemma to see an explanation of this goal.\n-/\n\n/- Lemma\nFor all natural numbers $n$, we have\n$$0 + n = n.$$\n-/\nlemma zero_add (n : mynat) : 0 + n = n :=\nbegin [nat_num_game]\n", "proof": "  induction n with d hd,\n    rw add_zero,\n    refl,\n  rw add_succ,\n  rw hd,\n  refl\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nWe're in the successor case, and your top right box should look\nsomething like this:\n\n```\ncase mynat.succ\nd : mynat,\nhd : 0 + d = d\n\u22a2 0 + succ d = succ d\n```\n\n*Important:* make sure that you only have one goal at this point. You\nshould have proved `0 + 0 = 0` by now. Tactics only operate on the top goal.\n\nThe first line just reminds us we're doing the inductive step.\nWe have a fixed natural number `d`, and the inductive hypothesis `hd : 0 + d = d`\nsaying that we have a proof of `0 + d = d`.  \nOur goal is to prove `0 + succ d = succ d`. In words, we're showing that\nif the lemma is true for `d`, then it's also true for the number after `d`.\nThat's the inductive step. Once we've proved this inductive step, we will have proved\n`zero_add` by the principle of mathematical induction.\n\nTo prove our goal, we need to use `add_succ`. We know that `add_succ 0 d`\nis the result that `0 + succ d = succ (0 + d)`, so the first thing\nwe need to do is to replace the left hand side `0 + succ d` of our\ngoal with the right hand side. We do this with the `rw` command. You can write\n\n`rw add_succ,`\n\n(or even `rw add_succ 0 d,` if you want to give Lean all the inputs instead of making it\nfigure them out itself). Don't forget the comma though. Hit enter. The goal should change to\n\n`\u22a2 succ (0 + d) = succ d`\n\nNow remember our inductive hypothesis `hd : 0 + d = d`. We need\nto rewrite this too! Type \n\n`rw hd,`\n\n(don't forget the comma). The goal will now change to\n\n`\u22a2 succ d = succ d`\n\nThis goal can be solved with the `refl` tactic. After you apply it,\nLean will inform you that there are no goals left. You are done!\n\n## Now venture off on your own.\n\nThose three tactics -- \n\n* `induction n with d hd,` \n* `rw h,`\n* `refl,`\n\nwill get you quite a long way through this game. Using only these tactics\nyou can beat Addition World level 4 (the boss level of Addition World),\nall of Multiplication World including the boss level `a * b = b * a`,\nand even all of Power World including the fiendish final boss. This route will\ngive you a good grounding in these three basic tactics; after that, if you\nare still interested, there are other worlds to master, where you can learn\nmore tactics.\n\nBut we're getting ahead of ourselves, you still have to beat the rest of Addition World. \nWe're going to stop explaining stuff carefully now. If you get stuck or want\nto know more about Lean (e.g. how to do much harder maths in Lean),\nask in `#new members` at\n<a href=\"https://leanprover.zulipchat.com\" target=\"blank\">the Lean chat</a>\n(login required, real name preferred). Kevin or Mohammad or one of the other\npeople there might be able to help.\n\nGood luck! Click on \"next level\" to solve some levels on your own.\n\n-/\n\nend mynat -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 147, "name": "zero_add", "statement": "(n : mynat) : 0 + n = n"}, {"type": "text", "content": "38"}, {"type": "lean", "content": "39", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "40", "hidden": true}, {"type": "lean", "content": "41", "hidden": true}, {"type": "lean", "content": "42", "hidden": true}, {"type": "lean", "content": "43", "hidden": true}, {"type": "text", "content": "44"}, {"type": "lemma", "text": "45", "lean": "lemma add_assoc (a b c : mynat) : (a + b) + c = a + (b + c) :=\n", "sideBar": true, "firstProofLineNumber": 41, "lastProofLineNumber": 53, "textBefore": "import mynat.definition -- hide\nimport mynat.add -- hide\nimport game.world2.level1 -- hide\nnamespace mynat -- hide\n\n/- \n# Addition world\n\nDon't forget to use the drop down boxes on the left to see your tactics and\nwhat you have proved so far.\n\n## Level 2: `add_assoc` -- associativity of addition.\n\nIt's well-known that (1 + 2) + 3 = 1 + (2 + 3) -- if we have three numbers\nto add up, it doesn't matter which of the additions we do first. This fact\nis called *associativity of addition* by mathematicians, and it is *not*\nobvious. For example, subtraction really is not associative: $(6 - 2) - 1$\nis really not equal to $6 - (2 - 1)$. We are going to have to prove\nthat addition, as defined the way we've defined it, is associative. \n \nSee if you can prove associativity of addition. Hint: because addition was defined\nby recursion on the right-most variable, use induction on the right-most\nvariable (try other variables at your peril!). Note that when Lean writes `a + b + c`,\nit means `(a + b) + c`. If it wants to talk about `a + (b + c)` it will put the brackets\nin explictly.\n\nReminder: you are done when you see \"Proof complete!\" in the top right, and an empty\nbox (no errors) in the bottom right. You can move between levels and worlds (i.e. you\ncan go back and review old stuff) without losing anything.\n\nOnce you're done with associativity (sub-boss), we can move on to commutativity (boss).\n-/\n\n/- Lemma\nOn the set of natural numbers, addition is associative.\nIn other words, for all natural numbers $a, b$ and $c$, we have\n$$ (a + b) + c = a + (b + c). $$\n-/\nlemma add_assoc (a b c : mynat) : (a + b) + c = a + (b + c) :=\nbegin [nat_num_game]\n", "proof": "  induction c with d hd,\n  { -- \u22a2 a + b + 0 = a + (b + 0)\n    rw add_zero,\n    rw add_zero,\n    refl\n  },\n  { -- \u22a2 (a + b) + succ d = a + (b + succ d)\n    rw add_succ,\n    rw add_succ,\n    rw add_succ,\n    rw hd,\n    refl,\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide \n\n", "height": 13, "editorText": "sorry", "lineOffset": 40, "name": "add_assoc", "statement": "(a b c : mynat) : (a + b) + c = a + (b + c)"}, {"type": "lean", "content": "46", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "47", "hidden": true}, {"type": "lean", "content": "48", "hidden": true}, {"type": "lean", "content": "49", "hidden": true}, {"type": "lean", "content": "50", "hidden": true}, {"type": "text", "content": "51"}, {"type": "lemma", "text": "52", "lean": "lemma succ_add (a b : mynat) : succ a + b = succ (a + b) :=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 43, "textBefore": "import mynat.definition -- hide\nimport mynat.add -- hide\nimport game.world2.level2 -- hide\nnamespace mynat -- hide\n\n/- \n# Addition World\n\n## Level 3: `succ_add`\n\nOh no! On the way to `add_comm`, a wild `succ_add` appears. `succ_add`\nis the proof that `succ(a) + b = succ(a + b)` for `a` and `b` in your\nnatural number type. We need to prove this now, because we will need\nto use this result in our proof that `a + b = b + a` in the next level.\n\nNB: think about why computer scientists called this result `succ_add` .\nThere is a logic to all the names.\n\nNote that if you want to be more precise about exactly where you want\nto rewrite something like `add_succ` (the proof you already have),\nyou can do things like `rw add_succ (succ a)` or\n`rw add_succ (succ a) d`, telling Lean explicitly what to use for\nthe input variables for the function `add_succ`. Indeed, `add_succ`\nis a function -- it takes as input two variables `a` and `b` and outputs a proof\nthat `a + succ(b) = succ(a + b)`. The tactic `rw add_succ` just says to Lean \"guess\nwhat the variables are\". \n-/\n\n/- Lemma\nFor all natural numbers $a, b$, we have\n$$ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b). $$\n-/\nlemma succ_add (a b : mynat) : succ a + b = succ (a + b) :=\nbegin [nat_num_game]\n", "proof": "  induction b with d hd,\n  {\n    refl\n  }, \n  { rw add_succ,\n    rw hd,\n    rw add_succ,\n    refl\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide \n", "height": 9, "editorText": "sorry", "lineOffset": 34, "name": "succ_add", "statement": "(a b : mynat) : succ a + b = succ (a + b)"}, {"type": "lean", "content": "53", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "54", "hidden": true}, {"type": "lean", "content": "55", "hidden": true}, {"type": "lean", "content": "56", "hidden": true}, {"type": "lean", "content": "57", "hidden": true}, {"type": "text", "content": "58"}, {"type": "lemma", "text": "59", "lean": "lemma add_comm (a b : mynat) : a + b = b + a :=\n", "sideBar": true, "firstProofLineNumber": 24, "lastProofLineNumber": 33, "textBefore": "import mynat.definition -- hide\nimport mynat.add -- hide\nimport game.world2.level3 -- hide\nnamespace mynat -- hide\n\n/- \n# Addition World\n\n## Level 4: `add_comm` (boss level)\n\n[boss battle music]\n\nLook in Theorem statements -> Addition world to see the proofs you have.\nThese should be enough.\n-/\n\n/- Lemma\nOn the set of natural numbers, addition is commutative.\nIn other words, for all natural numbers $a$ and $b$, we have\n$$ a + b = b + a. $$\n-/\nlemma add_comm (a b : mynat) : a + b = b + a :=\nbegin [nat_num_game]\n", "proof": "  induction b with d hd,\n  { rw zero_add,\n    rw add_zero,\n    refl\n  },\n  { rw add_succ,\n    rw hd,\n    rw succ_add,\n    refl\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n\nIf you got this far -- nice! You're nearly ready to make a choice:\nMultiplication World or Function World. But there are just a couple\nmore useful lemmas in Addition World which you should prove first.\nPress on to level 5.\n\n-/\nend mynat -- hide \n", "height": 10, "editorText": "sorry", "lineOffset": 23, "name": "add_comm", "statement": "(a b : mynat) : a + b = b + a"}, {"type": "text", "content": "60"}, {"type": "lean", "content": "61", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "62", "hidden": true}, {"type": "lean", "content": "63", "hidden": true}, {"type": "lean", "content": "64", "hidden": true}, {"type": "lean", "content": "65", "hidden": true}, {"type": "axiom", "content": "66", "name": "one_eq_succ_zero", "sideBar": true}, {"type": "text", "content": "67"}, {"type": "theorem", "text": "68", "lean": "theorem succ_eq_add_one (n : mynat) : succ n = n + 1 :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 37, "textBefore": "import mynat.definition -- hide\nimport mynat.add -- hide\nimport game.world2.level4 -- hide\nnamespace mynat -- hide\n\n/- Axiom : one_eq_succ_zero\n1 = succ(0)\n-/\n\n/-\n\n# Addition World\n\n## Level 5: `succ_eq_add_one`\n\nI've just added `one_eq_succ_zero` (a proof of `1 = succ(0)`) to your list of theorems; this is true\nby definition of $1$, but we didn't need it until now.\n\nLevels 5 and 6 are the two last levels in Addition World.\nLevel 5 involves the number $1$. When you see a $1$ in your goal,\nyou can write `rw one_eq_succ_zero` to get back\nto something which only mentions `0`. This is a good move because $0$ is easier for us to\nmanipulate than $1$ right now, because we have\nsome theorems about $0$ (`zero_add`, `add_zero`), but, other than `1 = succ(0)`,\nno theorems at all which mention $1$. Let's prove one now.\n-/\n\n/- Theorem\nFor any natural number $n$, we have\n$$ \\operatorname{succ}(n) = n+1. $$\n-/\ntheorem succ_eq_add_one (n : mynat) : succ n = n + 1 :=\nbegin [nat_num_game]\n", "proof": "  rw one_eq_succ_zero,\n  rw add_succ,\n  rw add_zero,\n  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 4, "editorText": "sorry", "lineOffset": 33, "name": "succ_eq_add_one", "statement": "(n : mynat) : succ n = n + 1"}, {"type": "lean", "content": "69", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "70", "hidden": true}, {"type": "lean", "content": "71", "hidden": true}, {"type": "lean", "content": "72", "hidden": true}, {"type": "lean", "content": "73", "hidden": true}, {"type": "lean", "content": "74", "hidden": true}, {"type": "text", "content": "75"}, {"type": "lemma", "text": "76", "lean": "lemma add_right_comm (a b c : mynat) : a + b + c = a + c + b :=\n", "sideBar": true, "firstProofLineNumber": 53, "lastProofLineNumber": 56, "textBefore": "import mynat.definition -- hide\nimport mynat.add -- hide\nimport game.world2.level5 -- hide\nimport tactic.ring -- hide\nnamespace mynat -- hide\n\n\n\n/-\n\n# Addition World\n\n## Level 6: `add_right_comm`\n\nLean sometimes writes `a + b + c`. What does it mean? The convention is\nthat if there are no brackets displayed in an addition formula, the brackets\nare around the left most `+` (Lean's addition is \"left associative\"). \nSo the goal in this level is `(a + b) + c = (a + c) + b`. This isn't\nquite `add_assoc` or `add_comm`, it's something you'll have to prove\nby putting these two theorems together.\n\nIf you hadn't picked up on this already, `rw add_assoc` will\nchange `(x + y) + z` to `x + (y + z)`, but to change it back\nyou will need `rw \u2190 add_assoc`. Get the left arrow by typing `\\l`\nthen the space bar (note that this is L for left, not a number 1).\nSimilarly, if `h : a = b` then `rw h` will change `a`'s to `b`'s\nand `rw \u2190 h` will change `b`'s to `a`'s.\n\nAlso, you can be (and will need to be, in this level) more precise\nabout where to rewrite theorems. `rw add_comm,` will just find the\nfirst `? + ?` it sees and swap it around. You can target more specific\nadditions like this: `rw add_comm a` will swap around\nadditions of the form `a + ?`, and `rw add_comm a b,` will only\nswap additions of the form `a + b`.\n\n## Where next?\n\nThere are thirteen more levels about addition after this one, but before\nyou can attempt them you need to learn some more tactics. So after this\nlevel you have a choice -- either move on to Multiplication World (which you can\nsolve with the tactics you know) or try Function World (and learn some new ones).\nAfter solving this level, click \"Main Menu\" in the top left to take you back\nto the overworld, and make your choice. Other things, perhaps of interest\nto some players, are mentioned below the lemma. \n-/\n\n/- Lemma\nFor all natural numbers $a, b$ and $c$, we have\n$$ a + b + c = a + c + b. $$\n-/\nlemma add_right_comm (a b c : mynat) : a + b + c = a + c + b :=\nbegin [nat_num_game]\n", "proof": "  rw add_assoc,\n  rw add_comm b c,\n  rw \u2190add_assoc,\n  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nIf you have got this far, then you have become very good at\nmanipulating equalities in Lean. You can also now collect\nfour collectibles (or `instance`s, as Lean calls them)\n\n```\nmynat.add_semigroup -- (after level 2)\nmynat.add_monoid -- (after level 2)\nmynat.add_comm_semigroup mynat (after level 4)\nmynat.add_comm_monoid -- (after level 4)\n```\n\nIn Multiplication World you will be able to collect such\nadvanced collectibles as `mynat.comm_semiring` and\n`mynat.distrib`, and then move on to power world and\nthe famous collectible at the end of it.\n\nOne last thing -- didn't you think that solving this level\n`add_right_comm` was boring? Check out this AI that can do it for us.\n\nFirst we have to get the `add_comm_monoid` collectible,\nwhich we do by saying the magic words which make Lean's type class inference\nsystem give it to us.\n-/\ninstance : add_comm_monoid mynat := by structure_helper\n\n\n\n/-\nNow the `simp` AI becomes accessible (it's just an advanced\ntactic really), and can nail some really tedious-for-a-human-to-solve\ngoals. For example check out this one-line proof:\n-/\n\nexample (a b c d e : mynat) :\n(((a+b)+c)+d)+e=(c+((b+e)+a))+d := begin\n  simp\nend \n\n/-\nImagine having to do that one by hand! The AI closes the goal\nbecause it knows how to use associativity and commutativity\nsensibly in a commutative monoid.\n\nYou are now done with addition world. Go back to the main menu (top left)\nand decide whether to press on with multiplication world and power world\n(which can be solved with `rw`, `refl` and `induction`), or to go on\nto Function World where you can learn the tactics needed to prove\ngoals of the form $P\\implies Q$, thus enabling you to solve more\nadvanced addition world levels such as $a+t=b+t\\implies a=b$. Note that\nFunction World is more challenging mathematically; but if you can do Addition\nWorld you can surely do Multiplication World and Power World.\n-/\n\nend mynat -- hide\n\n/- Tactic : simp\n\n## Summary\n\nThe `simp` tactic is a high-level tactic which tries\nto prove equalities using facts in its database (such\nas `add_assoc` and `add_comm`).\n\n## Details\n\nThe `simp` tactic does basic automation. By level 6 of\nAddition World you\nhave proved enough about addition for `simp` to be able\nto solve all equalities whose proofs involve a tedious number\nof rewrites of `add_assoc` and `add_comm`, and by\nlevel 9 of Multiplication World the same is true of `mul_assoc` and `mul_comm`.\n\n### Example:\nIf our goal is this:\n```\n\u22a2 a + b + c + d + e = c + (b + e + a) + d\n```\n\nand you have completed addition world, then you've proved\nenough about addition to solve this level with `simp`. \nNote however that you can't prove `add_assoc` with `simp`,\nbecause `add_assoc` is an ingredient to get `simp` working.\n\n### Example:\nIf our goal is this:\n```\n\u22a2 a * b * c = c * b * a\n```\nthen as long as you've completed Multiplication World, `simp` will close this\ngoal.\n-/\n\n", "height": 4, "editorText": "sorry", "lineOffset": 52, "name": "add_right_comm", "statement": "(a b c : mynat) : a + b + c = a + c + b"}, {"type": "text", "content": "77"}, {"type": "lean", "content": "78", "hidden": false}, {"type": "text", "content": "79"}, {"type": "lean", "content": "80", "hidden": false}, {"type": "text", "content": "81"}, {"type": "lean", "content": "82", "hidden": true}, {"type": "tactic", "content": "83", "name": "simp", "sideBar": true}]}], "parents": [0]}, {"name": "84", "levels": [{"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "85", "hidden": true}, {"type": "lean", "content": "86", "hidden": false}, {"type": "axiom", "content": "87", "name": "mul_zero (a : mynat) :", "sideBar": true}, {"type": "axiom", "content": "88", "name": "mul_succ (a b : mynat) :", "sideBar": true}, {"type": "text", "content": "89"}, {"type": "lean", "content": "90", "hidden": true}, {"type": "lemma", "text": "91", "lean": "lemma zero_mul (m : mynat) : 0 * m = 0 :=\n", "sideBar": true, "firstProofLineNumber": 60, "lastProofLineNumber": 70, "textBefore": "import game.world2.level6 -- hide\nimport mynat.mul -- import the definition of multiplication on mynat\n\n\n/- Axiom : mul_zero (a : mynat) :\na * 0 = 0\n-/\n\n/- Axiom : mul_succ (a b : mynat) :\na * succ(b) = a * b + a\n-/\n\n/- \n\n# Multiplication World\n\nA new import! This import gives you the definition of multiplication on your\nnatural numbers. It is defined by recursion, just like addition.\nHere are the two new axioms:\n\n  * `mul_zero (a : mynat) : a * 0 = 0`\n  * `mul_succ (a b : mynat) : a * succ(b) = a * b + a`\n\nIn words, we define multiplication by \"induction on the second variable\",\nwith `a * 0` defined to be `0` and, if we know `a * b`, then `a` times\nthe number after `b` is defined to be `a * b + a`. \n\nYou can keep all the theorems you proved about addition, but \nfor multiplication, those two results above are you've got right now.\nI would recommend that you sort out the bar on the left. Fold up everything,\nand then unfold just Theorem Statements -> Multiplication World. This will\nremind you of your two new theorems, both of which are true by definition.\nIf you want to be reminded of the theorems you have proved about addition,\nyou can just open up the Addition World theorem statements and take a look. \nIf you don't want to keep opening and closing these menus, why not think\na bit about the logic behind the naming of the proofs? After a while you\nmight find that you can guess the name of the proof you want.\n\nAnyway, what's going on in multiplication world? Like addition, we need to go\nfor the proofs that multiplication\nis commutative and associative, but as well as that we will\nneed to prove facts about the relationship between multiplication\nand addition, for example `a * (b + c) = a * b + a * c`, so now\nthere is a lot more to do. Good luck! \n\nWe are given `mul_zero`, and the first thing to prove is `zero_mul`.\nLike `zero_add`, we of course prove it by induction.\n\n## Level 1: `zero_mul`\n-/\n\nnamespace mynat -- hide\n\n/- Lemma\nFor all natural numbers $m$, we have\n$$ 0 \\times m = 0. $$\n-/\nlemma zero_mul (m : mynat) : 0 * m = 0 :=\nbegin [nat_num_game]\n", "proof": "  induction m with d hd,\n  {\n    rw mul_zero,\n    refl\n  },\n  {\n    rw mul_succ,\n    rw hd,\n    rw add_zero,\n    refl\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 11, "editorText": "sorry", "lineOffset": 59, "name": "zero_mul", "statement": "(m : mynat) : 0 * m = 0"}, {"type": "lean", "content": "92", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "93", "hidden": true}, {"type": "lean", "content": "94", "hidden": true}, {"type": "lean", "content": "95", "hidden": true}, {"type": "text", "content": "96"}, {"type": "lemma", "text": "97", "lean": "lemma mul_one (m : mynat) : m * 1 = m :=\n", "sideBar": true, "firstProofLineNumber": 30, "lastProofLineNumber": 36, "textBefore": "import game.world3.level1 -- hide\nimport mynat.mul -- hide\n\nnamespace mynat -- hide\n\n/-\n# Multiplication World\n\n## Level 2: `mul_one`\n\nRemember that you can see everything you have proved so far about multiplication in\nthe drop-down box on the left (and that this list will grow as we proceed).\n\nIn this level we'll need to use\n\n* `one_eq_succ_zero : 1 = succ(0)`\n\nwhich was mentioned back in Addition World and\nwhich will be a useful thing to rewrite right now, as we\nbegin to prove a couple of lemmas about how `1` behaves\nwith respect to multiplication.\n-/\n\n/- Lemma\nFor any natural number $m$, we have\n$$ m \\times 1 = m. $$\n-/\nlemma mul_one (m : mynat) : m * 1 = m :=\nbegin [nat_num_game]\n", "proof": "  rw one_eq_succ_zero,\n  rw mul_succ,\n  rw mul_zero,\n  rw zero_add,\n  refl\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 29, "name": "mul_one", "statement": "(m : mynat) : m * 1 = m"}, {"type": "lean", "content": "98", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "99", "hidden": true}, {"type": "lean", "content": "100", "hidden": true}, {"type": "lean", "content": "101", "hidden": true}, {"type": "text", "content": "102"}, {"type": "lemma", "text": "103", "lean": "lemma one_mul (m : mynat) : 1 * m = m :=\n", "sideBar": true, "firstProofLineNumber": 30, "lastProofLineNumber": 40, "textBefore": "import game.world3.level2 -- hide\nimport mynat.mul -- hide\n\nnamespace mynat -- hide\n\n/-\n# Multiplication World\n\n## Level 3: `one_mul`\n\nThese proofs from addition world might be useful here:\n\n* `one_eq_succ_zero : 1 = succ(0)`\n* `succ_eq_add_one a : succ(a) = a + 1` \n\nWe just proved `mul_one`, now let's prove `one_mul`. \nThen we will have proved, in fancy terms,\nthat 1 is a \"left and right identity\"\nfor multiplication (just like we showed that\n0 is a left and right identity for addition\nwith `add_zero` and `zero_add`).\n-/\n\n/- Lemma\nFor any natural number $m$, we have\n$$ 1 \\times m = m. $$\n-/\nlemma one_mul (m : mynat) : 1 * m = m :=\nbegin [nat_num_game]\n", "proof": "  induction m with d hd,\n  {\n    rw mul_zero,\n    refl,\n  },\n  {\n    rw mul_succ,\n    rw hd,\n    rw succ_eq_add_one,\n    refl,\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 11, "editorText": "sorry", "lineOffset": 29, "name": "one_mul", "statement": "(m : mynat) : 1 * m = m"}, {"type": "lean", "content": "104", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "105", "hidden": true}, {"type": "lean", "content": "106", "hidden": true}, {"type": "text", "content": "107"}, {"type": "lemma", "text": "108", "lean": "lemma mul_add (t a b : mynat) : t * (a + b) = t * a + t * b :=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 45, "textBefore": "import game.world3.level3 -- hide\nnamespace mynat -- hide\n\n/-\n# Multiplication World\n\n## Level 4: `mul_add`\n\nWhere are we going? Well we want to prove `mul_comm`\nand `mul_assoc`, i.e. that `a * b = b * a` and\n`(a * b) * c = a * (b * c)`. But we *also* want to\nestablish the way multiplication interacts with addition,\ni.e. we want to prove that we can \"expand out the brackets\"\nand show `a * (b + c) = (a * b) + (a * c)`.\nThe technical term for this is \"left distributivity of\nmultiplication over addition\" (there is also right distributivity,\nwhich we'll get to later).\n\nNote the name of this proof -- `mul_add`. And note the left\nhand side -- `a * (b + c)`, a multiplication and then an addition.\nI think `mul_add` is much easier to remember than \"left_distrib\",\nan alternative name for the proof of this lemma.\n-/\n\n/- Lemma\nMultiplication is distributive over addition.\nIn other words, for all natural numbers $a$, $b$ and $t$, we have\n$$ t(a + b) = ta + tb. $$\n-/\n\nlemma mul_add (t a b : mynat) : t * (a + b) = t * a + t * b :=\nbegin [nat_num_game]\n", "proof": "  induction b with d hd,\n  { rewrite [add_zero, mul_zero, add_zero],\n  },\n  {\n    rw add_succ,\n    rw mul_succ,\n    rw hd,\n    rw mul_succ,\n    rw add_assoc, -- ;-)\n    refl,\n\n\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\ndef left_distrib := mul_add -- the \"proper\" name for this lemma\n-- I just don't instinctively know what left_distrib means -- hide\n\nend mynat -- hide\n", "height": 13, "editorText": "sorry", "lineOffset": 32, "name": "mul_add", "statement": "(t a b : mynat) : t * (a + b) = t * a + t * b"}, {"type": "lean", "content": "109", "hidden": false}, {"type": "lean", "content": "110", "hidden": true}, {"type": "lean", "content": "111", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "112", "hidden": true}, {"type": "lean", "content": "113", "hidden": true}, {"type": "lean", "content": "114", "hidden": true}, {"type": "text", "content": "115"}, {"type": "lemma", "text": "116", "lean": "lemma mul_assoc (a b c : mynat) : (a * b) * c = a * (b * c) :=\n", "sideBar": true, "firstProofLineNumber": 32, "lastProofLineNumber": 44, "textBefore": "import game.world3.level4 -- hide\nimport mynat.mul -- hide\n\nnamespace mynat -- hide\n\n/-\n# Multiplication World\n\n## Level 5: `mul_assoc`\n\nWe now have enough to prove that multiplication is associative.\n\n## Random tactic hints\n\n1) Did you know you can do `repeat {rw mul_succ}`?\n\n2) Did you know you can do `rwa [hd, mul_add]`?\nI learnt that trick from Ken Lee. Ken spotted that\n`rwa` will do the rewrites and will then check to\nsee if the goal can be proved by `refl`, and if it\ncan, it will close it! [It will also close goals which\nare exactly equal to hypotheses, which will be helpful later on.]\n-/\n\n/- Lemma\nMultiplication is associative.\nIn other words, for all natural numbers $a$, $b$ and $c$, we have\n$$ (ab)c = a(bc). $$\n-/\nlemma mul_assoc (a b c : mynat) : (a * b) * c = a * (b * c) :=\nbegin [nat_num_game]\n", "proof": "  induction c with d hd,\n  { \n    repeat {rw mul_zero},\n  },\n  {\n    rw mul_succ,\n    rw mul_succ,\n    rw hd,\n    rw mul_add,\n    refl,\n\n\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nA mathematician could now remark that you have proved that the natural\nnumbers form a monoid under multiplication.\n-/\ndef collectible_4 : monoid mynat := by structure_helper -- hide\n\nend mynat -- hide\n", "height": 13, "editorText": "sorry", "lineOffset": 31, "name": "mul_assoc", "statement": "(a b c : mynat) : (a * b) * c = a * (b * c)"}, {"type": "text", "content": "117"}, {"type": "lean", "content": "118", "hidden": true}, {"type": "lean", "content": "119", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "120", "hidden": true}, {"type": "lean", "content": "121", "hidden": true}, {"type": "lean", "content": "122", "hidden": true}, {"type": "text", "content": "123"}, {"type": "lemma", "text": "124", "lean": "lemma succ_mul (a b : mynat) : succ a * b = a * b + b :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 49, "textBefore": "import game.world3.level5 -- hide\nimport mynat.mul -- hide\nnamespace mynat -- hide\n\n/-\n# Multiplication World\n\n## Level 6: `succ_mul`\n\nWe now begin our journey to `mul_comm`, the proof that `a * b = b * a`. \nWe'll get there in level 8. Until we're there, it is frustrating\nbut true that we cannot assume commutativity. We have `mul_succ`\nbut we're going to need `succ_mul` (guess what it says -- maybe you\nare getting the hang of Lean's naming conventions). \n\nRemember also that we have tools like\n\n* `add_right_comm a b c : a + b + c = a + c + b` \n\nThese things are the tools we need to slowly build up the results\nwhich we will need to do mathematics \"normally\". \nWe also now have access to Lean's `simp` tactic,\nwhich will solve any goal which just needs a bunch\nof rewrites of `add_assoc` and `add_comm`. Use if\nyou're getting lazy!\n-/\n\n/- Lemma\nFor all natural numbers $a$ and $b$, we have\n$$ \\operatorname{succ}(a) \\times b = ab + b. $$\n-/\nlemma succ_mul (a b : mynat) : succ a * b = a * b + b :=\nbegin [nat_num_game]\n", "proof": "  induction b with d hd,\n  {\n    rw mul_zero,\n    rw mul_zero,\n    rw add_zero,\n    refl,\n  },\n  {\n    rw mul_succ,\n    rw mul_succ,\n    rw hd,\n    rw add_succ,\n    rw add_succ,\n    rw add_right_comm,\n    refl,\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 16, "editorText": "sorry", "lineOffset": 33, "name": "succ_mul", "statement": "(a b : mynat) : succ a * b = a * b + b"}, {"type": "lean", "content": "125", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "126", "hidden": true}, {"type": "lean", "content": "127", "hidden": true}, {"type": "text", "content": "128"}, {"type": "lemma", "text": "129", "lean": "lemma add_mul (a b t : mynat) : (a + b) * t = a * t + b * t :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 42, "textBefore": "import game.world3.level6 -- hide\nnamespace mynat -- hide\n\n/-\n# Multiplication World\n\n## Level 7: `add_mul`\n\nWe proved `mul_add` already, but because we don't have commutativity yet\nwe also need to prove `add_mul`. We have a bunch of tools now, so this won't\nbe too hard. You know what -- you can do this one by induction on any of\nthe variables. Try them all! Which works best? If you can't face\ndoing all the commutativity and associativity, remember the high-powered\n`simp` tactic mentioned at the bottom of Addition World level 6,\nwhich will solve any puzzle which needs only commutativity\nand associativity. If your goal looks like `a+(b+c)=c+b+a` or something,\ndon't mess around doing it explicitly with `add_comm` and `add_assoc`,\njust try `simp`.\n-/\n\n/- Lemma\nAddition is distributive over multiplication.\nIn other words, for all natural numbers $a$, $b$ and $t$, we have\n$$ (a + b) \\times t = at + bt. $$\n-/\nlemma add_mul (a b t : mynat) : (a + b) * t = a * t + b * t :=\nbegin [nat_num_game]\n", "proof": "  induction b with d hd,\n  { \n    rw zero_mul,\n    rw add_zero,\n    rw add_zero,\n    refl\n  },\n  {\n    rw add_succ,\n    rw succ_mul,\n    rw hd,\n    rw succ_mul,\n    rw add_assoc,\n    refl\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nA mathematician would now say that you have proved that the natural\nnumbers are a semiring. This sounds like a respectable result.\n-/\n\ndef right_distrib := add_mul -- alternative name\ninstance : semiring mynat := by structure_helper\n\n/-\nLean would add that you have also proved that they are a `distrib`. \nHowever this concept has no mathematical name at all -- this says something\nabout the regard with which mathematicians hold this collectible.\nThis is an artefact of the set-up of collectibles in Lean. You consider politely\ndeclining Lean's offer of a `distrib` collectible.\nYou are dreaming of the big collectible at the end of power world.\n-/\n\ninstance : distrib mynat := by structure_helper -- \n\nend mynat -- hide\n", "height": 15, "editorText": "sorry", "lineOffset": 27, "name": "add_mul", "statement": "(a b t : mynat) : (a + b) * t = a * t + b * t"}, {"type": "text", "content": "130"}, {"type": "lean", "content": "131", "hidden": false}, {"type": "text", "content": "132"}, {"type": "lean", "content": "133", "hidden": false}, {"type": "lean", "content": "134", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "135", "hidden": true}, {"type": "lean", "content": "136", "hidden": true}, {"type": "text", "content": "137"}, {"type": "lemma", "text": "138", "lean": "lemma mul_comm (a b : mynat) : a * b = b * a :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 33, "textBefore": "import game.world3.level7 -- hide\nnamespace mynat -- hide\n\n/-\n# Multiplication World\n\n## Level 8: `mul_comm`\n\nFinally, the boss level of multiplication world. But (assuming you\ndidn't cheat) you are well-prepared for it -- you have `zero_mul`\nand `mul_zero`, as well as `succ_mul` and `mul_succ`. After this\nlevel you can of course throw away one of each pair if you like,\nbut I would recommend you hold on to them, sometimes it's convenient\nto have exactly the right tools to do a job.\n-/\n\n/- Lemma\nMultiplication is commutative.\n-/\nlemma mul_comm (a b : mynat) : a * b = b * a :=\nbegin [nat_num_game]\n", "proof": "  induction b with d hd,\n  { \n    rw zero_mul,\n    rw mul_zero,\n    refl,\n  },\n  {\n    rw succ_mul,\n    rw \u2190hd,\n    rw mul_succ,\n    refl,\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nYou've now proved that the natural numbers are a commutative semiring!\nThat's the last collectible in Multiplication World. \n-/\ninstance mynat.comm_semiring : comm_semiring mynat := by structure_helper\n/-\nBut don't leave multiplication just yet -- prove `mul_left_comm`, the last\nlevel of the world, and then we can beef up the power of `simp`. \n-/\n\nend mynat -- hide\n", "height": 12, "editorText": "sorry", "lineOffset": 21, "name": "mul_comm", "statement": "(a b : mynat) : a * b = b * a"}, {"type": "text", "content": "139"}, {"type": "lean", "content": "140", "hidden": false}, {"type": "text", "content": "141"}, {"type": "lean", "content": "142", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "143", "hidden": true}, {"type": "lean", "content": "144", "hidden": true}, {"type": "lean", "content": "145", "hidden": true}, {"type": "text", "content": "146"}, {"type": "lemma", "text": "147", "lean": "lemma mul_left_comm (a b c : mynat) : a * (b * c) = b * (a * c) :=\n", "sideBar": true, "firstProofLineNumber": 25, "lastProofLineNumber": 31, "textBefore": "import game.world3.level8 -- hide\nimport mynat.mul -- hide\nnamespace mynat -- hide\n\n/-\n# Multiplication World\n\n## Level 9: `mul_left_comm`\n\nYou are equipped with\n\n* `mul_assoc (a b c : mynat) : (a * b) * c = a * (b * c)`\n* `mul_comm (a b : mynat) : a * b = b * a`\n\nRe-read the docs for `rw` so you know all the tricks.\nYou can see them in the \"tactics\" drop-down menu on the left.\n-/\n\n/- Lemma\nFor all natural numbers $a$ $b$ and $c$, we have\n$$a(bc)=b(ac)$$\n-/\nlemma mul_left_comm (a b c : mynat) : a * (b * c) = b * (a * c) :=\nbegin [nat_num_game]\n", "proof": "  rw \u2190mul_assoc,\n  rw mul_comm a, \n  rw mul_assoc,\n  refl,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nAnd now I whisper a magic incantation\n-/\nattribute [simp] mul_assoc mul_comm mul_left_comm\n/-\nand all of a sudden Lean can automatically do levels which are\nvery boring for a human, for example\n-/\nexample (a b c d e : mynat) :\n(((a*b)*c)*d)*e=(c*((b*e)*a))*d :=\nbegin\n  simp,\nend \n\n/-\nIf you feel like attempting Advanced Multiplication world\nyou'll have to do Function World and the Proposition Worlds first.\nThese worlds assume a certain amount of mathematical maturity\n(perhaps 1st year undergraduate level). \nYour other possibility is Power World, with the \"final boss\".\n-/\n\nend mynat -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 24, "name": "mul_left_comm", "statement": "(a b c : mynat) : a * (b * c) = b * (a * c)"}, {"type": "text", "content": "148"}, {"type": "lean", "content": "149", "hidden": false}, {"type": "text", "content": "150"}, {"type": "lean", "content": "151", "hidden": false}, {"type": "text", "content": "152"}, {"type": "lean", "content": "153", "hidden": true}]}], "parents": [1]}, {"name": "154", "levels": [{"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "155", "hidden": true}, {"type": "lean", "content": "156", "hidden": false}, {"type": "lean", "content": "157", "hidden": true}, {"type": "axiom", "content": "158", "name": "pow_zero (a : mynat) :", "sideBar": true}, {"type": "axiom", "content": "159", "name": "pow_succ (a b : mynat) :", "sideBar": true}, {"type": "text", "content": "160"}, {"type": "lemma", "text": "161", "lean": "lemma zero_pow_zero : (0 : mynat) ^ (0 : mynat) = 1 :=\n", "sideBar": true, "firstProofLineNumber": 49, "lastProofLineNumber": 52, "textBefore": "import game.world3.level9 -- hide\nimport mynat.pow -- new import\nnamespace mynat -- hide\n\n\n/- Axiom : pow_zero (a : mynat) :\na ^ 0 = 1\n-/\n\n/- Axiom : pow_succ (a b : mynat) :\na ^ succ(b) = a ^ b * a\n-/\n\n/- \n\n# Power World\n\nA new world with seven levels. And a new import!\nThis import gives you the power to make powers of your\nnatural numbers. It is defined by recursion, just like addition and multiplication.\nHere are the two new axioms:\n\n  * `pow_zero (a : mynat) : a ^ 0 = 1`\n  * `pow_succ (a b : mynat) : a ^ succ(b) = a ^ b * a`\n\nThe power function has various relations to addition and multiplication.\nIf you have gone through levels 1--6 of addition world and levels 1--9 of\nmultiplication world, you should have no trouble with this world:\nThe usual tactics `induction`, `rw` and `refl` should see you through.\nYou might want to fiddle with the\ndrop-down menus on the left so you can see which theorems of Power World\nyou have proved at any given time. Addition and multiplication -- we\nhave a solid API for them now, i.e. if you need something about addition\nor multiplication, it's probably already in the library we have built.\nCollectibles are indication that we are proving the right things.\n\nThe levels in this world were designed by Sian Carey, a UROP student\nat Imperial College London, funded by a Mary Lister McCammon Fellowship,\nin the summer of 2019. Thanks Sian!\n\n## Level 1: `zero_pow_zero`\n-/\n\n/- Lemma\n$0 ^ 0 = 1$.\n-/\nlemma zero_pow_zero : (0 : mynat) ^ (0 : mynat) = 1 :=\nbegin [nat_num_game]\n", "proof": "  rw pow_zero,\n  refl,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 4, "editorText": "sorry", "lineOffset": 48, "name": "zero_pow_zero", "statement": "(0 : mynat) ^ (0 : mynat) = 1"}, {"type": "lean", "content": "162", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "163", "hidden": true}, {"type": "lean", "content": "164", "hidden": true}, {"type": "text", "content": "165"}, {"type": "lemma", "text": "166", "lean": "lemma zero_pow_succ (m : mynat) : (0 : mynat) ^ (succ m) = 0 :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 20, "textBefore": "import game.world4.level1 -- hide\nnamespace mynat -- hide\n\n/- \n\n# Power World\n\n## Level 2: `zero_pow_succ`\n-/\n\n/- Lemma\nFor all naturals $m$, $0 ^{succ (m)} = 0$.\n-/\nlemma zero_pow_succ (m : mynat) : (0 : mynat) ^ (succ m) = 0 :=\nbegin [nat_num_game]\n", "proof": "  rw pow_succ,\n  rw mul_zero,\n  refl,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 5, "editorText": "sorry", "lineOffset": 15, "name": "zero_pow_succ", "statement": "(m : mynat) : (0 : mynat) ^ (succ m) = 0"}, {"type": "lean", "content": "167", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "168", "hidden": true}, {"type": "lean", "content": "169", "hidden": true}, {"type": "text", "content": "170"}, {"type": "lemma", "text": "171", "lean": "lemma pow_one (a : mynat) : a ^ (1 : mynat) = a :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 21, "textBefore": "import game.world4.level2 -- hide\nnamespace mynat -- hide\n\n/- \n\n# Power World\n\n## Level 3: `pow_one`\n-/\n\n/- Lemma\nFor all naturals $a$, $a ^ 1 = a$.\n-/\nlemma pow_one (a : mynat) : a ^ (1 : mynat) = a :=\nbegin [nat_num_game]\n", "proof": "  rw one_eq_succ_zero,\n  rw pow_succ,\n  rw pow_zero,\n  rw one_mul,\n  refl,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 6, "editorText": "sorry", "lineOffset": 15, "name": "pow_one", "statement": "(a : mynat) : a ^ (1 : mynat) = a"}, {"type": "lean", "content": "172", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "173", "hidden": true}, {"type": "lean", "content": "174", "hidden": true}, {"type": "text", "content": "175"}, {"type": "lemma", "text": "176", "lean": "lemma one_pow (m : mynat) : (1 : mynat) ^ m = 1 :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 23, "textBefore": "import game.world4.level3 -- hide\nnamespace mynat -- hide\n\n/- \n\n# Power World\n\n## Level 4: `one_pow`\n-/\n\n/- Lemma\nFor all naturals $m$, $1 ^ m = 1$.\n-/\nlemma one_pow (m : mynat) : (1 : mynat) ^ m = 1 :=\nbegin [nat_num_game]\n", "proof": "  induction m with t ht,\n    rw pow_zero,\n    refl,\n  rw pow_succ,\n  rw ht,\n  rw mul_one,\n  refl,\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 15, "name": "one_pow", "statement": "(m : mynat) : (1 : mynat) ^ m = 1"}, {"type": "lean", "content": "177", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "178", "hidden": true}, {"type": "lean", "content": "179", "hidden": true}, {"type": "text", "content": "180"}, {"type": "lemma", "text": "181", "lean": "lemma pow_add (a m n : mynat) : a ^ (m + n) = a ^ m * a ^ n :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 24, "textBefore": "import game.world4.level4 -- hide\nnamespace mynat -- hide\n\n/- \n\n# Power World\n\n## Level 5: `pow_add`\n-/\n\n/- Lemma\nFor all naturals $a$, $m$, $n$, we have $a^{m + n} = a ^ m  a ^ n$.\n-/\nlemma pow_add (a m n : mynat) : a ^ (m + n) = a ^ m * a ^ n :=\nbegin [nat_num_game]\n", "proof": "  induction n with t ht,\n    rw [add_zero, pow_zero, mul_one],\n    refl,\n  rw [add_succ, pow_succ, pow_succ, ht, mul_assoc],\n  refl,\n\n  \n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 9, "editorText": "sorry", "lineOffset": 15, "name": "pow_add", "statement": "(a m n : mynat) : a ^ (m + n) = a ^ m * a ^ n"}, {"type": "lean", "content": "182", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "183", "hidden": true}, {"type": "lean", "content": "184", "hidden": true}, {"type": "text", "content": "185"}, {"type": "lemma", "text": "186", "lean": "lemma mul_pow (a b n : mynat) : (a * b) ^ n = a ^ n * b ^ n :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 29, "textBefore": "import game.world4.level5 -- hide\nnamespace mynat -- hide\n\n/- \n\n# Power World\n\n## Level 6: `mul_pow`\n\nYou might find the tip at the end of level 9 of Multiplication World\nuseful in this one. You can go to the main menu and pop back into\nMultiplication World and take a look -- you won't lose any of your\nproofs. You'll only lose proofs if you reload the page.\n-/\n\n\n/- Lemma\nFor all naturals $a$, $b$, $n$, we have $(ab) ^ n = a ^ nb ^ n$.\n-/\nlemma mul_pow (a b n : mynat) : (a * b) ^ n = a ^ n * b ^ n :=\nbegin [nat_num_game]\n", "proof": "  induction n with t Ht,\n    rw [pow_zero, pow_zero, pow_zero, mul_one],\n    refl,\n  rw [pow_succ, pow_succ, pow_succ, Ht],\n  simp,\n\n  \n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 21, "name": "mul_pow", "statement": "(a b n : mynat) : (a * b) ^ n = a ^ n * b ^ n"}, {"type": "lean", "content": "187", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "188", "hidden": true}, {"type": "lean", "content": "189", "hidden": true}, {"type": "text", "content": "190"}, {"type": "text", "content": "191"}, {"type": "lemma", "text": "192", "lean": "lemma pow_pow (a m n : mynat) : (a ^ m) ^ n = a ^ (m * n) :=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 29, "textBefore": "import game.world4.level6 -- hide\nnamespace mynat -- hide\n\n/- \n\n# Power World\n\n## Level 7: `pow_pow`\n-/\n\n/-\nBoss level! What will the collectible be?\n-/\n/- Lemma\nFor all naturals $a$, $m$, $n$, we have $(a ^ m) ^ n = a ^ {mn}$.\n-/\nlemma pow_pow (a m n : mynat) : (a ^ m) ^ n = a ^ (m * n) :=\nbegin [nat_num_game]\n", "proof": "  induction' n with t Ht,\n    rw [mul_zero, pow_zero, pow_zero],\n    refl,\n  rw [pow_succ, Ht, mul_succ, pow_add],\n  refl,\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nApparently Lean can't find a collectible, even though you feel like you\njust finished power world so you must have proved *something*. What should the\ncollectible for this level be called? \n-/\n\n/-\nBut what is this? It's one of those twists where there's another\nboss after the boss you thought was the final boss! Go to the next\nlevel!\n-/\n\nend mynat -- hide\n", "height": 11, "editorText": "sorry", "lineOffset": 18, "name": "pow_pow", "statement": "(a m n : mynat) : (a ^ m) ^ n = a ^ (m * n)"}, {"type": "text", "content": "193"}, {"type": "text", "content": "194"}, {"type": "lean", "content": "195", "hidden": true}]}, {"name": "", "problemIndex": 8, "objects": [{"type": "lean", "content": "196", "hidden": true}, {"type": "lean", "content": "197", "hidden": true}, {"type": "lean", "content": "198", "hidden": true}, {"type": "lean", "content": "199", "hidden": true}, {"type": "lean", "content": "200", "hidden": true}, {"type": "lean", "content": "201", "hidden": true}, {"type": "text", "content": "202"}, {"type": "text", "content": "203"}, {"type": "theorem", "text": "204", "lean": "lemma add_squared (a b : mynat) :\n  (a + b) ^ (2 : mynat) = a ^ (2 : mynat) + b ^ (2 : mynat) + 2 * a * b :=\n", "sideBar": true, "firstProofLineNumber": 40, "lastProofLineNumber": 66, "textBefore": "import game.world4.level7 -- hide\n-- incantation for importing ring into framework -- hide\nimport tactic.ring -- hide\nmeta def nat_num_game.interactive.ring := tactic.interactive.ring -- hide\nnamespace mynat -- hide\n\ndef two_eq_succ_one : (2 : mynat) = succ 1 := rfl -- hide\n\n/- \n# Power World\n-/\n\n/-\n## Level 8: `add_squared`\n\n[final boss music] \n\nYou see something written on the stone dungeon wall:\n```\nbegin\n  rw two_eq_succ_one,\n  rw one_eq_succ_zero,\n  repeat {rw pow_succ},\n  ...\n```\n\nand you can't make out the last two lines because there's a kind\nof thing in the way that will magically disappear\nbut only when you've beaten the boss.\n\n-/\n\n/- Theorem\nFor all naturals $a$ and $b$, we have\n$$(a+b)^2=a^2+b^2+2ab.$$\n-/\nlemma add_squared (a b : mynat) :\n  (a + b) ^ (2 : mynat) = a ^ (2 : mynat) + b ^ (2 : mynat) + 2 * a * b :=\nbegin [nat_num_game]\n", "proof": "  rw two_eq_succ_one,\n  rw one_eq_succ_zero,\n  repeat {rw pow_succ},\n  repeat {rw pow_zero},\n  ring,\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- \nAs the boss lies smouldering, you notice on the dungeon wall that\n<a href=\"https://twitter.com/XenaProject/status/1190453646904958976?s=20/\" target=\"blank\">\ntwo more lines of code are now visible under the first three...</a> (Twitter.com)\n\nI just beat this level with 27 single rewrites followed by a `refl`. \nCan you do any better? (The current rewrite record is 25 -- see <a href=\"https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function.20with.20random.20definition/near/179723073\" target=\"blank\">here</a>\n(needs zulip login)).\nIf you beat it then well done! Do you\nfancy doing $(a+b)^3$ now? You might want to read \n<a href=\"https://xenaproject.wordpress.com/2018/06/13/ab3/\" target=\"blank\">\nthis Xena Project blog post</a> before you start though.\n-/\n\n/-\nIf you got this far -- very well done! If you only learnt the three\ntactics `rw`, `induction` and `refl` then there are now more tactics to\nlearn; go back to the main menu and choose Function World. \n\nThe main thing we really want to impress upon people is that we believe\nthat *all of pure mathematics* can be done in this new way.\nA system called Coq (which is very like Lean) has\n<a href=\"https://hal.inria.fr/hal-00816699\" target=\"blank\">\nchecked the proof of the Feit-Thompson theorem</a> (hundreds of pages of\ngroup theory) and Lean has a\n<a href=\"https://leanprover-community.github.io/lean-perfectoid-spaces/\"\n  target=\"blank\">\ndefinition of perfectoid spaces</a> (a very complex modern\nmathematical structure). I believe that these systems will one day\ncause a paradigm shift in the way mathematics is done, but first we need\nto build what we know, or at least build enough to state what we\nmathematicians believe. If you want to get involved, come and join\nus at the <a href=\"https://leanprover.zulipchat.com\" target=\"blank\">Zulip Lean chat</a>.\nThe #new members stream is a great place to start asking questions.\n\nTo come (possibly): the real number game, the group theory game,\nthe integer game, the natural number game 2,... . Alternatively\nsee <a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/FAQ.html\" target=\"blank\">the FAQ</a>\nfor some more ideas about what to do next.\n\n-/\n\nend mynat -- hide\n", "height": 27, "editorText": "sorry", "lineOffset": 39, "name": "add_squared", "statement": "(a b : mynat) :\n  (a + b) ^ (2 : mynat) = a ^ (2 : mynat) + b ^ (2 : mynat) + 2 * a * b"}, {"type": "text", "content": "205"}, {"type": "text", "content": "206"}, {"type": "lean", "content": "207", "hidden": true}]}], "parents": [2]}, {"name": "208", "levels": [{"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "209"}, {"type": "definition", "text": "210", "lean": "example (P Q : Type) (p : P) (h : P \u2192 Q) : Q :=\n", "sideBar": false, "firstProofLineNumber": 102, "lastProofLineNumber": 105, "textBefore": "/- \n\n# Function world. \n\nIf you have beaten Addition World, then you have got\nquite good at manipulating equalities in Lean using the `rw` tactic.\nBut there are plenty of levels later on which will require you\nto manipulate functions, and `rw` is not the tool for you here.\n\nTo manipulate functions effectively, we need to learn about a new collection\nof tactics, namely `exact`, `intro`, `have` and `apply`. These tactics\nare specially designed for dealing with functions. Of course we are\nultimately interested in using these tactics to prove theorems\nabout the natural numbers &ndash; but in this\nworld there is little point in working with specific sets like `mynat`,\neverything works for general sets.\n\nSo our notation for this level is: $P$, $Q$, $R$ and so on denote general sets,\nand $h$, $j$, $k$ and so on denote general\nfunctions between them. What we will learn in this world is how to use functions\nin Lean to push elements from set to set. A word of warning &ndash; \neven though there's no harm at all in thinking of $P$ being a set and $p$\nbeing an element, you will not see Lean using the notation $p\\in P$, because\ninternally Lean stores $P$ as a \"Type\" and $p$ as a \"term\", and it uses `p : P`\nto mean \"$p$ is a term of type $P$\", Lean's way of expressing the idea that $p$\nis an element of the set $P$. You have seen this already &ndash; Lean has\nbeen writing `n : mynat` to mean that $n$ is a natural number.\n\n## A new kind of goal.\n\nAll through addition world, our goals have been theorems,\nand it was our job to find the proofs. \n**The levels in function world aren't theorems**. This is the only world where\nthe levels aren't theorems in fact. In function world the object of a level\nis to create an element of the set in the goal. The goal will look like `\u22a2 X`\nwith $X$ a set and you get rid of the goal by constructing an element of $X$. \nI don't know if you noticed this, but you finished\nessentially every goal of Addition World (and Multiplication World and Power World,\nif you played them) with `refl`.\nThis tactic is no use to us here.\nWe are going to have to learn a new way of solving goals &ndash; the `exact` tactic.\n\nIf you delete the sorry below then your local context will look like this:\n\n```\nP Q : Type,\np : P,\nh : P \u2192 Q\n\u22a2 Q\n```\n\nIn this situation, we have sets $P$ and $Q$ (but Lean calls them types),\nand an element $p$ of $P$ (written `p : P`\nbut meaning $p\\in P$). We also have a function $h$ from $P$ to $Q$,\nand our goal is to construct an\nelement of the set $Q$. It's clear what to do *mathematically* to solve\nthis goal -- we can\nmake an element of $Q$ by applying the function $h$ to\nthe element $p$. But how to do it in Lean? There are at least two ways\nto explain this idea to Lean,\nand here we will learn about one of them, namely the method which\nuses the `exact` tactic.\n\n## The `exact` tactic. \n\nIf you can explicitly see how to make an element of your goal set,\ni.e. you have a formula for it, then you can just write `exact <formula>` \nand this will close the goal. \n\n### Example\n\nIf your local context looks like this\n\n```\nP Q : Type,\np : P,\nh : P \u2192 Q\n\u22a2 Q\n```\n\nthen $h(p)$ is an element of $Q$ so you can just write\n\n`exact h(p),`\n\nto close the goal. \n\n## Important note\n\nNote that `exact h(P),` won't work (with a capital $P$);\nthis is a common error I see from beginners. \n$P$ is not an element of $P$, it's $p$ that is an element of $P$. \n\n## Level 1: the `exact` tactic.\n-/\n\n/- Definition\nGiven an element of $P$ and a function from $P$ to $Q$,\nwe define an element of $Q$.\n-/\nexample (P Q : Type) (p : P) (h : P \u2192 Q) : Q :=\nbegin\n", "proof": "exact h(p),\n\n\n", "proof_hint": "sorry", "textAfter": "\nend \n\n/- Tactic : exact\n\n## Summary \n\nIf the goal is `\u22a2 X` then `exact x` will close the goal if\nand only if `x` is a term of type `X`. \n\n## Details\n\nSay $P$, $Q$ and $R$ are types (i.e., what a mathematician\nmight think of as either sets or propositions),\nand the local context looks like this: \n\n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\n\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n\n`exact j(h(p)),`\n\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n\n-/\n\n", "height": 4, "editorText": "sorry", "lineOffset": 101, "name": "", "statement": "(P Q : Type) (p : P) (h : P \u2192 Q) : Q"}, {"type": "tactic", "content": "211", "name": "exact", "sideBar": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "212", "hidden": false}, {"type": "tactic", "content": "213", "name": "intro", "sideBar": true}, {"type": "text", "content": "214"}, {"type": "definition", "text": "215", "lean": "example : mynat \u2192 mynat :=\n", "sideBar": false, "firstProofLineNumber": 125, "lastProofLineNumber": 129, "textBefore": "import mynat.add -- + on mynat\nimport mynat.mul -- * on mynat\n\n\n\n/- Tactic : intro\n\n## Summary:\n\n`intro p` will turn a goal `\u22a2 P \u2192 Q` into a hypothesis `p : P`\nand goal `\u22a2 Q`. If `P` and `Q` are sets `intro p` means \"let $p$ be an arbitrary element of $P$\".\nIf `P` and `Q` are propositions then `intro p` says \"assume $P$ is true\". \n\n## Details\n\nIf your goal is a function or an implication `\u22a2 P \u2192 Q` then `intro`\nwill always make progress. `intro p` turns\n\n`\u22a2 P \u2192 Q`\n\ninto \n\n```\np : P\n\u22a2 Q\n```\n\nThe opposite tactic to intro is `revert`; given the situation\njust above, `revert p` turns the goal back into `\u22a2 P \u2192 Q`.\n\nThere are two points of view with `intro` -- the\nfunction point of view (Function World) and the proposition\npoint of view (Proposition World).\n\n## Example (functions)\n\nWhat does it mean to define\na function? Given an arbitrary term of type `P` (or an element\nof the set `P` if you think set-theoretically) you need\nto come up with a term of type `Q`, so your first step is\nto choose `p`, an arbitary element of `P`. \n\n`intro p,` is Lean's way of saying \"let $p\\in P$ be arbitrary\".\nThe tactic `intro p` changes\n\n```\n\u22a2 P \u2192 Q\n```\n\ninto\n\n```\np : P\n\u22a2 Q\n```\n\nSo `p` is an arbitrary element of `P` about which nothing is known,\nand our task is to come up with an element of `Q` (which can of\ncourse depend on `p`).\n\n## Example (propositions)\n\nIf your goal is an implication $P\\implies Q$ then Lean writes\nthis as `\u22a2 P \u2192 Q`, and `intro p,` can be thought of as meaning\n\"let $p$ be a proof of $P$\", or more informally \"let's assume that\n$P$ is true\". The goal changes to `\u22a2 Q` and the hypothesis `p : P`\nappears in the local context.\n-/\n\n/-\n# Function world. \n\n## Level 2: the `intro` tactic.\n\nLet's make a function. Let's define the function on the natural\nnumbers which sends a natural number $n$ to $3n+2$. If you delete the\n`sorry` you will see that our goal is `mynat \u2192 mynat`. A mathematician\nmight denote this set with some exotic name such as\n$\\operatorname{Hom}(\\mathbb{N},\\mathbb{N})$,\nbut computer scientists use notation `X \u2192 Y` to denote the set of\nfunctions from `X` to `Y` and this name definitely has its merits.\nIn type theory, `X \u2192 Y` is a type (the type of all functions from $X$ to $Y$),\nand `f : X \u2192 Y` means that `f` is a term\nof this type, i.e., $f$ is a function from $X$ to $Y$.\n\nTo define a function $X\\to Y$ we need to choose an arbitrary\nelement $x\\in X$ and then, perhaps using $x$, make an element of $Y$.\nThe Lean tactic for \"let $x\\in X$ be arbitrary\" is `intro x`.\n\n## Rule of thumb: \n\nIf your goal is `P \u2192 Q` then `intro p` will make progress.\n\nTo solve the goal below, you have to come up with a function from `mynat`\nto `mynat`. Start with\n\n`intro n,`\n\n(i.e. \"let $n\\in\\mathbb{N}$ be arbitrary\") and note that our\nlocal context now looks like this:\n\n```\nn : mynat\n\u22a2 mynat\n```\n\nOur job now is to construct a natural number, which is\nallowed to depend on $n$. We can do this using `exact` and\nwriting a formula for the function we want to define. For example\nwe imported addition and multiplication at the top of this file,\nso \n\n`exact 3*n+2,`\n\nwill close the goal, ultimately defining the function $f(n)=3n+2$.\n\n-/ \n\n\n/- Definition\nWe define a function from mynat to mynat.\n-/\nexample : mynat \u2192 mynat :=\nbegin [nat_num_game]\n", "proof": "  intro n,\n  exact 3*n+2,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 5, "editorText": "sorry", "lineOffset": 124, "name": "", "statement": "mynat \u2192 mynat"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "tactic", "content": "216", "name": "have", "sideBar": true}, {"type": "text", "content": "217"}, {"type": "definition", "text": "218", "lean": "example (P Q R S T U: Type)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U :=\n", "sideBar": false, "firstProofLineNumber": 122, "lastProofLineNumber": 127, "textBefore": "/- Tactic : have\n\n## Summary\n\n`have h : P,` will create a new goal of creating a term of type `P`,\nand will add `h : P` to the hypotheses for the goal you were working on.\n\n## Details\n\nIf you want to name a term of some type (because you want it\nin your local context for some reason), and if you have the\nformula for the term, you can use `have` to give the term a name. \n\n## Example (`have q := ...` or `have q : Q := ...`)\n\nIf the local context contains\n```\nf : P \u2192 Q\np : P\n```\n\nthen the tactic `have q := f(p),` will add `q` to our local context,\nleaving it like this:\n\n```\nf : P \u2192 Q\np : P\nq : Q\n```\n\nIf you think about it, you don't ever really need `q`, because whenever you\nthink you need it you coudl just use `f(p)` instead. But it's good that\nwe can introduce convenient notation like this.\n\n## Example (`have q : Q,`)\n\nA variant of this tactic can be used where you just declare the\ntype of the term you want to have, finish the tactic statement with\na comma and no `:=`, and then Lean just adds it as a new goal.\nThe number of goals goes up by one if you use `have` like this.\n\nFor example if the local context is\n```\nP Q R : Prop/Type,\nf : P \u2192 Q,\ng : Q \u2192 R,\np : P\n\u22a2 R\n```\n\nthen after `have q : Q,`, there will be the new goal\n```\nf : P \u2192 Q,\ng : Q \u2192 R,\np : P,\n\u22a2 Q\n```\n\nand your original goal will have `q : Q` added to the list\nof hypotheses.\n-/\n\n/-\n# Function world. \n\n## Level 3: the `have` tactic.\n\nSay you have a whole bunch of sets and functions between them,\nand your goal is to build a certain element of a certain set.\nIf it helps, you can build intermediate elements of other sets\nalong the way, using the `have` command. `have` is the Lean analogue\nof saying \"let's define an element $q\\in Q$ by...\" in the middle of a calculation.\nIt is often not logically necessary, but on the other hand\nit is very convenient, for example it can save on notation, or\nit can break proofs or calculations up into smaller steps.\n\nIn the level below, we have an element of $P$ and we want an element\nof $U$; during the proof we will make several intermediate elements\nof some of the other sets involved. The diagram of sets and\nfunctions looks like this pictorially:\n\n![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game_images/function_diag.jpg)\n\nand so it's clear how to make the element of $U$ from the element of $P.$\nIndeed, we could solve this level in one move by typing\n\n`exact l(j(h(p))),`\n\nBut let us instead stroll more lazily through the level.\nWe can start by using the `have` tactic to make an element of $Q$:\n\n`have q := h(p),`\n\nand then we note that $j(q)$ is an element of $T$\n\n`have t : T := j(q),`\n\n(notice how on this occasion we explicitly told Lean what set we thought $t$ was in, with\nthat `: T` thing before the `:=`) and we could even define $u$ to be $l(t)$:\n\n`have u : U := l(t),`\n\nand then finish the level with\n\n`exact u,`\n\n. \n-/\n\n/- Definition\nGiven an element of $P$ we can define an element of $U$.\n-/\nexample (P Q R S T U: Type)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U :=\nbegin\n", "proof": "  have q := h(p),\n  have t : T := j(q),\n  have u : U := l(t),\n  exact u,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nIf you solved the level using `have`, then click on the last line of your proof\n(you do know you can move your cursor around with the arrow keys\nand explore your proof, right?) and note that the local context at that point\nis in something like the following mess:\n\n```\nP Q R S T U : Type,\np : P,\nh : P \u2192 Q,\ni : Q \u2192 R,\nj : Q \u2192 T,\nk : S \u2192 T,\nl : T \u2192 U,\nq : Q,\nt : T,\nu : U\n\u22a2 U\n```\n\nIt was already bad enough to start with, and we added three more\nterms to it. In level 4 we will learn about the `apply` tactic\nwhich solves the level using another technique, without leaving\nso much junk behind.\n-/", "height": 6, "editorText": "sorry", "lineOffset": 121, "name": "", "statement": "(P Q R S T U: Type)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U"}, {"type": "text", "content": "219"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "tactic", "content": "220", "name": "apply", "sideBar": true}, {"type": "text", "content": "221"}, {"type": "definition", "text": "222", "lean": "example (P Q R S T U: Type)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U :=\n", "sideBar": false, "firstProofLineNumber": 66, "lastProofLineNumber": 72, "textBefore": "/- Tactic : apply\n\n## Summary\n\nIf `h : P \u2192 Q` is a hypothesis, and the goal is `\u22a2 Q` then\n`apply h` changes the goal to `\u22a2 P`. \n\n## Details\n\nIf you have a function `h : P \u2192 Q` and your goal is `\u22a2 Q`\nthen `apply h` changes the goal to `\u22a2 P`. The logic is\nsimple: if you are trying to create a term of type `Q`,\nbut `h` is a function which turns terms of type `P` into\nterms of type `Q`, then it will suffice to construct a\nterm of type `P`. A mathematician might say: \"we need\nto construct an element of $Q$, but we have a function $h:P\\to Q$\nso it suffices to construct an element of $P$\". Or alternatively\n\"we need to prove $Q$, but we have a proof $h$ that $P\\implies Q$\nso it suffices to prove $P$\".\n\n-/\n\n/-\n\n# Function world. \n\n## Level 4: the `apply` tactic.\n\nLet's do the same level again:\n\n![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game_images/function_diag.jpg)\n\nWe are given $p \\in P$ and our goal is to find an element of $U$, or\nin other words to find a path through the maze that links $P$ to $U$.\nIn level 3 we solved this by using `have`s to move forward, from $P$\nto $Q$ to $T$ to $U$. Using the `apply` tactic we can instead construct\nthe path backwards, moving from $U$ to $T$ to $Q$ to $P$.\n\nOur goal is to construct an element of the set $U$. But $l:T\\to U$ is\na function, so it would suffice to construct an element of $T$. Tell\nLean this by starting the proof below with\n\n`apply l,`\n\nand notice that our assumptions don't change but *the goal changes*\nfrom `\u22a2 U` to `\u22a2 T`. \n\nKeep `apply`ing functions until your goal is `P`, and try not\nto get lost! Now solve this goal\nwith `exact p`. Note: you will need to learn the difference between\n`exact p` (which works) and `exact P` (which doesn't, because $P$ is\nnot an element of $P$).\n-/\n/- Definition\nGiven an element of $P$ we can define an element of $U$.\n-/\nexample (P Q R S T U: Type)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U :=\nbegin\n", "proof": "  apply l,\n  apply j,\n  apply h,\n  exact p,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 65, "name": "", "statement": "(P Q R S T U: Type)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "223"}, {"type": "definition", "text": "224", "lean": "example (P Q : Type) : P \u2192 (Q \u2192 P) :=\n", "sideBar": false, "firstProofLineNumber": 49, "lastProofLineNumber": 53, "textBefore": "/-\n# Function world. \n\n## Level 5: `P \u2192 (Q \u2192 P)`.\n\nIn this level, our goal is to construct a function, like in level 2.\n\n```\n\u22a2 P \u2192 (Q \u2192 P)\n```\n\nSo $P$ and $Q$ are sets, and our goal is to construct a function\nwhich takes an element of $P$ and outputs a function from $Q$ to $P$.\nWe don't know anything at all about the sets $P$ and $Q$, so initially\nthis seems like a bit of a tall order. But let's give it a go. Delete\nthe `sorry` and let's think about how to proceed.\n\nOur goal is `P \u2192 X` for some set $X=\\operatorname{Hom}(Q,P)$, and if our\ngoal is to construct a function then we almost always want to use the\n`intro` tactic from level 2, Lean's version of \"let $p\\in P$ be arbitrary.\"\nSo let's start with\n\n`intro p,`\n\nand we then find ourselves in this state:\n\n```\nP Q : Type,\np : P\n\u22a2 Q \u2192 P\n```\n\nWe now have an arbitrary element $p\\in P$ and we are supposed to be constructing\na function $Q\\to P$. Well, how about the constant function, which sends everything to $p$?\nThis will work. So let $q\\in Q$ be arbitrary:\n\n`intro q,`\n\nand then let's output `p`.\n\n`exact p,`\n-/\n\n/- Definition\nWe define an element of $\\operatorname{Hom}(P,\\operatorname{Hom}(Q,P))$.\n-/\nexample (P Q : Type) : P \u2192 (Q \u2192 P) :=\nbegin\n", "proof": "  intro p,\n  intro q,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nA mathematician would treat the set `P \u2192 (Q \u2192 P)` as the same as the set `P \u00d7 Q \u2192 P`,\nbecause to give an element of either function space is just to give a rule which takes\nan element of $P$ and an element of $Q$, and returns an element of $P$. Thinking of the\ngoal as a function from `P \u00d7 Q` to `P` we realise that it's just projection onto the first\nfactor.\n\n## Did you notice?\n\nI wrote `P \u2192 (Q \u2192 P)` but Lean just writes `P \u2192 Q \u2192 P`. This is because\ncomputer scientists adopt the convention that `\u2192` is *right associative*,\nwhich is a fancy way of saying \"when we write `P \u2192 Q \u2192 R`, we mean `P \u2192 (Q \u2192 R)`.\"\nMathematicians use right associativity as a convention for powers: if\na mathematician says $10^{10^{10}}$ they don't mean $(10^{10})^{10}=10^{100}$, they\nmean $10^{(10^{10})}$. So `10 ^ 10 ^ 10` in Lean means `10 ^ (10 ^ 10)` and not `(10 ^ 10) ^ 10`.\nHowever they use left associativity as a convention for subtraction: if\na mathematician writes $6 - 2 - 1$ they mean $(6 - 2) - 1$ and not $6 - (2 - 1)$.\n\n## Pro tip\n\n`intros p q,` is the same as `intro p, intro q,`.\n-/", "height": 5, "editorText": "sorry", "lineOffset": 48, "name": "", "statement": "(P Q : Type) : P \u2192 (Q \u2192 P)"}, {"type": "text", "content": "225"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "226"}, {"type": "definition", "text": "227", "lean": "example (P Q R : Type) : (P \u2192 (Q \u2192 R)) \u2192 ((P \u2192 Q) \u2192 (P \u2192 R)) :=\n", "sideBar": false, "firstProofLineNumber": 37, "lastProofLineNumber": 45, "textBefore": "/-\n# Function world. \n\n## Level 6: `(P \u2192 (Q \u2192 R)) \u2192 ((P \u2192 Q) \u2192 (P \u2192 R))`.\n\nYou can solve this level completely just using `intro`, `apply` and `exact`,\nbut if you want to argue forwards instead of backwards then don't forget\nthat you can do things like\n\n`have j : Q \u2192 R := f p,`\n\nif `f : P \u2192 (Q \u2192 R)` and `p : P`. Remember the trick with the colon in `have`:\nwe could just write `have j := f p,` but this way we can be sure that `j` is\nwhat we actually expect it to be.\n\nI recommend that you start with `intro f` rather than `intro p`\nbecause even though the goal starts `P \u2192 ...`, the brackets mean that\nthe goal is not a function from `P` to anything, it's a function from\n`P \u2192 (Q \u2192 R)` to something. In fact you can save time by starting\nwith `intros f h p`, which introduces three variables at once, although you'd\nbetter then look at your tactic state to check that you called all those new\nterms sensible things. \n\nAfter all the intros, you find that your your goal is `\u22a2 R`. If you try `have j : Q \u2192 R := f p`\nnow then you can `apply j`. Alternatively you can `apply (f p)` directly.\nWhat happens if you just try `apply f`? Can you figure out what just happened? This is a little\n`apply` easter egg. Why is it mathematically valid?\n-/\n\n/- Definition\nWhatever the sets $P$ and $Q$ and $R$ are, we\nmake an element of $\\operatorname{Hom}(\\operatorname{Hom}(P,\\operatorname{Hom}(Q,R)),\n\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\\operatorname{Hom}(P,R)))$.\n-/\nexample (P Q R : Type) : (P \u2192 (Q \u2192 R)) \u2192 ((P \u2192 Q) \u2192 (P \u2192 R)) :=\nbegin\n", "proof": "  intro f,\n  intro h,\n  intro p,\n  have j : Q \u2192 R := f p,\n  apply j,\n  apply h,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 9, "editorText": "sorry", "lineOffset": 36, "name": "", "statement": "(P Q R : Type) : (P \u2192 (Q \u2192 R)) \u2192 ((P \u2192 Q) \u2192 (P \u2192 R))"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "228"}, {"type": "definition", "text": "229", "lean": "example (P Q F : Type) : (P \u2192 Q) \u2192 ((Q \u2192 F) \u2192 (P \u2192 F)) :=\n", "sideBar": false, "firstProofLineNumber": 23, "lastProofLineNumber": 30, "textBefore": "/-\n# Function world. \n\n## Level 7: `(P \u2192 Q) \u2192 ((Q \u2192 F) \u2192 (P \u2192 F))` \n\nHave you noticed that, in stark contrast to earlier worlds,\nwe are not amassing a large collection of useful theorems? \nWe really are just constructing abstract levels with sets and\nfunctions, and then solving them and never using the results\never again. Here's another one, which should hopefully be\nvery easy for you now. Advanced mathematician viewers will\nknow it as contravariance of $\\operatorname{Hom}(\\cdot,F)$\nfunctor.\n-/\n\n/- Definition\nWhatever the sets $P$ and $Q$ and $F$ are, we \nmake an element of $\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\n\\operatorname{Hom}(\\operatorname{Hom}(Q,F),\\operatorname{Hom}(P,F)))$.\n-/\nexample (P Q F : Type) : (P \u2192 Q) \u2192 ((Q \u2192 F) \u2192 (P \u2192 F)) :=\nbegin\n", "proof": "  intro f,\n  intro h,\n  intro p,\n  apply h,\n  apply f,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 8, "editorText": "sorry", "lineOffset": 22, "name": "", "statement": "(P Q F : Type) : (P \u2192 Q) \u2192 ((Q \u2192 F) \u2192 (P \u2192 F))"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "230"}, {"type": "definition", "text": "231", "lean": "example (P Q : Type) : (P \u2192 Q) \u2192 ((Q \u2192 empty) \u2192 (P \u2192 empty)) :=\n", "sideBar": false, "firstProofLineNumber": 44, "lastProofLineNumber": 49, "textBefore": "/-\n# Function world. \n\n## Level 8: `(P \u2192 Q) \u2192 ((Q \u2192 empty) \u2192 (P \u2192 empty))` \n\nLevel 8 is the same as level 7, except we have replaced the\nset $F$ with the empty set $\\emptyset$. The same proof will work (after all, our\nprevious proof worked for all sets, and the empty set is a set).\nBut note that if you start with `intro f, intro h, intro p,`\n(which can incidentally be shortened to `intros f h p`),\nthen the local context looks like this:\n\n```\nP Q : Type,\nf : P \u2192 Q,\nh : Q \u2192 empty,\np : P\n\u22a2 empty\n```\n\nand your job is to construct an element of the empty set!\nThis on the face of it seems hard, but what is going on is that\nour hypotheses (we have an element of $P$, and functions $P\\to Q$\nand $Q\\to\\emptyset$) are themselves contradictory, so\nI guess we are doing some kind of proof by contradiction at this point? However,\nif your next line is `apply h` then all of a sudden the goal\nseems like it might be possible again. If this is confusing, note\nthat the proof of the previous world worked for all sets $F$, so in particular\nit worked for the empty set, you just probably weren't really thinking about\nthis case explicitly beforehand. [Technical note to constructivists: I know\nthat we are not doing a proof by contradiction. But how else do you explain\nto a classical mathematician that their goal is to prove something false\nand this is OK because their hypotheses don't add up?]\n\n-/\n\n/- Definition\nWhatever the sets $P$ and $Q$ are, we\nmake an element of $\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\n\\operatorname{Hom}(\\operatorname{Hom}(Q,\\emptyset),\\operatorname{Hom}(P,\\emptyset)))$.\n-/\nexample (P Q : Type) : (P \u2192 Q) \u2192 ((Q \u2192 empty) \u2192 (P \u2192 empty)) :=\nbegin\n", "proof": "  intros f h p,\n  apply h,\n  apply f,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 6, "editorText": "sorry", "lineOffset": 43, "name": "", "statement": "(P Q : Type) : (P \u2192 Q) \u2192 ((Q \u2192 empty) \u2192 (P \u2192 empty))"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "232"}, {"type": "definition", "text": "233", "lean": "example (A B C D E F G H I J K L : Type)\n(f1 : A \u2192 B) (f2 : B \u2192 E) (f3 : E \u2192 D) (f4 : D \u2192 A) (f5 : E \u2192 F)\n(f6 : F \u2192 C) (f7 : B \u2192 C) (f8 : F \u2192 G) (f9 : G \u2192 J) (f10 : I \u2192 J)\n(f11 : J \u2192 I) (f12 : I \u2192 H) (f13 : E \u2192 H) (f14 : H \u2192 K) (f15 : I \u2192 L)\n : A \u2192 L :=\n", "sideBar": false, "firstProofLineNumber": 24, "lastProofLineNumber": 31, "textBefore": "/-\n# Function world. \n\n## Level 9: a big maze. \n\nI asked around on Zulip and apparently there is not a tactic for this, perhaps because\nthis level is rather artificial. In world 6 we will see a variant of this example\nwhich can be solved by a tactic. It would be an interesting project to make a tactic\nwhich could solve this sort of level in Lean.\n\nYou can of course work both forwards and backwards, or you could crack and draw a picture.\n\n-/\n\n/- Definition\nGiven a bunch of functions, we can define another one.\n-/\nexample (A B C D E F G H I J K L : Type)\n(f1 : A \u2192 B) (f2 : B \u2192 E) (f3 : E \u2192 D) (f4 : D \u2192 A) (f5 : E \u2192 F)\n(f6 : F \u2192 C) (f7 : B \u2192 C) (f8 : F \u2192 G) (f9 : G \u2192 J) (f10 : I \u2192 J)\n(f11 : J \u2192 I) (f12 : I \u2192 H) (f13 : E \u2192 H) (f14 : H \u2192 K) (f15 : I \u2192 L)\n : A \u2192 L :=\nbegin\n", "proof": "  intro a, apply f15, apply f11, apply f9, apply f8, apply f5, apply f2, apply f1, assumption,\n\n\n\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nThat's the end of Function World! Next it's Proposition world, and the tactics you've learnt in Function World are enough\nto solve all nine levels! In fact, the levels in Proposition world might look strangely familiar$\\ldots$.\n-/\n", "height": 8, "editorText": "sorry", "lineOffset": 23, "name": "", "statement": "(A B C D E F G H I J K L : Type)\n(f1 : A \u2192 B) (f2 : B \u2192 E) (f3 : E \u2192 D) (f4 : D \u2192 A) (f5 : E \u2192 F)\n(f6 : F \u2192 C) (f7 : B \u2192 C) (f8 : F \u2192 G) (f9 : G \u2192 J) (f10 : I \u2192 J)\n(f11 : J \u2192 I) (f12 : I \u2192 H) (f13 : E \u2192 H) (f14 : H \u2192 K) (f15 : I \u2192 L)\n : A \u2192 L"}, {"type": "text", "content": "234"}]}], "parents": [1]}, {"name": "235", "levels": [{"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "236"}, {"type": "lemma", "text": "237", "lean": "example (P Q : Prop) (p : P) (h : P \u2192 Q) : Q :=\n", "sideBar": false, "firstProofLineNumber": 81, "lastProofLineNumber": 84, "textBefore": "/- \n\n# Proposition world. \n\nA Proposition is a true/false statement, like `2 + 2 = 4` or `2 + 2 = 5`.\nJust like we can have concrete sets in Lean like `mynat`, and abstract\nsets called things like `X`, we can also have concrete propositions like\n`2 + 2 = 5` and abstract propositions called things like `P`. \n\nMathematicians are very good at conflating a theorem with its proof.\nThey might say \"now use theorem 12 and we're done\". What they really\nmean is \"now use the proof of theorem 12...\" (i.e. the fact that we proved\nit already). Particularly problematic is the fact that mathematicians\nuse the word Proposition to mean \"a relatively straightforward statement\nwhich is true\" and computer scientists use it to mean \"a statement of\narbitrary complexity, which might be true or false\". Computer scientists\nare far more careful about distinguishing between a proposition and a proof.\nFor example: `x + 0 = x` is a proposition, and `add_zero x`\nis its proof. The convention we'll use is capital letters for propositions\nand small letters for proofs. \n\nIn this world you will see the local context in the following kind of state:\n\n```\nP : Prop\np : P\n```\n\nHere `P` is the true/false statement (the statement of proposition), and `p` is its proof.\nIt's like `P` being the set and `p` being the element. In fact computer scientists\nsometimes think about the following analogy: propositions are like sets,\nand their proofs are like their elements. \n\n## What's going on in this world? \n\nWe're going to learn about manipulating propositions and proofs.\nFortunately, we don't need to learn a bunch of new tactics -- the\nones we just learnt (`exact`, `intro`, `have`, `apply`) will be perfect.\n\nThe levels in proposition world are \"back to normal\", we're proving\ntheorems, not constructing elements of sets. Or are we?\n\nIf you delete the sorry below then your local context will look like this:\n\n```\nP Q : Prop,\np : P,\nh : P \u2192 Q\n\u22a2 Q\n```\n\nIn this situation, we have true/false statements $P$ and $Q$,\na proof $p$ of $P$, and $h$ is the hypothesis that $P\\implies Q$.\nOur goal is to construct a proof of $Q$. It's clear what to do\n*mathematically* to solve this goal, $P$ is true and $P$ implies $Q$\nso $Q$ is true. But how to do it in Lean?\n\nAdopting a point of view wholly unfamiliar to many mathematicians,\nLean interprets the hypothesis $h$ as a function from proofs\nof $P$ to proofs of $Q$, so the rather surprising approach\n\n`exact h(p),`\n\nworks to close the goal.\n\nNote that `exact h(P),` (with a capital P) won't work;\nthis is a common error I see from beginners. \"We're trying to solve `P`\nso it's exactly `P`\". The goal states the *theorem*, your job is to\nconstruct the *proof*. $P$ is not a proof of $P$, it's $p$ that is a proof of $P$. \n\nIn Lean, Propositions, like sets, are types, and proofs, like elements of sets, are terms.\n\n## Level 1: the `exact` tactic.\n-/\n\n/- Lemma : no-side-bar\nIf $P$ is true, and $P\\implies Q$ is also true, then $Q$ is true.\n-/\nexample (P Q : Prop) (p : P) (h : P \u2192 Q) : Q :=\nbegin\n", "proof": "exact h(p),\n\n\n", "proof_hint": "sorry", "textAfter": "\nend \n\n", "height": 4, "editorText": "sorry", "lineOffset": 80, "name": "", "statement": "(P Q : Prop) (p : P) (h : P \u2192 Q) : Q"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "238"}, {"type": "lemma", "text": "239", "lean": "lemma imp_self (P : Prop) : P \u2192 P :=\n", "sideBar": false, "firstProofLineNumber": 63, "lastProofLineNumber": 67, "textBefore": "/-\n# Proposition world. \n\n## Level 2: `intro`.\n\nLet's prove an implication. Let $P$ be a true/false statement,\nand let's prove that $P\\implies P$. If you delete the\n`sorry` you will see that our goal is `P \u2192 P`. Constructing a term\nof type `P \u2192 P` (which is what solving this goal *means*) in this\ncase amounts to proving that $P\\implies P$, and computer scientists\nthink of this as coming up with a function which sends proofs of $P$\nto proofs of $P$.\n\nTo define an implication $P\\implies Q$ we need to choose an arbitrary\nproof $p : P$ of $P$ and then, perhaps using $p$, construct a proof\nof $Q$.  The Lean way to say \"let's assume $P$ is true\" is `intro p`,\ni.e., \"let's assume we have a proof of $P$\".\n\n## Note for worriers.\n\nThose of you who know\nsomething about the subtle differences between truth and provability\ndiscovered by Goedel -- these are not relevant here. Imagine we are\nworking in a fixed model of mathematics, and when I say \"proof\"\nI actually mean \"truth in the model\", or \"proof in the metatheory\".\n\n## Rule of thumb: \n\nIf your goal is to prove `P \u2192 Q` (i.e. that $P\\implies Q$)\nthen `intro p`, meaning \"assume $p$ is a proof of $P$\", will make progress.\n\nTo solve the goal below, you have to come up with a function from\n`P` (thought of as the set of proofs of $P$!) to itself. Start with\n\n`intro p,`\n\n(i.e. \"let $p$ be a proof of $P$\") and note that our\nlocal context now looks like this:\n\n```\nP : Prop,\np : P\n\u22a2 P\n```\n\nOur job now is to construct a proof of $P$. But $p$ is a proof of $P$.\nSo\n\n`exact p,`\n\nwill close the goal. Note that `exact P` will not work -- don't\nconfuse a true/false statement (which could be false!) with a proof.\nWe will stick with the convention of capital letters for propositions\nand small letters for proofs.\n-/ \n\n\n/- Lemma : no-side-bar\nIf $P$ is a proposition then $P\\implies P$.\n-/\nlemma imp_self (P : Prop) : P \u2192 P :=\nbegin\n", "proof": "  intro p,\n  exact p,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 5, "editorText": "sorry", "lineOffset": 62, "name": "imp_self", "statement": "(P : Prop) : P \u2192 P"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "240"}, {"type": "lemma", "text": "241", "lean": "lemma maze (P Q R S T U: Prop)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U :=\n", "sideBar": false, "firstProofLineNumber": 62, "lastProofLineNumber": 67, "textBefore": "/-\n# Proposition world. \n\n## Level 3: `have`.\n\nSay you have a whole bunch of propositions and implications between them,\nand your goal is to build a certain proof of a certain proposition.\nIf it helps, you can build intermediate proofs of other propositions\nalong the way, using the `have` command. `have q : Q := ...` is the Lean analogue\nof saying \"We now see that we can prove $Q$, because...\"\nin the middle of a proof.\nIt is often not logically necessary, but on the other hand\nit is very convenient, for example it can save on notation, or\nit can break proofs up into smaller steps.\n\nIn the level below, we have a proof of $P$ and we want a proof\nof $U$; during the proof we will construct proofs of\nof some of the other propositions involved. The diagram of\npropositions and implications looks like this pictorially:\n\n![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game_images/implies_diag.jpg)\n\nand so it's clear how to deduce $U$ from $P$.\nIndeed, we could solve this level in one move by typing\n\n`exact l(j(h(p))),`\n\nBut let us instead stroll more lazily through the level.\nWe can start by using the `have` tactic to make a proof of $Q$:\n\n`have q := h(p),`\n\nand then we note that $j(q)$ is a proof of $T$:\n\n`have t : T := j(q),`\n\n(note how we explicitly told Lean what proposition we thought $t$ was\na proof of, with that `: T` thing before the `:=`) \nand we could even define $u$ to be $l(t)$:\n\n`have u : U := l(t),`\n\nand then finish the level with\n\n`exact u,`\n\n. \n-/\n\n/- Lemma : no-side-bar\nIn the maze of logical implications above, if $P$ is true then so is $U$.\n-/\nlemma maze (P Q R S T U: Prop)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U :=\nbegin\n", "proof": "  have q := h(p),\n  have t := j(q),\n  have u := l(t),\n  exact u,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nIf you solved the level using `have`, then click on the last line of your proof\n(you do know you can move your cursor around with the arrow keys\nand explore your proof, right?) and note that the local context at that point\nis in something like the following mess:\n\n```\nP Q R S T U : Prop,\np : P,\nh : P \u2192 Q,\ni : Q \u2192 R,\nj : Q \u2192 T,\nk : S \u2192 T,\nl : T \u2192 U,\nq : Q,\nt : T,\nu : U\n\u22a2 U\n```\n\nIt was already bad enough to start with, and we added three more\nterms to it. In level 4 we will learn about the `apply` tactic\nwhich solves the level using another technique, without leaving\nso much junk behind.\n-/", "height": 6, "editorText": "sorry", "lineOffset": 61, "name": "maze", "statement": "(P Q R S T U: Prop)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U"}, {"type": "text", "content": "242"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "243"}, {"type": "lemma", "text": "244", "lean": "lemma maze (P Q R S T U: Prop)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U :=\n", "sideBar": false, "firstProofLineNumber": 44, "lastProofLineNumber": 50, "textBefore": "/-\n\n# Proposition world. \n\n## Level 4: `apply`.\n\nLet's do the same level again:\n\n![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game_images/implies_diag.jpg)\n\nWe are given a proof $p$ of $P$ and our goal is to find a proof of $U$, or\nin other words to find a path through the maze that links $P$ to $U$.\nIn level 3 we solved this by using `have`s to move forward, from $P$\nto $Q$ to $T$ to $U$. Using the `apply` tactic we can instead construct\nthe path backwards, moving from $U$ to $T$ to $Q$ to $P$.\n\nOur goal is to prove $U$. But $l:T\\implies U$ is\nan implication which we are assuming, so it would suffice to prove $T$.\nTell Lean this by starting the proof below with\n\n`apply l,`\n\nand notice that our assumptions don't change but *the goal changes*\nfrom `\u22a2 U` to `\u22a2 T`. \n\nKeep `apply`ing implications until your goal is `P`, and try not\nto get lost! Now solve this goal\nwith `exact p`. Note: you will need to learn the difference between\n`exact p` (which works) and `exact P` (which doesn't, because $P$ is\nnot a proof of $P$).\n-/\n/- Lemma : no-side-bar\nWe can solve a maze.\n-/\nlemma maze (P Q R S T U: Prop)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U :=\nbegin\n", "proof": "  apply l,\n  apply j,\n  apply h,\n  exact p,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend", "height": 7, "editorText": "sorry", "lineOffset": 43, "name": "maze", "statement": "(P Q R S T U: Prop)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "245"}, {"type": "lemma", "text": "246", "lean": "example (P Q : Prop) : P \u2192 (Q \u2192 P) :=\n", "sideBar": false, "firstProofLineNumber": 50, "lastProofLineNumber": 54, "textBefore": "/-\n# Proposition world. \n\n## Level 5 : `P \u2192 (Q \u2192 P)`.\n\nIn this level, our goal is to construct an implication, like in level 2.\n\n```\n\u22a2 P \u2192 (Q \u2192 P)\n```\n\nSo $P$ and $Q$ are propositions, and our goal is to prove\nthat $P\\implies(Q\\implies P)$.\nWe don't know whether $P$, $Q$ are true or false, so initially\nthis seems like a bit of a tall order. But let's give it a go. Delete\nthe `sorry` and let's think about how to proceed.\n\nOur goal is `P \u2192 X` for some true/false statement $X$, and if our\ngoal is to construct an implication then we almost always want to use the\n`intro` tactic from level 2, Lean's version of \"assume $P$\", or more precisely\n\"assume $p$ is a proof of $P$\". So let's start with\n\n`intro p,`\n\nand we then find ourselves in this state:\n\n```\nP Q : Prop,\np : P\n\u22a2 Q \u2192 P\n```\n\nWe now have a proof $p$ of $P$ and we are supposed to be constructing\na proof of $Q\\implies P$. So let's assume that $Q$ is true and try\nand prove that $P$ is true. We assume $Q$ like this:\n\n`intro q,`\n\nand now we have to prove $P$, but have a proof handy:\n\n`exact p,`\n-/\n\n/- Lemma : no-side-bar\nFor any propositions $P$ and $Q$, we always have\n$P\\implies(Q\\implies P)$. \n-/\nexample (P Q : Prop) : P \u2192 (Q \u2192 P) :=\nbegin\n", "proof": "  intro p,\n  intro q,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nA mathematician would treat the proposition $P\\implies(Q\\implies P)$\nas the same as the proposition $P\\land Q\\implies P$,\nbecause to give a proof of either of these is just to give a method which takes\na proof of $P$ and a proof of $Q$, and returns a proof of $P$. Thinking of the\ngoal as $P\\land Q\\implies P$ we see why it is provable.\n\n## Did you notice?\n\nI wrote `P \u2192 (Q \u2192 P)` but Lean just writes `P \u2192 Q \u2192 P`. This is because\ncomputer scientists adopt the convention that `\u2192` is *right associative*,\nwhich is a fancy way of saying \"when we write `P \u2192 Q \u2192 R`, we mean `P \u2192 (Q \u2192 R)`.\nMathematicians would never dream of writing something as ambiguous as\n$P\\implies Q\\implies R$ (they are not really interested in proving abstract\npropositions, they would rather work with concrete ones such as Fermat's Last Theorem),\nso they do not have a convention for where the brackets go. It's important to\nremember Lean's convention though, or else you will get confused. If your goal\nis `P \u2192 Q \u2192 R` then you need to know whether `intro h` will create `h : P` or `h : P \u2192 Q`. \nMake sure you understand which one. \n-/", "height": 5, "editorText": "sorry", "lineOffset": 49, "name": "", "statement": "(P Q : Prop) : P \u2192 (Q \u2192 P)"}, {"type": "text", "content": "247"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "248"}, {"type": "lemma", "text": "249", "lean": "example (P Q R : Prop) : (P \u2192 (Q \u2192 R)) \u2192 ((P \u2192 Q) \u2192 (P \u2192 R)) :=\n", "sideBar": false, "firstProofLineNumber": 26, "lastProofLineNumber": 34, "textBefore": "/-\n# Proposition world. \n\n## Level 6: `(P \u2192 (Q \u2192 R)) \u2192 ((P \u2192 Q) \u2192 (P \u2192 R))`.\n\nYou can solve this level completely just using `intro`, `apply` and `exact`,\nbut if you want to argue forwards instead of backwards then don't forget\nthat you can do things like `have j : Q \u2192 R := f p` if `f : P \u2192 (Q \u2192 R)`\nand `p : P`. I recommend that you start with `intro f` rather than `intro p`\nbecause even though the goal starts `P \u2192 ...`, the brackets mean that\nthe goal is not the statement that `P` implies anything, it's the statement that\n$P\\implies (Q\\implies R)$ implies something. In fact I'd recommend that you started\nwith `intros f h p`, which introduces three variables at once.\nYou then find that your your goal is `\u22a2 R`. If you try `have j : Q \u2192 R := f p`\nnow then you can `apply j`. Alternatively you can `apply (f p)` directly.\nWhat happens if you just try `apply f`? Can you figure out what just happened? This is a little\n`apply` easter egg. Why is it mathematically valid?\n-/\n\n/- Lemma : no-side-bar\nIf $P$ and $Q$ and $R$ are true/false statements, then\n$$(P\\implies(Q\\implies R))\\implies((P\\implies Q)\\implies(P\\implies R)).$$\n-/\nexample (P Q R : Prop) : (P \u2192 (Q \u2192 R)) \u2192 ((P \u2192 Q) \u2192 (P \u2192 R)) :=\nbegin\n", "proof": "  intro f,\n  intro h,\n  intro p,\n  have j : Q \u2192 R := f p,\n  apply j,\n  apply h,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 9, "editorText": "sorry", "lineOffset": 25, "name": "", "statement": "(P Q R : Prop) : (P \u2192 (Q \u2192 R)) \u2192 ((P \u2192 Q) \u2192 (P \u2192 R))"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "250"}, {"type": "lemma", "text": "251", "lean": "lemma imp_trans (P Q R : Prop) : (P \u2192 Q) \u2192 ((Q \u2192 R) \u2192 (P \u2192 R)) :=\n", "sideBar": false, "firstProofLineNumber": 23, "lastProofLineNumber": 29, "textBefore": "/-\n# Function world. \n\n## Level 7: `(P \u2192 Q) \u2192 ((Q \u2192 R) \u2192 (P \u2192 R))` \n\nIf you start with `intro hpq` and then `intro hqr`\nthe dust will clear a bit and the level will look like this:\n```\nP Q R : Prop,\nhpq : P \u2192 Q,\nhqr : Q \u2192 R\n\u22a2 P \u2192 R\n```\nSo this level is really about showing transitivity of $\\implies$,\nif you like that sort of language.\n-/\n\n/- Lemma : no-side-bar\nFrom $P\\implies Q$ and $Q\\implies R$ we can deduce $P\\implies R$.\n-/\nlemma imp_trans (P Q R : Prop) : (P \u2192 Q) \u2192 ((Q \u2192 R) \u2192 (P \u2192 R)) :=\nbegin\n", "proof": "  intros hpq hqr,\n  intro p,\n  apply hqr,\n  apply hpq,\n  assumption\n  \n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 7, "editorText": "sorry", "lineOffset": 22, "name": "imp_trans", "statement": "(P Q R : Prop) : (P \u2192 Q) \u2192 ((Q \u2192 R) \u2192 (P \u2192 R))"}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "axiom", "content": "252", "name": "not_iff_imp_false (P : Prop) :", "sideBar": true}, {"type": "lean", "content": "253", "hidden": true}, {"type": "text", "content": "254"}, {"type": "lemma", "text": "255", "lean": "lemma contrapositive (P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P) :=\n", "sideBar": false, "firstProofLineNumber": 33, "lastProofLineNumber": 41, "textBefore": "/- Axiom : not_iff_imp_false (P : Prop) :\n\u00ac P \u2194 P \u2192 false\n-/\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n/-\n# Proposition world. \n\n## Level 8 : `(P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)` \n\nThere is a false proposition `false`, with no proof. It is\neasy to check that $\\lnot Q$ is equivalent to $Q\\implies {\\tt false}$,\nand in the natural number game we call this\n\n`not_iff_imp_false (P : Prop) : \u00ac P \u2194 (P \u2192 false)`\n\nSo you can start the proof of the contrapositive below with\n\n`repeat {rw not_iff_imp_false},`\n\nto get rid of the two occurences of `\u00ac`, and I'm sure you can\ntake it from there (note that we just added `not_iff_imp_false` to the\ntheorem statements in the menu on the left). At some point your goal might be to prove `false`.\nAt that point I guess you must be proving something by contradiction.\nOr are you? \n-/\n\n/- Lemma : no-side-bar\nIf $P$ and $Q$ are propositions, and $P\\implies Q$, then\n$\\lnot Q\\implies \\lnot P$. \n-/\nlemma contrapositive (P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P) :=\nbegin\n", "proof": "  repeat {rw not_iff_imp_false},\n  intro f,\n  intro h,\n  intro p,\n  apply h,\n  apply f,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n## Technical note\n\n\nAll of that rewriting you did with `rw` in addition world\nwas rewriting hypothesis of the form `h : X = Y`, but\nyou can also `rw h` if `h : P \u2194 Q` (because propositional\nextensionality says that if $P\\iff Q$ then $P=Q$, and\nmathematicians use this whether or not they notice.)\n-/\n", "height": 9, "editorText": "sorry", "lineOffset": 32, "name": "contrapositive", "statement": "(P Q : Prop) : (P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)"}, {"type": "text", "content": "256"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "257"}, {"type": "lemma", "text": "258", "lean": "example (A B C D E F G H I J K L : Prop)\n(f1 : A \u2192 B) (f2 : B \u2192 E) (f3 : E \u2192 D) (f4 : D \u2192 A) (f5 : E \u2192 F)\n(f6 : F \u2192 C) (f7 : B \u2192 C) (f8 : F \u2192 G) (f9 : G \u2192 J) (f10 : I \u2192 J)\n(f11 : J \u2192 I) (f12 : I \u2192 H) (f13 : E \u2192 H) (f14 : H \u2192 K) (f15 : I \u2192 L)\n : A \u2192 L :=\n", "sideBar": false, "firstProofLineNumber": 19, "lastProofLineNumber": 22, "textBefore": "/-\n# Proposition world. \n\n## Level 9: a big maze. \n\nLean's \"congruence closure\" tactic `cc` is good at mazes. You might want to try it now.\nPerhaps I should have mentioned it earlier.\n-/\n\n/- Lemma : no-side-bar\nThere is a way through the following maze.\n-/\nexample (A B C D E F G H I J K L : Prop)\n(f1 : A \u2192 B) (f2 : B \u2192 E) (f3 : E \u2192 D) (f4 : D \u2192 A) (f5 : E \u2192 F)\n(f6 : F \u2192 C) (f7 : B \u2192 C) (f8 : F \u2192 G) (f9 : G \u2192 J) (f10 : I \u2192 J)\n(f11 : J \u2192 I) (f12 : I \u2192 H) (f13 : E \u2192 H) (f14 : H \u2192 K) (f15 : I \u2192 L)\n : A \u2192 L :=\nbegin\n", "proof": "  cc,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nNow move onto advanced proposition world, where you will see\nhow to prove goals such as `P \u2227 Q` ($P$ and $Q$), `P \u2228 Q` ($P$ or $Q$),\n`P \u2194 Q` ($P\\iff Q$).\nYou will need to learn five more tactics: `split`, `cases`,\n`left`, `right`, and `exfalso`,\nbut they are all straightforward, and furthermore they are\nessentially the last tactics you\nneed to learn in order to complete all the levels of the Natural Number Game,\nincluding all the 17 levels of Inequality World. \n-/\n\n/- Tactic : cc\n\n## Summary:\n\n`cc` will solve certain \"logic\" goals.\n\n## Details\n\n`cc` is a \"congruence closure tactic\". In practice this means that it is\ngood at solving certain logic goals. It's worth trying if you think\nthat the goal could be solved using truth tables.\n-/", "height": 4, "editorText": "sorry", "lineOffset": 18, "name": "", "statement": "(A B C D E F G H I J K L : Prop)\n(f1 : A \u2192 B) (f2 : B \u2192 E) (f3 : E \u2192 D) (f4 : D \u2192 A) (f5 : E \u2192 F)\n(f6 : F \u2192 C) (f7 : B \u2192 C) (f8 : F \u2192 G) (f9 : G \u2192 J) (f10 : I \u2192 J)\n(f11 : J \u2192 I) (f12 : I \u2192 H) (f13 : E \u2192 H) (f14 : H \u2192 K) (f15 : I \u2192 L)\n : A \u2192 L"}, {"type": "text", "content": "259"}, {"type": "tactic", "content": "260", "name": "cc", "sideBar": true}]}], "parents": [4]}, {"name": "261", "levels": [{"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "262"}, {"type": "lemma", "text": "263", "lean": "example (P Q : Prop) (p : P) (q : Q) : P \u2227 Q :=\n", "sideBar": false, "firstProofLineNumber": 24, "lastProofLineNumber": 28, "textBefore": "/- \n\n# Advanced proposition world. \n\nIn this world we will learn five key tactics needed to solve all the\nlevels of the Natural Number Game, namely `split`, `cases`, `left`, `right`, and `exfalso`.\nThese, and `use` (which we'll get to in Inequality World) are all the\ntactics you will need to beat all the levels of the game.\n\n## Level 1: the `split` tactic.\n\nThe logical symbol `\u2227` means \"and\". If $P$ and $Q$ are propositions, then\n$P\\land Q$ is the proposition \"$P$ and $Q$\". If your *goal* is `P \u2227 Q` then\nyou can make progress with the `split` tactic, which turns one goal `\u22a2 P \u2227 Q`\ninto two goals, namely `\u22a2 P` and `\u22a2 Q`. In the level below, after a `split`,\nyou will be able to finish off the goals with the `exact` tactic.\n-/\n\n/- Lemma : no-side-bar\nIf $P$ and $Q$ are true, then $P\\land Q$ is true.\n-/\nexample (P Q : Prop) (p : P) (q : Q) : P \u2227 Q :=\nbegin\n", "proof": "  split,\n  exact p,\n  exact q,\n\n", "proof_hint": "sorry", "textAfter": "\nend \n\n/- Tactic : split\n\n## Summary:\n\nIf the goal is `P \u2227 Q` or `P \u2194 Q` then `split` will break it into two goals.\n\n## Details\n\nIf `P Q : Prop` and the goal is `\u22a2 P \u2227 Q`, then `split` will change it into\ntwo goals, namely `\u22a2 P` and `\u22a2 Q`. \n\nIf `P Q : Prop` and the goal is `\u22a2 P \u2194 Q`, then `split` will change it into\ntwo goals, namely `\u22a2 P \u2192 Q` and `\u22a2 Q \u2192 P`.  \n\n## Example:\n\nIf your local context (the top right window) looks like this\n```\na b : mynat,\n\u22a2 a = b \u2194 a + 3 = b + 3\n```\n\nthen after\n\n`split,`\n\nit will look like this:\n\n```\n2 goals\na b : mynat\n\u22a2 a = b \u2192 a + 3 = b + 3\n\na b : mynat\n\u22a2 a + 3 = b + 3 \u2192 a = b\n\n-/\n", "height": 5, "editorText": "sorry", "lineOffset": 23, "name": "", "statement": "(P Q : Prop) (p : P) (q : Q) : P \u2227 Q"}, {"type": "tactic", "content": "264", "name": "split", "sideBar": true}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "265"}, {"type": "lemma", "text": "266", "lean": "lemma and_symm (P Q : Prop) : P \u2227 Q \u2192 Q \u2227 P :=\n", "sideBar": true, "firstProofLineNumber": 30, "lastProofLineNumber": 36, "textBefore": "/- \n\n# Advanced proposition world. \n\n## Level 2: the `cases` tactic.\n\nIf `P \u2227 Q` is in the goal, then we can make progress with `split`.\nBut what if `P \u2227 Q` is a hypothesis? In this case, the `cases` tactic will enable\nus to extract proofs of `P` and `Q` from this hypothesis.\n\nThe lemma below asks us to prove `P \u2227 Q \u2192 Q \u2227 P`, that is,\nsymmetry of the \"and\" relation. The obvious first move is\n\n`intro h,`\n\nbecause the goal is an implication and this tactic is guaranteed\nto make progress. Now `h : P \u2227 Q` is a hypothesis, and\n\n`cases h with p q,`\n\nwill change `h`, the proof of `P \u2227 Q`, into two proofs `p : P`\nand `q : Q`. From there, `split` and `exact` will get you home.\n-/\n\n/- Lemma\nIf $P$ and $Q$ are true/false statements, then $P\\land Q\\implies Q\\land P$. \n-/\nlemma and_symm (P Q : Prop) : P \u2227 Q \u2192 Q \u2227 P :=\nbegin\n", "proof": "  intro h,\n  cases h with p q,\n  split,\n  exact q,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend \n\n/- Tactic : cases\n\n## Summary:\n\n`cases` is a tactic which works on hypotheses.\nIf `h : P \u2227 Q` or `h : P \u2194 Q` is a hypothesis then `cases h with h1 h2` will remove `h`\nfrom the list of hypotheses and replace it with the \"ingredients\" of `h`,\ni.e. `h1 : P` and `h2 : Q`, or `h1 : P \u2192 Q` and `h2 : Q \u2192 P`. Also\nworks with `h : P \u2228 Q` and `n : mynat`. \n\n## Details\n\nHow does one prove `P \u2227 Q`? The way to do it is to prove `P` and to\nprove `Q`. There are hence two ingredients which go into a proof of\n`P \u2227 Q`, and the `cases` tactic extracts them. \n\nMore precisely, if the local context contains\n```\nh : P \u2227 Q`\n```\n\nthen after the tactic `cases h with p q,` the local context will\nchange to\n```\np : P,\nq : Q\n```\nand `h` will disappear. \n\nSimilarly `h : P \u2194 Q` is proved by proving `P \u2192 Q` and `Q \u2192 P`,\nand `cases h with hpq hqp` will delete our assumption `h` and\nreplace it with\n```\nhpq : P \u2192 Q,\nhqp : Q \u2192 P\n```\n\nBe warned though -- `rw h` works with `h : P \u2194 Q` (`rw` works with\n`=` and `\u2194`), whereas you cannot rewrite with an implication.\n\n`cases` also works with hypotheses of the form `P \u2228 Q` and even\nwith `n : mynat`. Here the situation is different however. \nTo prove `P \u2228 Q` you need to give either a proof of `P` *or* a proof\nof `Q`, so if `h : P \u2228 Q` then `cases h with p q` will change one goal\ninto two, one with `p : P` and the other with `q : Q`. Similarly, each\nnatural is either `0` or `succ(d)` for `d` another natural, so if\n`n : mynat` then `cases n with d` also turns one goal into two,\none with `n = 0` and the other with `d : mynat` and `n = succ(d)`.\n-/", "height": 7, "editorText": "sorry", "lineOffset": 29, "name": "and_symm", "statement": "(P Q : Prop) : P \u2227 Q \u2192 Q \u2227 P"}, {"type": "tactic", "content": "267", "name": "cases", "sideBar": true}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "268"}, {"type": "lemma", "text": "269", "lean": "lemma and_trans (P Q R : Prop) : P \u2227 Q \u2192 Q \u2227 R \u2192 P \u2227 R :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 22, "textBefore": "/- \n\n# Advanced proposition world. \n\n## Level 3: and_trans.\n-/\n\n/- Lemma\nIf $P$, $Q$ and $R$ are true/false statements, then $P\\land Q$ and\n$Q\\land R$ together imply $P\\land R$.\n-/\nlemma and_trans (P Q R : Prop) : P \u2227 Q \u2192 Q \u2227 R \u2192 P \u2227 R :=\nbegin\n", "proof": "  intro hpq,\n  intro hqr,\n  cases hpq with p q,\n  cases hqr with q' r,\n  split,\n  assumption,\n  assumption,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 9, "editorText": "sorry", "lineOffset": 13, "name": "and_trans", "statement": "(P Q R : Prop) : P \u2227 Q \u2192 Q \u2227 R \u2192 P \u2227 R"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "270"}, {"type": "lemma", "text": "271", "lean": "lemma iff_trans (P Q R : Prop) : (P \u2194 Q) \u2192 (Q \u2194 R) \u2192 (P \u2194 R) :=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 26, "textBefore": "/- \n\n# Advanced proposition world. \n\n## Level 4: `iff_trans`.\n\nThe mathematical statement $P\\iff Q$ is equivalent to $(P\\implies Q)\\land(Q\\implies P)$. The `cases`\nand `split` tactics work on hypotheses and goals (respectively) of the form `P \u2194 Q`. If you need\nto write an `\u2194` arrow you can do so by typing `\\iff`, but you shouldn't need to. After an initial\n`intro h,` you can type `cases h with hpq hqp` to break `h : P \u2194 Q` into its constituent parts.\n-/\n\n/- Lemma\nIf $P$, $Q$ and $R$ are true/false statements, then\n$P\\iff Q$ and $Q\\iff R$ together imply $P\\iff R$.\n-/\nlemma iff_trans (P Q R : Prop) : (P \u2194 Q) \u2192 (Q \u2194 R) \u2192 (P \u2194 R) :=\nbegin\n", "proof": "  intro hpq,\n  intro hqr,\n  cases hpq with hpq hqp,\n  cases hqr with hqr hrq,\n  split,\n  cc,cc,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 8, "editorText": "sorry", "lineOffset": 18, "name": "iff_trans", "statement": "(P Q R : Prop) : (P \u2194 Q) \u2192 (Q \u2194 R) \u2192 (P \u2194 R)"}]}, {"name": "", "problemIndex": 1, "objects": [{"type": "text", "content": "272"}, {"type": "lemma", "text": "273", "lean": "lemma iff_trans (P Q R : Prop) : (P \u2194 Q) \u2192 (Q \u2194 R) \u2192 (P \u2194 R) :=\n", "sideBar": false, "firstProofLineNumber": 39, "lastProofLineNumber": 50, "textBefore": "/- \n\n# Advanced proposition world. \n\n## Level 5: `iff_trans` easter eggs.\n\nLet's try `iff_trans` again. Try proving it in other ways.\n\n### A trick.\n\nInstead of using `cases` on `h : P \u2194 Q` you can just access the proofs of `P \u2192 Q` and `Q \u2192 P`\ndirectly with `h.1` and `h.2`. So you can solve this level with\n\n```\nintros hpq hqr, \nsplit,\nintro p,\napply hqr.1,\n...\n```\n\n### Another trick\n\nInstead of using `cases` on `h : P \u2194 Q`, you can just `rw h`, and this will change all `P`s to `Q`s\nin the goal. You can use this to create a much shorter proof. Note that\nthis is an argument for *not* running the `cases` tactic on an iff statement;\nyou cannot rewrite one-way implications, but you can rewrite two-way implications.\n\n### Another trick\n\n`cc` works on this sort of goal too.\n-/\n\n/- Lemma : no-side-bar\nIf $P$, $Q$ and $R$ are true/false statements, then `P \u2194 Q` and `Q \u2194 R` together imply `P \u2194 R`.\n-/\nlemma iff_trans (P Q R : Prop) : (P \u2194 Q) \u2192 (Q \u2194 R) \u2192 (P \u2194 R) :=\nbegin\n", "proof": "  intros hpq hqr,\n  split,\n  intro p,\n  apply hqr.1,\n  apply hpq.1,\n  assumption,\n  intro r,\n  apply hpq.2,\n  apply hqr.2,\n  assumption,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 12, "editorText": "sorry", "lineOffset": 38, "name": "iff_trans", "statement": "(P Q R : Prop) : (P \u2194 Q) \u2192 (Q \u2194 R) \u2192 (P \u2194 R)"}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "274", "hidden": true}, {"type": "text", "content": "275"}, {"type": "lemma", "text": "276", "lean": "example (P Q : Prop) : Q \u2192 (P \u2228 Q) :=\n", "sideBar": false, "firstProofLineNumber": 25, "lastProofLineNumber": 29, "textBefore": "import game.world7.level5 -- hide\n/- \n# Advanced proposition world. \n\n## Level 6: Or, and the `left` and `right` tactics.\n\n`P \u2228 Q` means \"$P$ or $Q$\". So to prove it, you\nneed to choose one of `P` or `Q`, and prove that one.\nIf `\u22a2 P \u2228 Q` is your goal, then `left` changes this\ngoal to `\u22a2 P`, and `right` changes it to `\u22a2 Q`.\nNote that you can take a wrong turn here. Let's\nstart with trying to prove $Q\\implies (P\\lor Q)$.\nAfter the `intro`, one of `left` and `right` leads\nto an impossible goal, the other to an easy finish.\n-/\n\n\n\n/- Lemma : no-side-bar\nIf $P$ and $Q$ are true/false statements, then\n$$Q\\implies(P\\lor Q).$$ \n-/\nexample (P Q : Prop) : Q \u2192 (P \u2228 Q) :=\nbegin\n", "proof": "  intro q,\n  right,\n  assumption,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n/- Tactic : left and right\n\n## Summary\n\n`left` and `right` work on the goal, and they change\n`\u22a2 P \u2228 Q` to `\u22a2 P` and `\u22a2 Q` respectively.\n\n## Details\n\nThe tactics `left` and `right` work on a goal which is a type with\ntwo constructors, the classic example being `P \u2228 Q`. \nTo prove `P \u2228 Q` it suffices to either prove `P` or prove `Q`,\nand once you know which one you are going for you can change\nthe goal with `left` or `right` to the appropriate choice.\n-/\n", "height": 5, "editorText": "sorry", "lineOffset": 24, "name": "", "statement": "(P Q : Prop) : Q \u2192 (P \u2228 Q)"}, {"type": "tactic", "content": "277", "name": "left and right", "sideBar": true}]}, {"name": "", "problemIndex": 2, "objects": [{"type": "lean", "content": "278", "hidden": true}, {"type": "text", "content": "279"}, {"type": "lemma", "text": "280", "lean": "lemma or_symm (P Q : Prop) : P \u2228 Q \u2192 Q \u2228 P :=\n", "sideBar": true, "firstProofLineNumber": 25, "lastProofLineNumber": 32, "textBefore": "import game.world7.level6 -- hide\n/- \n# Advanced proposition world. \n\n## Level 7: `or_symm`\n\nProving that $(P\\lor Q)\\implies(Q\\lor P)$ involves an element of danger.\n`intro h,` is the obvious start. But now,\neven though the goal is an `\u2228` statement, both `left` and `right` put\nyou in a situation with an impossible goal. Fortunately, after `intro h,`\nyou can do `cases h with p q`. Then something new happens: because\nthere are two ways to prove `P \u2228 Q` (namely, proving `P` or proving `Q`),\nthe `cases` tactic turns one goal into two, one for each case. You should\nbe able to make it home from there. \n-/\n\n\n\n/- Lemma\nIf $P$ and $Q$ are true/false statements, then\n$$P\\lor Q\\implies Q\\lor P.$$ \n-/\nlemma or_symm (P Q : Prop) : P \u2228 Q \u2192 Q \u2228 P :=\nbegin\n", "proof": "  intro h,\n  cases h with p q,\n    right,\n    exact p,\n  left,\n  exact q,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n", "height": 8, "editorText": "sorry", "lineOffset": 24, "name": "or_symm", "statement": "(P Q : Prop) : P \u2228 Q \u2192 Q \u2228 P"}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "281", "hidden": true}, {"type": "lean", "content": "282", "hidden": true}, {"type": "text", "content": "283"}, {"type": "lemma", "text": "284", "lean": "lemma and_or_distrib_left (P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R) :=\n", "sideBar": true, "firstProofLineNumber": 20, "lastProofLineNumber": 37, "textBefore": "import tactic.finish game.world7.level7 -- hide\nnamespace mynat -- hide\n/- \n# Advanced proposition world. \n\n## Level 8: `and_or_distrib_left`\n\nWe know that `x(y+z)=xy+xz` for numbers, and this\nis called distributivity of multiplication over addition.\nThe same is true for `\u2227` and `\u2228` -- in fact `\u2227` distributes\nover `\u2228` and `\u2228` distributes over `\u2227`. Let's prove one of these.\n-/\n\n/- Lemma\nIf $P$. $Q$ and $R$ are true/false statements, then\n$$P\\land(Q\\lor R)\\iff(P\\land Q)\\lor (P\\land R).$$ \n-/\nlemma and_or_distrib_left (P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R) :=\nbegin\n", "proof": "  split,\n  intro h,\n  cases h with hp hqr,\n  cases hqr with q r,\n  left, split, assumption, assumption,\n  right, split, assumption, assumption,\n  intro h,\n  cases h with hpq hpr,\n  cases hpq with p q,\n  split, assumption,\n  left, assumption,\n  cases hpr with hp hr,\n  split, assumption,\n  right, assumption,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n## Pro tip\n\nDid you spot the import? What do you think it does?\n\nIf you follow the instructions at\n<a href=\"https://github.com/leanprover-community/mathlib#installation\" target=\"blank\">the mathlib github page</a>\nyou will be able to install Lean and mathlib on your own system, and then you can create a new project\nand experiment with such imports yourself.\n-/\nend mynat", "height": 18, "editorText": "sorry", "lineOffset": 19, "name": "and_or_distrib_left", "statement": "(P Q R : Prop) : P \u2227 (Q \u2228 R) \u2194 (P \u2227 Q) \u2228 (P \u2227 R)"}, {"type": "text", "content": "285"}, {"type": "lean", "content": "286", "hidden": false}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "287", "hidden": true}, {"type": "lean", "content": "288", "hidden": true}, {"type": "lean", "content": "289", "hidden": false}, {"type": "lean", "content": "290", "hidden": true}, {"type": "text", "content": "291"}, {"type": "lemma", "text": "292", "lean": "lemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q :=\n", "sideBar": false, "firstProofLineNumber": 31, "lastProofLineNumber": 38, "textBefore": "import game.world7.level8 -- hide\nimport game.world6.level8 -- hide\nimport tactic.tauto -- useful high-powered tactic\nlocal attribute [instance, priority 10] classical.prop_decidable -- hide\n/- \n# Advanced proposition world. \n\nYou already know enough to embark on advanced addition world. But here are just a couple\nmore things.\n\n## Level 9: `exfalso` and proof by contradiction. \n\nIt's certainly true that $P\\land(\\lnot P)\\implies Q$ for any propositions $P$\nand $Q$, because the left hand side of the implication is false. But how do\nwe prove that `false` implies any proposition $Q$? A cheap way of doing it in\nLean is using the `exfalso` tactic, which changes any goal at all to `false`. \nYou might think this is a step backwards, but if you have a hypothesis `h : \u00ac P`\nthen after `rw not_iff_imp_false at h,` you can `apply h,` to make progress. \nTry solving this level without using `cc` or `tauto`, but using `exfalso` instead.\n\n-/\n\n\n\n/- Lemma : no-side-bar\nIf $P$ and $Q$ are true/false statements, then\n$$(P\\land(\\lnot P))\\implies Q.$$\n-/\nlemma contra (P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q :=\nbegin\n", "proof": "  intro h,\n  cases h with p np,\n  rw not_iff_imp_false at np,\n  exfalso,\n  apply np,\n  exact p,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/-\n## Pro tip.\n\n`\u00ac P` is actually `P \u2192 false` *by definition*. Try\ncommenting out `rw not_iff_imp_false at ...` by putting two minus signs `--`\nbefore the `rw`. Does it still compile?\n-/\n\n/- Tactic : exfalso\n\n## Summary\n\n`exfalso` changes your goal to `false`. \n\n## Details\n\nWe know that `false` implies `P` for any proposition `P`, and so if your goal is `P`\nthen you should be able to `apply` `false \u2192 P` and reduce your goal to `false`. This\nis what the `exfalso` tactic does. The theorem that `false \u2192 P` is called `false.elim`\nso one can achieve the same effect with `apply false.elim`. \n\nThis tactic can be used in a proof by contradiction, where the hypotheses are enough\nto deduce a contradiction and the goal happens to be some random statement (possibly\na false one) which you just want to simplify to `false`.\n-/\n\n", "height": 8, "editorText": "sorry", "lineOffset": 30, "name": "contra", "statement": "(P Q : Prop) : (P \u2227 \u00ac P) \u2192 Q"}, {"type": "text", "content": "293"}, {"type": "tactic", "content": "294", "name": "exfalso", "sideBar": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "295", "hidden": true}, {"type": "lean", "content": "296", "hidden": false}, {"type": "text", "content": "297"}, {"type": "lemma", "text": "298", "lean": "lemma contrapositive2 (P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q) :=\n", "sideBar": false, "firstProofLineNumber": 55, "lastProofLineNumber": 58, "textBefore": "import game.world7.level9 -- hide\nimport tactic.tauto \nlocal attribute [instance, priority 10] classical.prop_decidable -- we are mathematicians\n/- \n# Advanced proposition world.\n\n\n\n## Level 10: the law of the excluded middle.\n\nWe proved earlier that `(P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)`. The converse,\nthat `(\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q)` is certainly true, but trying to prove\nit using what we've learnt so far is impossible (because it is not provable in\nconstructive logic). For example, after\n\n```\nintro h,\nintro p,\nrepeat {rw not_iff_imp_false at h},\n```\n\nin the below, you are left with\n```\nP Q : Prop,\nh : (Q \u2192 false) \u2192 P \u2192 false\np : P\n\u22a2 Q\n```\n\nThe tools you have are not sufficient to continue. But you can just\nprove this, and any other basic lemmas of this form like `\u00ac \u00ac P \u2192 P`,\nusing the `by_cases` tactic. Instead of starting with all the `intro`s,\ntry this instead:\n\n`by_cases p : P; by_cases q : Q,`\n\n**Note the semicolon**! It means \"do the next tactic to all the goals, not just the top one\".\nAfter it, there are four goals, one for each of the four possibilities PQ=TT, TF, FT, FF.\nYou can see that `p` is a proof of `P` in some of the goals, and a proof of `\u00ac P` in others.\nSimilar comments apply to `q`. \n\n`repeat {cc}` then finishes the job.\n\nThis approach assumed that `P \u2228 \u00ac P` was true; the `by_cases` tactic just does `cases` on\nthis result. This is called the law of the excluded middle, and it cannot be proved just\nusing tactics such as `intro` and `apply`.\n\n-/\n/- Lemma : no-side-bar\nIf $P$ and $Q$ are true/false statements, then\n$$(\\lnot Q\\implies \\lnot P)\\implies(P\\implies Q).$$ \n-/\nlemma contrapositive2 (P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q) :=\nbegin\n", "proof": "  by_cases p : P; by_cases q : Q,\n  repeat {cc}, \n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/-\nOK that's enough logic -- now perhaps it's time to go on to Advanced Addition World!\nGet to it via the main menu.\n-/\n\n\n/-\n## Pro tip\n\nIn fact the tactic `tauto!` just kills this goal (and many other logic goals) immediately.\n-/\n\n/- Tactic : by_cases\n\n## Summary\n\n`by_cases h : P` does a cases split on whether `P` is true or false.\n\n## Details\n\nSome logic goals cannot be proved with `intro` and `apply` and `exact`.\nThe simplest example is the law of the excluded middle `\u00ac \u00ac P \u2192 P`.\nYou can prove this using truth tables but not with `intro`, `apply` etc.\nTo do a truth table proof, the tactic `by_cases h : P` will turn a goal of\n`\u22a2 \u00ac \u00ac P \u2192 P` into two goals\n\n```\nP : Prop,\nh : P\n\u22a2 \u00ac\u00acP \u2192 P\n\nP : Prop,\nh : \u00acP\n\u22a2 \u00ac\u00acP \u2192 P\n```\n\nEach of these can now be proved using `intro`, `apply`, `exact` and `exfalso`.\nRemember though that in these simple logic cases, high-powered logic\ntactics like `cc` and `tauto!` will just prove everything.\n\n\n\n-/\n\n/- Tactic : tauto\n\n## Summary\n\nThe `tauto` tactic (and its variant `tauto!`) will close various logic\ngoals.\n\n## Details\n\n`tauto` is an all-purpose logic tactic which will try to solve goals using pure\nlogical reasoning -- for example it will close the following goal:\n\n```\nP Q : Prop,\nhP : P,\nhQ : Q\n\u22a2 P \u2227 Q\n```\n\n`tauto` is supposed to only use constructive logic, but its big brother `tauto!` uses classical logic\nand hence closes more goals.\n-/\n", "height": 4, "editorText": "sorry", "lineOffset": 54, "name": "contrapositive2", "statement": "(P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q)"}, {"type": "text", "content": "299"}, {"type": "text", "content": "300"}, {"type": "tactic", "content": "301", "name": "by_cases", "sideBar": true}, {"type": "tactic", "content": "302", "name": "tauto", "sideBar": true}]}], "parents": [5]}, {"name": "303", "levels": [{"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "304", "hidden": true}, {"type": "lean", "content": "305", "hidden": true}, {"type": "lean", "content": "306", "hidden": true}, {"type": "lean", "content": "307", "hidden": true}, {"type": "axiom", "content": "308", "name": "succ_inj {a b : mynat} :", "sideBar": true}, {"type": "text", "content": "309"}, {"type": "theorem", "text": "310", "lean": "theorem succ_inj' {a b : mynat} (hs : succ(a) = succ(b)) :  a = b := \n", "sideBar": false, "firstProofLineNumber": 46, "lastProofLineNumber": 49, "textBefore": "import mynat.definition -- hide\nimport mynat.add -- hide\nimport game.world2.level6 -- hide\nnamespace mynat -- hide\n\n/- Axiom : succ_inj {a b : mynat} :\n  succ(a) = succ(b) \u2192 a = b\n-/\n\n/-\n\n# Advanced Addition World\n\n## Level 1: `succ_inj`. A function.\n\nPeano's original collection of axioms for the natural numbers contained two further\nassumptions, which have not yet been mentioned in the game:\n\n```\nsucc_inj {a b : mynat} :\n  succ(a) = succ(b) \u2192 a = b\n\nzero_ne_succ (a : mynat) :\n  zero \u2260 succ(a)\n ```\n\nThe reason they have not been used yet is that they are both implications,\nthat is,\nof the form $P\\implies Q$. This is clear for `succ_inj a b`, which\nsays that for all $a$ and $b$ we have $succ(a)=succ(b)\\implies a=b$.\nFor `zero_ne_succ` the trick is that $X\\ne Y$ is *defined to mean*\n$X = Y\\implies{\\tt false}$. If you have played through Proposition world,\nyou now have the required Lean skills (i.e., you know the required\ntactics) to work with these implications.\nLet's finally learn how to use `succ_inj`. You should know a couple\nof ways to prove the below -- one directly using an `exact`,\nand one which uses an `apply` first. But either way you'll need to use `succ_inj`.\n-/\n\n/- Theorem : no-side-bar\nFor all naturals $a$ and $b$, if we assume $succ(a)=succ(b)$, then we can\ndeduce $a=b$. \n-/\ntheorem succ_inj' {a b : mynat} (hs : succ(a) = succ(b)) :  a = b := \nbegin [nat_num_game]\n", "proof": "    exact succ_inj(hs),\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n## Important thing.\n\nYou can rewrite proofs of *equalities*. If `h : A = B` then `rw h` changes `A`s to `B`s.\nBut you *cannot rewrite proofs of implications*. `rw succ_inj` will *never work*\nbecause `succ_inj` isn't of the form $A = B$, it's of the form $A\\implies B$. This is one\nof the most common mistakes I see from beginners. $\\implies$ and $=$ are *two different things*\nand you need to be clear about which one you are using.\n-/\nend mynat -- hide\n", "height": 4, "editorText": "sorry", "lineOffset": 45, "name": "succ_inj'", "statement": "{a b : mynat} (hs : succ(a) = succ(b)) :  a = b"}, {"type": "text", "content": "311"}, {"type": "lean", "content": "312", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "313", "hidden": true}, {"type": "lean", "content": "314", "hidden": true}, {"type": "lean", "content": "315", "hidden": true}, {"type": "lean", "content": "316", "hidden": true}, {"type": "text", "content": "317"}, {"type": "text", "content": "318"}, {"type": "theorem", "text": "319", "lean": "theorem succ_succ_inj {a b : mynat} (h : succ(succ(a)) = succ(succ(b))) :  a = b := \n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 31, "textBefore": "import mynat.definition -- hide\nimport mynat.add -- hide\nimport game.world8.level1 -- hide\nnamespace mynat -- hide\n\n/-\n\n# Advanced Addition World\n\n## Level 2: `succ_succ_inj`.\n-/\n\n/-\nIn the below theorem, we need to apply `succ_inj` twice. Once to prove\n$succ(succ(a))=succ(succ(b))\\implies succ(a)=succ(b)$, and then again\nto prove $succ(a)=succ(b)\\implies a=b$. However `succ(a)=succ(b)` is\nnowhere to be found, it's neither an assumption or a goal when we start\nthis level. You can make it with `have` or you can use `apply`.\n-/\n/- Theorem\nFor all naturals $a$ and $b$, if we assume $succ(succ(a))=succ(succ(b))$, then we can\ndeduce $a=b$. \n-/\ntheorem succ_succ_inj {a b : mynat} (h : succ(succ(a)) = succ(succ(b))) :  a = b := \nbegin [nat_num_game]\n", "proof": "    have h2 : succ(a)=succ(b),\n      exact succ_inj(h),\n    exact succ_inj(h2),\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n## Sample solutions to this level. \n\nMake sure you understand them all. And remember that `rw` should not be used\nwith `succ_inj` -- `rw` works only with equalities or `\u2194` statements,\nnot implications or functions.\n\n-/\nexample {a b : mynat} (h : succ(succ(a)) = succ(succ(b))) :  a = b := \nbegin\n  apply succ_inj,\n  apply succ_inj,\n  exact h\nend \n\nexample {a b : mynat} (h : succ(succ(a)) = succ(succ(b))) :  a = b := \nbegin\n  apply succ_inj,\n  exact succ_inj(h),\nend \n\nexample {a b : mynat} (h : succ(succ(a)) = succ(succ(b))) :  a = b := \nbegin\n  exact succ_inj(succ_inj(h)),\nend \n\nend mynat -- hide", "height": 6, "editorText": "sorry", "lineOffset": 25, "name": "succ_succ_inj", "statement": "{a b : mynat} (h : succ(succ(a)) = succ(succ(b))) :  a = b"}, {"type": "text", "content": "320"}, {"type": "lean", "content": "321", "hidden": false}, {"type": "lean", "content": "322", "hidden": true}]}, {"name": "", "problemIndex": 6, "objects": [{"type": "lean", "content": "323", "hidden": true}, {"type": "lean", "content": "324", "hidden": true}, {"type": "lean", "content": "325", "hidden": true}, {"type": "lean", "content": "326", "hidden": true}, {"type": "text", "content": "327"}, {"type": "text", "content": "328"}, {"type": "theorem", "text": "329", "lean": "theorem succ_eq_succ_of_eq {a b : mynat} : a = b \u2192 succ(a) = succ(b) :=\n", "sideBar": true, "firstProofLineNumber": 25, "lastProofLineNumber": 27, "textBefore": "import mynat.definition -- hide\nimport mynat.add -- hide\nimport game.world8.level2 -- hide\nnamespace mynat -- hide\n\n/-\n\n# Advanced Addition World\n\n## Level 3: `succ_eq_succ_of_eq`.\n-/\n\n/-\nWe are going to prove something completely obvious: if $a=b$ then\n$succ(a)=succ(b)$. This is *not* `succ_inj`!\nThis is trivial -- we can just rewrite our proof of `a=b`.\nBut how do we get to that proof? Use the `intro` tactic.\n-/\n\n/- Theorem\nFor all naturals $a$ and $b$, $a=b\\implies succ(a)=succ(b)$. \n-/\ntheorem succ_eq_succ_of_eq {a b : mynat} : a = b \u2192 succ(a) = succ(b) :=\nbegin [nat_num_game]\n", "proof": "  intro h,\n  rw h,\n  refl,", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide", "height": 3, "editorText": "sorry", "lineOffset": 24, "name": "succ_eq_succ_of_eq", "statement": "{a b : mynat} : a = b \u2192 succ(a) = succ(b)"}, {"type": "lean", "content": "330", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "331", "hidden": true}, {"type": "lean", "content": "332", "hidden": true}, {"type": "lean", "content": "333", "hidden": true}, {"type": "lean", "content": "334", "hidden": true}, {"type": "text", "content": "335"}, {"type": "theorem", "text": "336", "lean": "theorem succ_eq_succ_iff (a b : mynat) : succ a = succ b \u2194 a = b :=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 41, "textBefore": "import mynat.definition -- hide\nimport mynat.add -- hide\nimport game.world8.level3 -- hide\nnamespace mynat -- hide\n\n/-\n\n# Advanced Addition World\n\n## Level 4: `eq_iff_succ_eq_succ`\n\nHere is an `iff` goal. You can split it into two goals (the implications in both\ndirections) using the `split` tactic, which is how you're going to have to start.\n\n`split,`\n\nNow you have two goals. The first is exactly `succ_inj` so you can close\nit with\n\n`exact succ_inj,`\n\nand the second one you could solve by looking up the name of the theorem\nyou proved in the last level and doing `exact <that name>`, or alternatively\nyou could get some more `intro` practice and seeing if you can prove it\nusing `intro`, `rw` and `refl`.\n-/\n\n/- Theorem\nTwo natural numbers are equal if and only if their successors are equal.\n-/\ntheorem succ_eq_succ_iff (a b : mynat) : succ a = succ b \u2194 a = b :=\nbegin [nat_num_game]\n", "proof": "  split,\n  { exact succ_inj},\n--  exact succ_eq_succ_of_eq,\n  { intro H,\n    rw H,\n    refl,\n  }\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 9, "editorText": "sorry", "lineOffset": 32, "name": "succ_eq_succ_iff", "statement": "(a b : mynat) : succ a = succ b \u2194 a = b"}, {"type": "lean", "content": "337", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "338", "hidden": true}, {"type": "lean", "content": "339", "hidden": true}, {"type": "lean", "content": "340", "hidden": true}, {"type": "lean", "content": "341", "hidden": true}, {"type": "text", "content": "342"}, {"type": "theorem", "text": "343", "lean": "theorem add_right_cancel (a t b : mynat) : a + t = b + t \u2192 a = b :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 35, "textBefore": "import mynat.definition -- hide\nimport mynat.add -- hide\nimport game.world8.level4 -- hide\nnamespace mynat -- hide\n\n/-\n\n# Advanced Addition World\n\n## Level 5: `add_right_cancel`\n\nThe theorem `add_right_cancel` is the theorem that you can cancel on the right\nwhen you're doing addition -- if `a + t = b + t` then `a = b`. After `intro h`\nI'd recommend induction on `t`. Don't forget that `rw add_zero at h` can be used\nto do rewriting of hypotheses rather than the goal.\n-/\n\n\n/- Theorem\nOn the set of natural numbers, addition has the right cancellation property.\nIn other words, if there are natural numbers $a, b$ and $c$ such that\n$$ a + t = b + t, $$\nthen we have $a = b$.\n-/\ntheorem add_right_cancel (a t b : mynat) : a + t = b + t \u2192 a = b :=\nbegin [nat_num_game]\n", "proof": "  intro h,\n  induction t with d hd,\n  rw add_zero at h,\n  rw add_zero at h,\n  exact h,\n  apply hd,\n  rw add_succ at h,\n  rw add_succ at h,\n  exact succ_inj(h),  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 9, "editorText": "sorry", "lineOffset": 26, "name": "add_right_cancel", "statement": "(a t b : mynat) : a + t = b + t \u2192 a = b"}, {"type": "lean", "content": "344", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "345", "hidden": true}, {"type": "lean", "content": "346", "hidden": true}, {"type": "text", "content": "347"}, {"type": "theorem", "text": "348", "lean": "theorem add_left_cancel (t a b : mynat) : t + a = t + b \u2192 a = b :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 33, "textBefore": "import game.world8.level5 -- hide\nnamespace mynat -- hide\n\n/-\n\n# Advanced Addition World\n\n## Level 6: `add_left_cancel`\n\nThe theorem `add_left_cancel` is the theorem that you can cancel on the left\nwhen you're doing addition -- if `t + a = t + b` then `a = b`. \nThere is a three-line proof which ends in `exact add_right_cancel a t b` (or even\n`exact add_right_cancel _ _ _`); this\nstrategy involves changing the goal to the statement of `add_right_cancel` somehow.\n\n\n-/\n\n\n/- Theorem\nOn the set of natural numbers, addition has the left cancellation property.\nIn other words, if there are natural numbers $a, b$ and $t$ such that\n$$ t + a = t + b, $$\nthen we have $a = b$.\n-/\ntheorem add_left_cancel (t a b : mynat) : t + a = t + b \u2192 a = b :=\nbegin [nat_num_game]\n", "proof": "  rw add_comm,\n  rw add_comm t,\n  exact add_right_cancel a t b,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 6, "editorText": "sorry", "lineOffset": 27, "name": "add_left_cancel", "statement": "(t a b : mynat) : t + a = t + b \u2192 a = b"}, {"type": "lean", "content": "349", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "350", "hidden": true}, {"type": "lean", "content": "351", "hidden": true}, {"type": "text", "content": "352"}, {"type": "theorem", "text": "353", "lean": "theorem add_right_cancel_iff (t a b : mynat) :  a + t = b + t \u2194 a = b :=\n", "sideBar": true, "firstProofLineNumber": 25, "lastProofLineNumber": 33, "textBefore": "import game.world8.level6 -- hide\nnamespace mynat -- hide\n\n/-\n\n# Advanced Addition World\n\n## Level 7: `add_right_cancel_iff`\n\nIt's sometimes convenient to have the \"if and only if\" version\nof theorems like `add_right_cancel`. Remember that you can use `split`\nto split an `\u2194` goal into the `\u2192` goal and the `\u2190` goal.\n\n## Pro tip:\n\n`exact add_right_cancel _ _ _` means \"let Lean figure out the missing inputs\"\n-/\n\n/- Theorem\nFor all naturals $a$, $b$ and $t$, \n$$ a + t = b + t\\iff a=b. $$\n-/\ntheorem add_right_cancel_iff (t a b : mynat) :  a + t = b + t \u2194 a = b :=\nbegin [nat_num_game]\n", "proof": "  split,\n  { exact add_right_cancel _ _ _}, -- done that way already,\n  { intro H, -- H : a = b,\n    rw H,\n    refl,\n  }\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 9, "editorText": "sorry", "lineOffset": 24, "name": "add_right_cancel_iff", "statement": "(t a b : mynat) :  a + t = b + t \u2194 a = b"}, {"type": "lean", "content": "354", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "355", "hidden": true}, {"type": "lean", "content": "356", "hidden": true}, {"type": "text", "content": "357"}, {"type": "lemma", "text": "358", "lean": "lemma eq_zero_of_add_right_eq_self {a b : mynat} : a + b = a \u2192 b = 0 :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 30, "textBefore": "import game.world8.level7 -- hide\nnamespace mynat -- hide\n\n/-\n\n# Advanced Addition World\n\n## Level 8: `eq_zero_of_add_right_eq_self`\n\nThe lemma you're about to prove will be useful when we want to prove that $\\leq$ is antisymmetric.\nThere are some wrong paths that you can take with this one.\n-/\n\n/- Lemma\nIf $a$ and $b$ are natural numbers such that \n$$ a + b = a, $$\nthen $b = 0$.\n-/\n\nlemma eq_zero_of_add_right_eq_self {a b : mynat} : a + b = a \u2192 b = 0 :=\nbegin [nat_num_game]\n", "proof": "  intro h,\n  apply add_left_cancel a,\n  rw h,\n  rw add_zero,\n  refl,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 9, "editorText": "sorry", "lineOffset": 21, "name": "eq_zero_of_add_right_eq_self", "statement": "{a b : mynat} : a + b = a \u2192 b = 0"}, {"type": "lean", "content": "359", "hidden": true}]}, {"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "360", "hidden": true}, {"type": "lean", "content": "361", "hidden": true}, {"type": "lean", "content": "362", "hidden": true}, {"type": "lean", "content": "363", "hidden": true}, {"type": "axiom", "content": "364", "name": "zero_ne_succ (a : mynat) :", "sideBar": true}, {"type": "tactic", "content": "365", "name": "symmetry", "sideBar": true}, {"type": "text", "content": "366"}, {"type": "theorem", "text": "367", "lean": "theorem succ_ne_zero (a : mynat) : succ a \u2260 0 := \n", "sideBar": true, "firstProofLineNumber": 63, "lastProofLineNumber": 66, "textBefore": "import mynat.definition -- hide\nimport mynat.add -- hide\nimport game.world8.level8 -- hide\nnamespace mynat -- hide\n\n/- Axiom : zero_ne_succ (a : mynat) :\n0 \u2260 succ(a)\n-/\n\n/- Tactic : symmetry\n\n## Summary\n\n`symmetry` turns goals of the form `\u22a2 A = B` to `\u22a2 B = A`.\nAlso works with `\u2260`. Also works on hypotheses: if `h : a \u2260 b`\nthen `symmetry at h` gives `h : b \u2260 a`.\n\n## Details\n\n`symmetry` works on both goals and hypotheses. By default it\nworks on the goal. It will turn a goal of the form `\u22a2 A = B`\nto `\u22a2 B = A`. More generally it will work with any symmetric\nbinary relation (for example `\u2260`, or more generally any\nbinary relation whose proof of symmetry has been tagged\nwith the `symm` attribute).\n\nTo get `symmetry` working on a hypothesis, use `symmetry at h`.\n\n## Examples\n\nIf the tactic state is\n```\nh : a = b\n\u22a2 c \u2260 d\n```\n\nthen `symmetry` changes the goal to `\u22a2 d \u2260 c` and\n`symmetry at h` changes `h` to `h : b = a`.\n-/\n\n/-\n\n# Advanced Addition World\n\n## Level 9: `succ_ne_zero`\n\nLevels 9 to 13 introduce the last axiom of Peano, namely\nthat $0\\not=\\operatorname{succ}(a)$. The proof of this is called `zero_ne_succ a`. \n\n`zero_ne_succ (a : mynat) : 0 \u2260 succ(a)`\n\nThe `symmetry` tactic will turn any goal of the form `R x y` into `R y x`,\nif `R` is a symmetric binary relation (for example `=` or `\u2260`).\nIn particular, you can prove `succ_ne_zero` below by first using\n`symmetry` and then `exact zero_ne_succ a`. \n-/\n\n/- Theorem\nZero is not the successor of any natural number.\n-/\ntheorem succ_ne_zero (a : mynat) : succ a \u2260 0 := \nbegin [nat_num_game]\n", "proof": "  symmetry,\n  exact zero_ne_succ a,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat\n", "height": 4, "editorText": "sorry", "lineOffset": 62, "name": "succ_ne_zero", "statement": "(a : mynat) : succ a \u2260 0"}, {"type": "lean", "content": "368", "hidden": false}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "369", "hidden": true}, {"type": "lean", "content": "370", "hidden": true}, {"type": "text", "content": "371"}, {"type": "lemma", "text": "372", "lean": "lemma add_left_eq_zero {{a b : mynat}} (H : a + b = 0) : b = 0 :=\n", "sideBar": true, "firstProofLineNumber": 65, "lastProofLineNumber": 72, "textBefore": "import game.world8.level9 -- hide\nnamespace mynat -- hide\n\n/-\n# Advanced Addition World\n\n## Level 10: `add_left_eq_zero`\n\n## Important: the definition of `\u2260`\n\nIn Lean, `a \u2260 b` is *defined to mean* `(a = b) \u2192 false`. \nThis means that if you see `a \u2260 b` you can *literally treat\nit as saying* `(a = b) \u2192 false`. Computer scientists would\nsay that these two terms are *definitionally equal*. \n\nThe following lemma, $a+b=0\\implies b=0$, will be useful in inequality world.\nLet me go through the proof, because it introduces several new\nconcepts: \n\n* `cases b`, where `b : mynat`\n* `exfalso`\n* `apply succ_ne_zero`\n\nWe're going to prove $a+b=0\\implies b=0$. Here is the\nstrategy. Each natural number is either `0` or `succ(d)` for\nsome other natural number `d`. So we can start the proof\nwith \n\n`cases b with d,`\n\nand then we have two goals, the case `b = 0` (which you can solve easily)\nand the case `b = succ(d)`, which looks like this:\n\n```\na d : mynat,\nH : a + succ d = 0\n\u22a2 succ d = 0\n```\n\nOur goal is impossible to prove. However our hypothesis `H`\nis also impossible, meaning that we still have a chance!\nFirst let's see why `H` is impossible. We can\n\n`rw add_succ at H,`\n\nto turn `H` into `H : succ (a + d) = 0`. Because\n`succ_ne_zero (a + d)` is a proof that `succ (a + d) \u2260 0`,\nit is also a proof of the implication `succ (a + d) = 0 \u2192 false`.\nHence `succ_ne_zero (a + d) H` is a proof of `false`!\nUnfortunately our goal is not `false`, it's a generic\nfalse statement. \n\nRecall however that the `exfalso` command turns any goal into `false`\n(it's logically OK because `false` implies every proposition, true or false).\nYou can probably take it from here.\n-/\n\n/- Lemma\nIf $a$ and $b$ are natural numbers such that \n$$ a + b = 0, $$\nthen $b = 0$.\n-/\nlemma add_left_eq_zero {{a b : mynat}} (H : a + b = 0) : b = 0 :=\nbegin [nat_num_game]\n", "proof": "  cases b with d,\n  { refl},\n  { rw add_succ at H,\n    exfalso,\n    apply succ_ne_zero (a + d),\n    exact H,\n  },\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 64, "name": "add_left_eq_zero", "statement": "{{a b : mynat}} (H : a + b = 0) : b = 0"}, {"type": "lean", "content": "373", "hidden": true}]}, {"name": "", "problemIndex": 5, "objects": [{"type": "lean", "content": "374", "hidden": true}, {"type": "lean", "content": "375", "hidden": true}, {"type": "lean", "content": "376", "hidden": true}, {"type": "lean", "content": "377", "hidden": true}, {"type": "text", "content": "378"}, {"type": "lemma", "text": "379", "lean": "lemma add_right_eq_zero {a b : mynat} : a + b = 0 \u2192 a = 0 :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 25, "textBefore": "import mynat.definition -- hide\nimport mynat.add -- hide\nimport game.world8.level10 -- hide\nnamespace mynat -- hide\n\n/-\n\n# Advanced Addition World\n\n## Level 11: `add_right_eq_zero`\n\nWe just proved `add_left_eq_zero (a b : mynat) : a + b = 0 \u2192 b = 0`.\nHopefully `add_right_eq_zero` shouldn't be too hard now.\n-/\n\n/- Lemma\nIf $a$ and $b$ are natural numbers such that \n$$ a + b = 0, $$\nthen $a = 0$.\n-/\nlemma add_right_eq_zero {a b : mynat} : a + b = 0 \u2192 a = 0 :=\nbegin [nat_num_game]\n", "proof": "  intro H,\n  rw add_comm at H,\n  exact add_left_eq_zero H,", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 3, "editorText": "sorry", "lineOffset": 22, "name": "add_right_eq_zero", "statement": "{a b : mynat} : a + b = 0 \u2192 a = 0"}, {"type": "lean", "content": "380", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "381", "hidden": true}, {"type": "lean", "content": "382", "hidden": true}, {"type": "text", "content": "383"}, {"type": "theorem", "text": "384", "lean": "theorem add_one_eq_succ (d : mynat) : d + 1 = succ d :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 27, "textBefore": "import game.world8.level11 -- hide\nnamespace mynat -- hide\n\n/-\n\n# Advanced Addition World\n\n## Level 12: `add_one_eq_succ`\n\nWe have\n\n  * `succ_eq_add_one (n : mynat) : succ n = n + 1`\n\nbut sometimes the other way is also convenient.\n-/\n\n/- Theorem\nFor any natural number $d$, we have\n$$ d+1 = \\operatorname{succ}(d). $$\n-/\ntheorem add_one_eq_succ (d : mynat) : d + 1 = succ d :=\nbegin [nat_num_game]\n", "proof": "  rw succ_eq_add_one,\n  refl,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 5, "editorText": "sorry", "lineOffset": 22, "name": "add_one_eq_succ", "statement": "(d : mynat) : d + 1 = succ d"}, {"type": "lean", "content": "385", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "386", "hidden": true}, {"type": "lean", "content": "387", "hidden": true}, {"type": "text", "content": "388"}, {"type": "lemma", "text": "389", "lean": "lemma ne_succ_self (n : mynat) : n \u2260 succ n :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 30, "textBefore": "import game.world8.level12 -- hide\nnamespace mynat -- hide\n\n/-\n\n# Advanced Addition World\n\n## Level 13: `ne_succ_self`\n\nThe last level in Advanced Addition World is the statement\nthat $n\\not=\\operatorname{succ}(n)$. When you've done this\nyou've completed Advanced Addition World and can move on\nto Advanced Multiplication World (after first doing\nMultiplication World, if you didn't do it already). \n-/\n\n/- Lemma\nFor any natural number $n$, we have\n$$ n \\neq \\operatorname{succ}(n). $$\n-/\nlemma ne_succ_self (n : mynat) : n \u2260 succ n :=\nbegin [nat_num_game]\n", "proof": "  induction n with d hd,\n    apply zero_ne_succ,\n  intro hs,\n  apply hd,\n  apply succ_inj,\n  assumption\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 22, "name": "ne_succ_self", "statement": "(n : mynat) : n \u2260 succ n"}, {"type": "lean", "content": "390", "hidden": true}]}], "parents": [6]}, {"name": "391", "levels": [{"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "392", "hidden": true}, {"type": "lean", "content": "393", "hidden": false}, {"type": "lean", "content": "394", "hidden": true}, {"type": "text", "content": "395"}, {"type": "theorem", "text": "396", "lean": "theorem mul_pos (a b : mynat) : a \u2260 0 \u2192 b \u2260 0 \u2192 a * b \u2260 0 :=\n", "sideBar": true, "firstProofLineNumber": 38, "lastProofLineNumber": 51, "textBefore": "import game.world8.level13 -- hide\nimport game.world3.level9\nnamespace mynat -- hide\n\n/-\n# Advanced Multiplication World\n\n## Level 1: `mul_pos`\n\nWelcome to Advanced Multiplication World! Before attempting this\nworld you should have completed seven other worlds, including\nMultiplication World and Advanced Addition World. There are four\nlevels in this world.\n\nRecall that if `b : mynat` is a hypothesis and you do `cases b with n`,\nyour one goal will split into two goals, \nnamely the cases `b = 0` and `b = succ(n)`. So `cases` here is like\na weaker version of induction (you don't get the inductive hypothesis).\n\n## Tricks\n\n1) if your goal is `\u22a2 X \u2260 Y` then `intro h` will give you `h : X = Y` and\na goal of `\u22a2 false`. This is because `X \u2260 Y` *means* `(X = Y) \u2192 false`.\nConversely if your goal is `false` and you have `h : X \u2260 Y` as a hypothesis\nthen `apply h` will turn the goal into `X = Y`.\n\n2) if `hab : succ (3 * x + 2 * y + 1) = 0` is a hypothesis and your goal is `\u22a2 false`,\nthen `exact succ_ne_zero _ hab` will solve the goal, because Lean will figure\nout that `_` is supposed to be `3 * x + 2 * y + 1`.\n\n-/\n\n/- Theorem\nThe product of two non-zero natural numbers is non-zero.\n-/\ntheorem mul_pos (a b : mynat) : a \u2260 0 \u2192 b \u2260 0 \u2192 a * b \u2260 0 :=\nbegin [nat_num_game]\n", "proof": "  intros ha hb,\n  intro hab,\n  cases b with b,\n    apply hb,\n    refl,\n  rw mul_succ at hab,\n  apply ha,\n  cases a with a,\n    refl,\n  rw add_succ at hab,\n  exfalso,\n  exact succ_ne_zero _ hab,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 14, "editorText": "sorry", "lineOffset": 37, "name": "mul_pos", "statement": "(a b : mynat) : a \u2260 0 \u2192 b \u2260 0 \u2192 a * b \u2260 0"}, {"type": "lean", "content": "397", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "398", "hidden": true}, {"type": "lean", "content": "399", "hidden": true}, {"type": "text", "content": "400"}, {"type": "theorem", "text": "401", "lean": "theorem eq_zero_or_eq_zero_of_mul_eq_zero (a b : mynat) (h : a * b = 0) :\n  a = 0 \u2228 b = 0 :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 27, "textBefore": "import game.world9.level1 -- hide\nnamespace mynat -- hide\n\n/-\n# Advanced Multiplication World\n\n## Level 2: `eq_zero_or_eq_zero_of_mul_eq_zero`\n\nA variant on the previous level.\n-/\n\n/- Theorem\nIf $ab = 0$, then at least one of $a$ or $b$ is equal to zero.\n-/\ntheorem eq_zero_or_eq_zero_of_mul_eq_zero (a b : mynat) (h : a * b = 0) :\n  a = 0 \u2228 b = 0 :=\nbegin [nat_num_game]\n", "proof": "  cases a with d,\n    left,\n    refl,\n  cases b with e he,\n    right,\n    refl,\n  exfalso,\n  rw mul_succ at h,\n  rw add_succ at h,\n  exact succ_ne_zero _ h,", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 10, "editorText": "sorry", "lineOffset": 17, "name": "eq_zero_or_eq_zero_of_mul_eq_zero", "statement": "(a b : mynat) (h : a * b = 0) :\n  a = 0 \u2228 b = 0"}, {"type": "lean", "content": "402", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "403", "hidden": true}, {"type": "lean", "content": "404", "hidden": true}, {"type": "text", "content": "405"}, {"type": "theorem", "text": "406", "lean": "theorem mul_eq_zero_iff (a b : mynat): a * b = 0 \u2194 a = 0 \u2228 b = 0 :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 30, "textBefore": "import game.world9.level2 -- hide\nnamespace mynat -- hide\n\n/-\n# Advanced Multiplication World\n\n## Level 3: `mul_eq_zero_iff`\n\nNow you have `eq_zero_or_eq_zero_of_mul_eq_zero` this is pretty straightforward.\n-/\n\n/- Theorem\n$ab = 0$, if and only if at least one of $a$ or $b$ is equal to zero.\n-/\ntheorem mul_eq_zero_iff (a b : mynat): a * b = 0 \u2194 a = 0 \u2228 b = 0 :=\nbegin [nat_num_game]\n", "proof": "  split,\n    swap,\n    intro hab,\n    cases hab,\n      rw hab,\n      rw zero_mul,\n      refl,\n    rw hab,\n    rw mul_zero,\n    refl,\n  intro h,\n  exact eq_zero_or_eq_zero_of_mul_eq_zero a b h,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 14, "editorText": "sorry", "lineOffset": 16, "name": "mul_eq_zero_iff", "statement": "(a b : mynat): a * b = 0 \u2194 a = 0 \u2228 b = 0"}, {"type": "lean", "content": "407", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "408", "hidden": true}, {"type": "lean", "content": "409", "hidden": true}, {"type": "text", "content": "410"}, {"type": "theorem", "text": "411", "lean": "theorem mul_left_cancel (a b c : mynat) (ha : a \u2260 0) : a * b = a * c \u2192 b = c :=\n", "sideBar": true, "firstProofLineNumber": 56, "lastProofLineNumber": 84, "textBefore": "import game.world9.level3 -- hide\nnamespace mynat -- hide\n\n/-\n# Advanced Multiplication World\n\n## Level 4: `mul_left_cancel`\n\nThis is the last of the bonus multiplication levels.\n`mul_left_cancel` will be useful in inequality world.\n\nPeople find this level hard. I have probably had more questions about this\nlevel than all the other levels put together, in fact. Many levels in this\ngame can just be solved by \"running at it\" -- do induction on one of the\nvariables, keep your head, and you're done. In fact, if you like a challenge,\nit might be instructive if you stop reading after the end of this paragraph and try solving this level now by induction,\nseeing the trouble you run into, and reading the rest of these comments afterwards. This level\nhas a sting in the tail. If you are a competent mathematician, try\nand figure out what is going on. Write down a maths proof of the\ntheorem in this level. Exactly what statement do you want to prove\nby induction? It is subtle.\n\nOk so here are some spoilers. The problem with naively running at it, is that if you try induction on,\nsay, $c$, then you are imagining a and b as fixed, and your inductive\nhypothesis $P(c)$ is $ab=ac \\implies b=c$. So for your inductive step\nyou will be able to assume $ab=ad \\implies b=d$ and your goal will\nbe to show $ab=a(d+1) \\implies b=d+1$. When you also assume $ab=a(d+1)$\nyou will realise that your inductive hypothesis is *useless*, because\n$ab=ad$ is not true! The statement $P(c)$ (with $a$ and $b$ regarded\nas constants) is not provable by induction.\n\nWhat you *can* prove by induction is the following *stronger* statement.\nImagine $a\\not=0$ as fixed, and then prove \"for all $b$, if $ab=ac$ then $b=c$\"\nby induction on $c$. This gives us the extra flexibility we require.\nNote that we are quantifying over all $b$ in the inductive hypothesis -- it\nis essential that $b$ is not fixed. \n\nYou can do this in two ways in Lean -- before you start the induction\nyou can write `revert b,`. The `revert` tactic is the opposite of the `intro`\ntactic; it replaces the `b` in the hypotheses with \"for all $b$\" in the goal.\n\nAlternatively, you can write `induction c with d hd\ngeneralizing b` as the first line of the proof. \n\nIf you do not modify your technique in this way, then this level seems\nto be impossible (judging by the comments I've had about it!)\n-/\n\n/- Theorem\nIf $a \\neq 0$, $b$ and $c$ are natural numbers such that\n$ ab = ac, $\nthen $b = c$.\n-/\ntheorem mul_left_cancel (a b c : mynat) (ha : a \u2260 0) : a * b = a * c \u2192 b = c :=\nbegin [nat_num_game]\n", "proof": "  induction c with d hd generalizing b,\n  { rw mul_zero,\n    intro h,\n    cases (eq_zero_or_eq_zero_of_mul_eq_zero _ _ h) with h1 h2,\n      exfalso,\n      apply ha,\n      assumption,\n    assumption\n  },\n  { intro hb,\n    cases b with c,\n    { rw mul_zero at hb,\n      exfalso,\n      apply ha,\n      symmetry at hb,\n      cases (eq_zero_or_eq_zero_of_mul_eq_zero _ _ hb) with h h,\n        exact h,\n      exfalso,\n      exact succ_ne_zero _ h,\n    },\n    { have h : c = d,\n        apply hd,\n        rw mul_succ at hb,\n        rw mul_succ at hb,\n        apply add_right_cancel _ _ _ hb,\n      rw h,\n      refl,\n    }\n  }", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n\n/-\nYou should now be ready for inequality world.\n-/\n\n/- Tactic : revert\n\n## Summary\n\n`revert x` is the opposite to `intro x`.\n\n## Details\n\nIf the tactic state looks like this\n\n```\nP Q : Prop,\nh : P\n\u22a2 Q\n```\n\nthen `revert h` will change it to\n\n```\nP Q : Prop\n\u22a2 P \u2192 Q\n```\n\n`revert` also works with things like natural numbers: if\nthe tactic state looks like this\n\n```\nm : mynat\n\u22a2 m + 1 = succ m\n```\n\nthen `revert m` will turn it into\n\n```\n\u22a2 \u2200 (m : mynat), m + 1 = mynat.succ m\n```\n\n-/\n", "height": 29, "editorText": "sorry", "lineOffset": 55, "name": "mul_left_cancel", "statement": "(a b c : mynat) (ha : a \u2260 0) : a * b = a * c \u2192 b = c"}, {"type": "lean", "content": "412", "hidden": true}, {"type": "text", "content": "413"}, {"type": "tactic", "content": "414", "name": "revert", "sideBar": true}]}], "parents": [2, 7]}, {"name": "415", "levels": [{"name": "", "problemIndex": 7, "objects": [{"type": "lean", "content": "416", "hidden": false}, {"type": "lean", "content": "417", "hidden": true}, {"type": "lean", "content": "418", "hidden": true}, {"type": "lean", "content": "419", "hidden": true}, {"type": "axiom", "content": "420", "name": "le_iff_exists_add (a b : mynat)", "sideBar": true}, {"type": "tactic", "content": "421", "name": "use", "sideBar": true}, {"type": "text", "content": "422"}, {"type": "lemma", "text": "423", "lean": "lemma one_add_le_self (x : mynat) : x \u2264 1 + x :=\n", "sideBar": false, "firstProofLineNumber": 96, "lastProofLineNumber": 100, "textBefore": "import mynat.le -- import definition of \u2264\nimport game.world9.level4 -- hide\nimport game.world4.level8 -- hide\nnamespace mynat -- hide\n/- Axiom : le_iff_exists_add (a b : mynat)\n  a \u2264 b \u2194 \u2203 (c : mynat), b = a + c\n-/\n\n/- Tactic : use\n## Summary\n\n`use` works on the goal. If your goal is `\u22a2 \u2203 c : mynat, 1 + x = x + c`\nthen `use 1` will turn the goal into `\u22a2 1 + x = x + 1`, and the rather\nmore unwise `use 0` will turn it into the impossible-to-prove\n`\u22a2 1 + x = x + 0`.\n\n## Details\n\n`use` is a tactic which works on goals of the form `\u22a2 \u2203 c, P(c)` where\n`P(c)` is some proposition which depends on `c`. With a goal of this\nform, `use 0` will turn the goal into `\u22a2 P(0)`, `use x + y` (assuming\n`x` and `y` are natural numbers in your local context) will turn\nthe goal into `P(x + y)` and so on.\n-/\n\n/- \n\n# Inequality world. \n\nA new import, giving us a new definition. If `a` and `b` are naturals,\n`a \u2264 b` is *defined* to mean\n\n`\u2203 (c : mynat), b = a + c`\n\nThe upside-down E means \"there exists\". So in words, $a\\le b$\nif and only if there exists a natural $c$ such that $b=a+c$. \n\nIf you really want to change an `a \u2264 b` to `\u2203 c, b = a + c` then\nyou can do so with `rw le_iff_exists_add`:\n\n```\nle_iff_exists_add (a b : mynat) :\n  a \u2264 b \u2194 \u2203 (c : mynat), b = a + c\n```\n\nBut because `a \u2264 b` is *defined as* `\u2203 (c : mynat), b = a + c`, you\ndo not need to `rw le_iff_exists_add`, you can just pretend when you see `a \u2264 b`\nthat it says `\u2203 (c : mynat), b = a + c`. You will see a concrete\nexample of this below.\n\nA new construction like `\u2203` means that we need to learn how to manipulate it.\nThere are two situations. Firstly we need to know how to solve a goal\nof the form `\u22a2 \u2203 c, ...`, and secondly we need to know how to use a hypothesis\nof the form `\u2203 c, ...`. \n\n## Level 1: the `use` tactic.\n\nThe goal below is to prove $x\\le 1+x$ for any natural number $x$. \nFirst let's turn the goal explicitly into an existence problem with\n\n`rw le_iff_exists_add,`\n\nand now the goal has become `\u2203 c : mynat, 1 + x = x + c`. Clearly\nthis statement is true, and the proof is that $c=1$ will work (we also\nneed the fact that addition is commutative, but we proved that a long\ntime ago). How do we make progress with this goal?\n\nThe `use` tactic can be used on goals of the form `\u2203 c, ...`. The idea\nis that we choose which natural number we want to use, and then we use it.\nSo try\n\n`use 1,`\n\nand now the goal becomes `\u22a2 1 + x = x + 1`. You can solve this by\n`exact add_comm 1 x`, or if you are lazy you can just use the `ring` tactic,\nwhich is a powerful AI which will solve any equality in algebra which can\nbe proved using the standard rules of addition and multiplication. Now\nlook at your proof. We're going to remove a line.\n\n## Important\n\nAn important time-saver here is to note that because `a \u2264 b` is *defined*\nas `\u2203 c : mynat, b = a + c`, you *do not need to write* `rw le_iff_exists_add`.\nThe `use` tactic will work directly on a goal of the form `a \u2264 b`. Just\nuse the difference `b - a` (note that we have not defined subtraction so\nthis does not formally make sense, but you can do the calculation in your head).\nIf you have written `rw le_iff_exists_add` below, then just put two minus signs `--`\nbefore it and comment it out. See that the proof still compiles.\n-/\n\n/- Lemma : no-side-bar\nIf $x$ is a natural number, then $x\\le 1+x$.\n-/\nlemma one_add_le_self (x : mynat) : x \u2264 1 + x :=\nbegin\n", "proof": "  rw le_iff_exists_add,\n  use 1,\n  ring,\n\n", "proof_hint": "sorry", "textAfter": "\nend \nend mynat -- hide\n", "height": 5, "editorText": "sorry", "lineOffset": 95, "name": "one_add_le_self", "statement": "(x : mynat) : x \u2264 1 + x"}, {"type": "lean", "content": "424", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "425", "hidden": true}, {"type": "lean", "content": "426", "hidden": true}, {"type": "text", "content": "427"}, {"type": "lemma", "text": "428", "lean": "lemma le_refl (x : mynat) : x \u2264 x :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 21, "textBefore": "import game.world10.level1 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\nHere's a nice easy one.\n\n## Level 2: le_refl \n-/\n/- Lemma : \nThe $\\le$ relation is reflexive. In other words, if $x$ is a natural number,\nthen $x\\le x$.\n-/\nlemma le_refl (x : mynat) : x \u2264 x :=\nbegin [nat_num_game]\n", "proof": "  use 0,\n  rw add_zero,\n  refl,\n\n", "proof_hint": "sorry", "textAfter": "\nend \n/-\n## Upgrading the `refl` tactic \n\nNow with the following incantation (NB thanks to master wizard Reid Barton\nfor correcting my spell)...\n-/\nattribute [refl] mynat.le_refl\n/-\n...we find that the `refl` tactic will close all goals\nof the form `a \u2264 a` as well as all goals of the form `a = a`.\n-/\nexample : (0 : mynat) \u2264 0 := begin\n  refl\nend\n\n/-\n## Pro tip\n\nDid you skip `rw le_iff_exists_add` in your proof of `le_refl` above?\nInstead of `rw add_zero` or `ring` or `exact add_zero x` at the end there,\nwhat happens if you just try `refl`? The *definition* of `x + 0` is `x`,\nso you don't need to `rw add_zero` either! The proof\n\n```\nuse 0,\nrefl,\n```\n\nworks.\n\nThe same remarks are true of\n`add_succ`, `mul_zero`, `mul_succ`, `pow_zero` and `pow_succ`. All of those\ntheorems are true *by definition*. The same is *not* true however of `zero_add`; \nthe theorem `0 + x = x` was proved by induction on `x`,\nand in particular it is not true by *definition*.\n\nDefinitional equality is of great importance\nto computer scientists, but mathematicians are much more fluid with their idea\nof a definition -- a concept can simultaneously have three equivalent definitions\nin a maths talk, as long as they're all logically equivalent. In Lean, a definition\nis *one thing*, and definitional equality is a subtle concept which depends on\nexactly which definition you chose. `add_comm` is certainly not true by definition,\nwhich means that if we had decided to define `a \u2264 b` by `\u2203 c, b = c + a` (rather\nthan `a + c`) all the same theorems would be true, but `refl` would work in\ndifferent places. `refl` closes a goal of the form `X = Y` if `X` and `Y` are\ndefinitionally equal.\n-/\nend mynat -- hide\n", "height": 5, "editorText": "sorry", "lineOffset": 16, "name": "le_refl", "statement": "(x : mynat) : x \u2264 x"}, {"type": "text", "content": "429"}, {"type": "lean", "content": "430", "hidden": false}, {"type": "text", "content": "431"}, {"type": "lean", "content": "432", "hidden": false}, {"type": "text", "content": "433"}, {"type": "lean", "content": "434", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "435", "hidden": true}, {"type": "lean", "content": "436", "hidden": true}, {"type": "text", "content": "437"}, {"type": "lemma", "text": "438", "lean": "theorem le_succ (a b : mynat) : a \u2264 b \u2192 a \u2264 (succ b) :=\n", "sideBar": true, "firstProofLineNumber": 44, "lastProofLineNumber": 50, "textBefore": "import game.world10.level2 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\n## Level 3: `le_succ_of_le`\n\nWe have seen how the `use` tactic makes progress on goals of the form `\u22a2 \u2203 c, ...`.\nBut what do we do when we have a *hypothesis* of the form `h : \u2203 c, ...`?\nThe hypothesis claims that there exists some natural number `c` with some\nproperty. How are we going to get to that natural number `c`? It turns out\nthat the `cases` tactic can be used (just like it was used to extract\ninformation from `\u2227` and `\u2228` and `\u2194` hypotheses). Let me talk you through\nthe proof of $a\\le b\\implies a\\le\\operatorname{succ}(b)$.\n\nThe goal is an implication so we clearly want to start with \n\n`intro h,`\n\n. After this, if you *want*, you can do something like\n\n`rw le_iff_exists_add at h \u22a2,`\n\n(get the sideways T with `\\|-` then space). This changes the `\u2264` into\nits `\u2203` form in `h` and the goal -- but if you are happy with just\n*imagining* the `\u2203` whenever you read a `\u2264` then you don't need to do this line.\n\nOur hypothesis `h` is now `\u2203 (c : mynat), b = a + c` (or `a \u2264 b` if you\nelected not to do the definitional rewriting) so\n\n`cases h with c hc,`\n\ngives you the natural number `c` and the hypothesis `hc : b = a + c`.\nNow use `use` wisely and you're home.\n\n-/\n\n/- Lemma\nFor all naturals $a$, $b$, if $a\\leq b$ then $a\\leq \\operatorname{succ}(b)$. \n-/\ntheorem le_succ (a b : mynat) : a \u2264 b \u2192 a \u2264 (succ b) :=\nbegin [nat_num_game]\n", "proof": "  intro h,\n  cases h with c hc,\n  rw hc,\n  use c + 1,\n  refl,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\n\n\nDid you use `succ c` or `c + 1` or `1 + c`? Those numbers are all\nequal, right? So it doesn't matter which one you use, right?\n\nHere's an interesting question. If you copy the proof below into\nthe box above, and then fill in the `???`\nbelow with `succ c`, will this proof compile? (move your cursor to\nafter the final comma to see what Lean thinks). What about if you\n`use 1 + c`? What about if you `use c + 1`? Can you work out\nwhat is going on? Does it help if I tell you that the *definition*\nof `1` is `succ 0`?\n\n```\ntheorem le_succ (a b : mynat) : a \u2264 b \u2192 a \u2264 (succ b) :=\nbegin [nat_num_game]\n  intro h,\n  cases h with c hc,\n  rw hc,\n  use ???,\n  refl,\n\n\nend\n```\n\n-/\nend mynat -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 43, "name": "le_succ", "statement": "(a b : mynat) : a \u2264 b \u2192 a \u2264 (succ b)"}, {"type": "text", "content": "439"}, {"type": "lean", "content": "440", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "441", "hidden": true}, {"type": "lean", "content": "442", "hidden": true}, {"type": "text", "content": "443"}, {"type": "lemma", "text": "444", "lean": "lemma zero_le (a : mynat) : 0 \u2264 a :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 21, "textBefore": "import game.world10.level3 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\n## Level 4: `zero_le`\n\nAnother easy one. \n-/\n\n/- Lemma\nFor all naturals $a$, $0\\leq a$.\n-/\nlemma zero_le (a : mynat) : 0 \u2264 a :=\nbegin [nat_num_game]\n", "proof": "  use a,\n  rw zero_add,\n  refl,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 5, "editorText": "sorry", "lineOffset": 16, "name": "zero_le", "statement": "(a : mynat) : 0 \u2264 a"}, {"type": "lean", "content": "445", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "446", "hidden": true}, {"type": "lean", "content": "447", "hidden": true}, {"type": "text", "content": "448"}, {"type": "lemma", "text": "449", "lean": "theorem le_trans (a b c : mynat) (hab : a \u2264 b) (hbc : b \u2264 c) : a \u2264 c :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 23, "textBefore": "import game.world10.level4 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\n## Level 5: `le_trans`\n\nAnother straightforward one. \n-/\n\n\n/- Lemma\n\u2264 is transitive. In other words, if $a\\leq b$ and $b\\leq c$ then $a\\leq c$. \n-/\ntheorem le_trans (a b c : mynat) (hab : a \u2264 b) (hbc : b \u2264 c) : a \u2264 c :=\nbegin [nat_num_game]\n", "proof": "  cases hab with d hd,\n  cases hbc with e he,\n  use (d + e),\n  rw \u2190add_assoc,\n  rw \u2190hd,\n  assumption,", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nCongratulations -- you just got a collectible. You proved that the\nnatural numbers are a preorder.\n-/\ninstance : preorder mynat := by structure_helper\nend mynat -- hide\n", "height": 6, "editorText": "sorry", "lineOffset": 17, "name": "le_trans", "statement": "(a b c : mynat) (hab : a \u2264 b) (hbc : b \u2264 c) : a \u2264 c"}, {"type": "text", "content": "450"}, {"type": "lean", "content": "451", "hidden": false}, {"type": "lean", "content": "452", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "453", "hidden": true}, {"type": "lean", "content": "454", "hidden": true}, {"type": "text", "content": "455"}, {"type": "lemma", "text": "456", "lean": "theorem le_antisymm (a b : mynat) (hab : a \u2264 b) (hba : b \u2264 a) : a = b :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 39, "textBefore": "import game.world10.level5 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\n## Level 6: `le_antisymm`\n\nIn Advanced Addition World you proved\n\n`eq_zero_of_add_right_eq_self (a b : mynat) : a + b = a \u2192 b = 0`.\n\nThis might be useful in this level.\n\nAnother tip: if you want to create a new hypothesis, you can use the `have` tactic.\nFor example, if you have a hypothesis `hd : a + (c + d) = a` and you want \na hypothesis `h : c + d = 0` then you can write\n\n`have h := eq_zero_of_add_right_eq_self hd,`\n\n-/\n\n/- Lemma\n$\\le$ is antisymmetric. In other words, if $a\\le b$ and $b\\le a$ then $a = b$. \n-/\ntheorem le_antisymm (a b : mynat) (hab : a \u2264 b) (hba : b \u2264 a) : a = b :=\nbegin [nat_num_game]\n", "proof": "  cases hab with c hc,\n  cases hba with d hd,\n  rw hc at hd,\n  rw add_assoc at hd,\n  symmetry at hd,\n  have h := eq_zero_of_add_right_eq_self hd,\n  have h2 := add_right_eq_zero h,\n  rw h2 at hc,\n  rw hc,\n  exact add_zero a,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n/-\nCongratulations -- you just proved that the natural numbers are a partial order!\n-/\n\ninstance : partial_order mynat := by structure_helper\nend mynat -- hide\n", "height": 12, "editorText": "sorry", "lineOffset": 27, "name": "le_antisymm", "statement": "(a b : mynat) (hab : a \u2264 b) (hba : b \u2264 a) : a = b"}, {"type": "text", "content": "457"}, {"type": "lean", "content": "458", "hidden": false}, {"type": "lean", "content": "459", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "460", "hidden": true}, {"type": "lean", "content": "461", "hidden": true}, {"type": "text", "content": "462"}, {"type": "lemma", "text": "463", "lean": "lemma le_zero (a : mynat) (h : a \u2264 0) : a = 0 :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 22, "textBefore": "import game.world10.level6 -- hide\nnamespace mynat -- hide\n/-\n# Inequality world \n\n## Level 7: `le_zero`\n\nWe proved `add_right_eq_zero` back in advanced addition world.\nRemember that you can do things like `have h2 := add_right_eq_zero h1`\nif `h1 : a + c = 0`.\n-/\n\n/- Lemma\nFor all naturals $a$, if $a\\le 0$ then $a = 0$.\n-/\nlemma le_zero (a : mynat) (h : a \u2264 0) : a = 0 :=\nbegin [nat_num_game]\n", "proof": "  cases h with c hc,\n  symmetry at hc,\n  exact add_right_eq_zero hc,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 5, "editorText": "sorry", "lineOffset": 17, "name": "le_zero", "statement": "(a : mynat) (h : a \u2264 0) : a = 0"}, {"type": "lean", "content": "464", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "465", "hidden": true}, {"type": "lean", "content": "466", "hidden": true}, {"type": "text", "content": "467"}, {"type": "lemma", "text": "468", "lean": "lemma succ_le_succ (a b : mynat) (h : a \u2264 b) : succ a \u2264 succ b :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 23, "textBefore": "import game.world10.level7 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\n## Level 8: `succ_le_succ`\n\nAnother straightforward one. \n-/\n\n/- Lemma\nFor all naturals $a$ and $b$, if $a\\le b$, then $\\operatorname{succ}(a)\\le\\operatorname{succ}(b)$. \n-/\nlemma succ_le_succ (a b : mynat) (h : a \u2264 b) : succ a \u2264 succ b :=\nbegin [nat_num_game]\n", "proof": "  cases h with c hc,\n  use c,\n  rw hc,\n  rw succ_add,\n  refl,\n  \n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 7, "editorText": "sorry", "lineOffset": 16, "name": "succ_le_succ", "statement": "(a b : mynat) (h : a \u2264 b) : succ a \u2264 succ b"}, {"type": "lean", "content": "469", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "470", "hidden": true}, {"type": "lean", "content": "471", "hidden": true}, {"type": "text", "content": "472"}, {"type": "lemma", "text": "473", "lean": "theorem le_total (a b : mynat) : a \u2264 b \u2228 b \u2264 a :=\n", "sideBar": true, "firstProofLineNumber": 14, "lastProofLineNumber": 29, "textBefore": "import game.world10.level8 -- hide\nnamespace mynat -- hide\n/- \n# Inequality world. \n\n## Level 9: `le_total`\n-/\n\n/- Lemma\nFor all naturals $a$ and $b$, either $a\\le b$ or $b\\le a$. \n-/\ntheorem le_total (a b : mynat) : a \u2264 b \u2228 b \u2264 a :=\nbegin [nat_num_game]\n", "proof": "  revert a,\n  induction b with d hd,\n    intro a,\n    right,\n    exact zero_le a,\n  intro a,\n  cases a with a,\n    left,\n    exact zero_le _,\n  cases hd a,\n    left,\n    exact succ_le_succ a d h,\n  right,\n  exact succ_le_succ d a h,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n-- Another collectible: the naturals are a linear order.\ninstance : linear_order mynat := by structure_helper\nend mynat -- hide\n", "height": 16, "editorText": "sorry", "lineOffset": 13, "name": "le_total", "statement": "(a b : mynat) : a \u2264 b \u2228 b \u2264 a"}, {"type": "lean", "content": "474", "hidden": false}, {"type": "lean", "content": "475", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "476", "hidden": true}, {"type": "lean", "content": "477", "hidden": true}, {"type": "text", "content": "478"}, {"type": "lemma", "text": "479", "lean": "lemma le_succ_self (a : mynat) : a \u2264 succ a :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 20, "textBefore": "import game.world10.level9 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\n## Level 10: `le_succ_self`\n\nCan you find the two-line proof?\n-/\n\n/- Lemma\nFor all naturals $a$, $a\\le\\operatorname{succ}(a).$\n-/\nlemma le_succ_self (a : mynat) : a \u2264 succ a :=\nbegin [nat_num_game]\n", "proof": "  use 1,\n  refl,\n  \n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 4, "editorText": "sorry", "lineOffset": 16, "name": "le_succ_self", "statement": "(a : mynat) : a \u2264 succ a"}, {"type": "lean", "content": "480", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "481", "hidden": true}, {"type": "lean", "content": "482", "hidden": true}, {"type": "text", "content": "483"}, {"type": "lemma", "text": "484", "lean": "theorem add_le_add_right {a b : mynat} : a \u2264 b \u2192 \u2200 t, (a + t) \u2264 (b + t) :=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 26, "textBefore": "import game.world10.level10 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\n## Level 11: `add_le_add_right`\n\nIf you're faced with a goal of the form `forall t, ...`, then the next\nline is \"so let $t$ be arbitrary\". The way to do this in Lean is `intro t`.\n-/\n\n/- Lemma\nFor all naturals $a$ and $b$, $a\\le b$ implies that for all naturals $t$,\n$a+t\\le b+t$.\n-/\ntheorem add_le_add_right {a b : mynat} : a \u2264 b \u2192 \u2200 t, (a + t) \u2264 (b + t) :=\nbegin [nat_num_game]\n", "proof": "  intro h,\n  cases h with c hc,\n  intro t,\n  use c,\n  rw hc,\n  ring,\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 8, "editorText": "sorry", "lineOffset": 18, "name": "add_le_add_right", "statement": "{a b : mynat} : a \u2264 b \u2192 \u2200 t, (a + t) \u2264 (b + t)"}, {"type": "lean", "content": "485", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "486", "hidden": true}, {"type": "lean", "content": "487", "hidden": true}, {"type": "text", "content": "488"}, {"type": "lemma", "text": "489", "lean": "theorem le_of_succ_le_succ (a b : mynat) : succ a \u2264 succ b \u2192 a \u2264 b :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 22, "textBefore": "import game.world10.level11 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\n## Level 12: `le_of_succ_le_succ`\n\n-/\n\n/- Lemma\nFor all naturals $a$ and $b$,\n$\\operatorname{succ}(a)\\le\\operatorname{succ}(b)\\implies a\\le b.$\n-/\ntheorem le_of_succ_le_succ (a b : mynat) : succ a \u2264 succ b \u2192 a \u2264 b :=\nbegin [nat_num_game]\n", "proof": "  intro h,\n  cases h with c hc,\n  use c,\n  apply succ_inj,\n  rw hc,\n  exact succ_add a c,", "proof_hint": "sorry", "textAfter": "\nend\n  \nend mynat -- hide\n", "height": 6, "editorText": "sorry", "lineOffset": 16, "name": "le_of_succ_le_succ", "statement": "(a b : mynat) : succ a \u2264 succ b \u2192 a \u2264 b"}, {"type": "lean", "content": "490", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "491", "hidden": true}, {"type": "lean", "content": "492", "hidden": true}, {"type": "text", "content": "493"}, {"type": "lemma", "text": "494", "lean": "theorem not_succ_le_self (a : mynat) : \u00ac (succ a \u2264 a) :=\n", "sideBar": true, "firstProofLineNumber": 31, "lastProofLineNumber": 45, "textBefore": "import game.world10.level12 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\n## Level 13: `not_succ_le_self`\n\nTurns out that `\u00ac P` is *by definition* `P \u2192 false`, so you can just\nstart this one with `intro h` if you like. \n\n## Pro tip:\n\n```\n  conv begin\n    to_lhs,\n    rw hc,\n  end,\n```\n\nis an incantation which rewrites `hc` only on the left hand side of the goal.\nLook carefully at the commas. You don't need to use `conv` to solve this,\nbut it's a helpful trick when `rw` is rewriting too much.\n-/\n\n/- Lemma\nFor all naturals $a$, $\\operatorname{succ}(a)$ is not at most $a$.\n-/\ntheorem not_succ_le_self (a : mynat) : \u00ac (succ a \u2264 a) :=\nbegin [nat_num_game]\n", "proof": "  intro h,\n  cases h with c h,\n  induction a with d hd,\n  { rw succ_add at h,\n    exact zero_ne_succ _ h,\n  },\n  { rw succ_add at h,\n    apply hd,\n    apply succ_inj,\n    exact h,\n  }\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n\n-- thanks to Filip Szczepa\u0144ski for this proof (nicer than the original; I was doing -- hide\n-- induction a before cases h) -- hide", "height": 15, "editorText": "sorry", "lineOffset": 30, "name": "not_succ_le_self", "statement": "(a : mynat) : \u00ac (succ a \u2264 a)"}, {"type": "lean", "content": "495", "hidden": true}, {"type": "lean", "content": "496", "hidden": true}, {"type": "lean", "content": "497", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "498", "hidden": true}, {"type": "lean", "content": "499", "hidden": true}, {"type": "text", "content": "500"}, {"type": "lemma", "text": "501", "lean": "theorem add_le_add_left {a b : mynat} (h : a \u2264 b) (t : mynat) :\n  t + a \u2264 t + b :=\n", "sideBar": true, "firstProofLineNumber": 23, "lastProofLineNumber": 28, "textBefore": "import game.world10.level13 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\n## Level 14: `add_le_add_left`\n\nI know these are easy and we've done several already, but this is one\nof the axioms for an ordered commutative monoid! The nature of formalising\nis that we should formalise all \"obvious\" lemmas, and then when we're\nactually using $\\le$ in real life, everything will be there. Note also,\nof course, that all of these lemmas are already formalised in Lean's\nmaths library already, for Lean's inbuilt natural numbers. \n-/\n\n/- Lemma\nIf $a\\le b$ then for all $t$, $t+a\\le t+b$. \n-/\ntheorem add_le_add_left {a b : mynat} (h : a \u2264 b) (t : mynat) :\n  t + a \u2264 t + b :=\nbegin [nat_num_game]\n", "proof": "  cases h with c hc,\n  use c,\n  rw hc,\n  ring,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n\nend mynat -- hide\n", "height": 6, "editorText": "sorry", "lineOffset": 22, "name": "add_le_add_left", "statement": "{a b : mynat} (h : a \u2264 b) (t : mynat) :\n  t + a \u2264 t + b"}, {"type": "lean", "content": "502", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "503", "hidden": false}, {"type": "lean", "content": "504", "hidden": true}, {"type": "lean", "content": "505", "hidden": true}, {"type": "text", "content": "506"}, {"type": "lemma", "text": "507", "lean": "lemma lt_aux_one (a b : mynat) : a \u2264 b \u2227 \u00ac (b \u2264 a) \u2192 succ a \u2264 b :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 44, "textBefore": "--import mynat.lt -- definition of <\nimport game.world10.level14 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\n## Level 15: introducing `<`\n\nTo get the remaining collectibles in this world, we need to\ngive a definition of `<`. By default, the definition of `a < b`\nin Lean, once `\u2264` is defined, is this:\n\n`a < b := a \u2264 b \u2227 \u00ac (b \u2264 a)`\n\n. But a much more usable definition would be this:\n\n`a < b := succ(a) \u2264 b`\n\n. Let's prove that these two definitions are the same\n-/\n\n/- Lemma : \nFor all naturals $a$ and $b$,\n$$a\\le b\\land\\lnot(b\\le a)\\implies\\operatorname{succ}(a)\\le b.$$\n-/\nlemma lt_aux_one (a b : mynat) : a \u2264 b \u2227 \u00ac (b \u2264 a) \u2192 succ a \u2264 b :=\nbegin [nat_num_game]\n", "proof": "  intro h,\n  cases h with h1 h2,\n  cases h1 with c hc,\n  cases c with d,\n    exfalso,\n    rw add_zero at hc,\n    apply h2,\n    rw hc,\n    refl,\n  use d,\n  rw hc,\n  rw add_succ,\n  rw succ_add,\n  refl,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend mynat -- hide\n", "height": 16, "editorText": "sorry", "lineOffset": 28, "name": "lt_aux_one", "statement": "(a b : mynat) : a \u2264 b \u2227 \u00ac (b \u2264 a) \u2192 succ a \u2264 b"}, {"type": "lean", "content": "508", "hidden": true}]}, {"name": "", "problemIndex": 3, "objects": [{"type": "lean", "content": "509", "hidden": true}, {"type": "lean", "content": "510", "hidden": true}, {"type": "text", "content": "511"}, {"type": "lemma", "text": "512", "lean": "lemma lt_aux_two (a b : mynat) : succ a \u2264 b \u2192 a \u2264 b \u2227 \u00ac (b \u2264 a) :=\n", "sideBar": true, "firstProofLineNumber": 21, "lastProofLineNumber": 35, "textBefore": "import game.world10.level15 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\n## Level 16: equivalence of two definitions of `<`\n\nNow let's go the other way. \n-/\n\n/- Lemma : \nFor all naturals $a$ and $b$,\n$$\n\\operatorname{succ}(a)\\le b\n\\implies\na\\le b\\land\\lnot(b\\le a).$$\n-/\nlemma lt_aux_two (a b : mynat) : succ a \u2264 b \u2192 a \u2264 b \u2227 \u00ac (b \u2264 a) :=\nbegin [nat_num_game]\n", "proof": "  intro h,\n  split,\n  { apply le_trans a (succ a) b,\n    exact le_succ_self a,\n    exact h,\n  },\n  intro nh,\n  apply ne_succ_self a,\n  apply le_antisymm a (succ a),\n  exact le_succ_self a,\n  exact le_trans (succ a) b a h nh,\n\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/-\nNow for the payoff.\n-/\nend mynat -- hide\n", "height": 15, "editorText": "sorry", "lineOffset": 20, "name": "lt_aux_two", "statement": "(a b : mynat) : succ a \u2264 b \u2192 a \u2264 b \u2227 \u00ac (b \u2264 a)"}, {"type": "text", "content": "513"}, {"type": "lean", "content": "514", "hidden": true}]}, {"name": "", "problemIndex": 4, "objects": [{"type": "lean", "content": "515", "hidden": true}, {"type": "lean", "content": "516", "hidden": true}, {"type": "text", "content": "517"}, {"type": "lean", "content": "518", "hidden": false}, {"type": "lemma", "text": "519", "lean": "lemma lt_iff_succ_le (a b : mynat) : a < b \u2194 succ a \u2264 b :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 30, "textBefore": "import game.world10.level16 -- hide\nnamespace mynat -- hide\n/- \n\n# Inequality world. \n\n## Level 17: definition of `<`\n\nOK so we are going to *define* `a < b` by `a \u2264 b \u2227 \u00ac (b \u2264 a)`,\nand given `lt_aux_one a b` and `lt_aux_two a b` it should now just\nbe a few lines to prove `a < b \u2194 succ(a) \u2264 b`. \n\n-/\n\ndefinition lt (a b : mynat) := a \u2264 b \u2227 \u00ac (b \u2264 a)\n\n-- incantation so that we can use `<` notation: \ninstance : has_lt mynat := \u27e8lt\u27e9\n\n/- Lemma : \nFor all naturals $a$ and $b$,\n$$a<b\\iff\\operatorname{succ}(a)\\le b.$$\n-/\nlemma lt_iff_succ_le (a b : mynat) : a < b \u2194 succ a \u2264 b :=\nbegin [nat_num_game]\n", "proof": "  split,\n    exact lt_aux_one a b,\n  exact lt_aux_two a b,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n/-\nFor now -- that's it. In the next version of the natural number game we will go on and make\nthe natural numbers into an `ordered_cancel_comm_monoid`, which is the most\nexotic of all the structures defined on the natural numbers in Lean 3.4.2.\n\nInterested in playing levels involving other kinds of mathematics?\nLook <a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/WHATS_NEXT.md\"\n  target=\"blank\">here</a> for more ideas about what to do next.\n\nInterested in learning more? Join us on the\n<a href=\"https://leanprover.zulipchat.com/\" target=\"blank\">Zulip Lean chat</a>\nand ask questions in the `#new members` stream. Real names preferred. Be nice.\n-/\n\nend mynat -- hide\n", "height": 5, "editorText": "sorry", "lineOffset": 25, "name": "lt_iff_succ_le", "statement": "(a b : mynat) : a < b \u2194 succ a \u2264 b"}, {"type": "text", "content": "520"}, {"type": "lean", "content": "521", "hidden": true}]}], "parents": [8]}], "texts": [["Natural number game", "# The Natural Number Game, version 1.3.3\n\n## By Kevin Buzzard and Mohammad Pedramfar. \n\n# What is this game?\n\nWelcome to the natural number game -- a part-book part-game which shows the power of induction.\nBlue nodes on the graph are ones that you are ready to enter. Grey nodes you should stay away\nfrom -- a grey node turns blue when *all* nodes above it are complete. Green nodes are completed.\n(Actually you can try any level at any time, but you might not know enough to complete it if it's grey).\n\nIn this game, you get own version of the natural numbers, called `mynat`, in an interactive\ntheorem prover called Lean. Your version of the natural numbers satisfies something called\nthe principle of mathematical induction, and a couple of other things too (Peano's axioms).\nUnfortunately, nobody has proved any theorems about these\nnatural numbers yet! For example, addition will be defined for you,\nbut nobody has proved that `x + y = y + x` yet. This is your job. You're going to\nprove mathematical theorems using the Lean theorem prover. In other words, you're going to solve\nlevels in a computer game.\n\nYou're going to prove these theorems using *tactics*. The introductory world, Tutorial World,\nwill take you through some of these tactics. During your proofs, your \"goal\" (i.e. what you're\nsupposed to be proving) will be displayed with  a `\u22a2` symbol in front of it. If the top\nright hand box reports \"Theorem Proved!\", you have closed all the goals in the level\nand can move on to the next level in the world you're in. When you've finished a world,\nhit \"main menu\" in the top left to get back here.\n\nFor more info, see the <a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/FAQ.html\" target=\"blank\">FAQ</a>.\n\n# What's new in v1.3?\n\nThe game now saves your progress! Thanks to everyone who asked for it,\nand to Mohammad for making it happen :-)\n\nCute little clipboard to copy your solutions.\n\n# Thanks\n\nSpecial thanks to Rob Lewis for tactic hackery, Bryan Gin-Ge Chen for\njavascript hackery, Patrick Massot for his\n<a href=\"https://github.com/leanprover-community/format_lean\" target=\"blank\">Lean to html formatter</a>,\nSian Carey for Power World,\nand, last but not least, all the people who fed back comments, including\nthe 2019-20 Imperial College 1st year maths beta tester students, Marie-Am\u00e9lie Lawn,\nToby Gee, Joseph Myers, and all the people who have been in touch\nvia the <a href=\"https://leanprover.zulipchat.com/\" target=\"blank\">Lean Zulip chat</a>\n or the <a href=\"https://xenaproject.wordpress.com/\" target=\"blank\">Xena Project blog</a>\n or via <a href=\"https://twitter.com/XenaProject\" target=\"blank\">Twitter</a>.\nThe natural number game is brought to you by the Xena project, a project based at Imperial College London\nwhose aim is to get mathematics undergraduates using computer theorem provers.\nLean is a computer theorem prover being developed at Microsoft Research.\n\nProve a theorem. Write a function. <a href=\"https://twitter.com/XenaProject\" target=\"blank\">@XenaProject</a>.\n", "Tutorial world", "import mynat.definition -- imports the natural numbers {0,1,2,3,4,...}.\nimport mynat.add -- imports definition of addition on the natural numbers.\nimport mynat.mul -- imports definition of multiplication on the natural numbers.\n", "namespace mynat -- hide\n", "# Tutorial World\n\n## Level 1: the `refl` tactic.\n\nLet us start by learning some tactics! Let's start with the `refl` tactic. `refl` stands for \"reflexivity\", which is a fancy\nway of saying that it will prove any goal of the form `A = A`. It doesn't matter how\ncomplicated `A` is, all that matters is that the left hand side is *exactly equal* to the\nright hand side (a computer scientist would say \"definitionally equal\"). I really mean\n\"press the same buttons on your computer in the same order\" equal.\nFor example, `x * y + z = x * y + z` can be proved by `refl`, but `x + y = y + x` cannot.\n\nEach level in this game involves proving a theorem or a lemma (a lemma is just a baby theorem).\nThe goal of the theorem will be a mathematical statement with a `\u22a2` just before it.\nWe will use tactics to manipulate and ultimately close (i.e. prove) these goals.\n\nLet's see `refl` in action! At the bottom of the text in this box, there's a lemma,\nwhich says that if $x$, $y$ and $z$ are natural numbers then $xy + z = xy + z$.\nLocate this lemma (if you can't see the lemma and these instructions at the same time, make this box wider\nby dragging the sides). Let's supply the proof. Click on the word `sorry` and then delete it.\nWhen the system finishes being busy, you'll be able to see your goal -- the objective\nof this level -- in the box on the top right. [NB if your system never finishes being busy, then\nyour computer is not running the javascript Lean which powers everything behind the scenes. \nTry Chrome? Try not using private browsing?] \n\nRemember that the goal is\nthe thing with the weird `\u22a2` thing just before it. The goal in this case is `x * y + z = x * y + z`,\nwhere `x`, `y` and `z` are some of your very own natural numbers.\nThat's a pretty easy goal to prove -- you can just prove it with the `refl` tactic.\nWhere it used to say `sorry`, write\n\n`refl,`\n\n**and don't forget the comma**. Then hit enter to go onto the next line.\nIf all is well, Lean should tell you \"Proof complete!\" in the top right box, and there\nshould be no errors in the bottom right box. You just did the first\nlevel of the tutorial! And you also learnt how to avoid by *far* the most\ncommon mistake that beginner users make -- **every line must end with a comma**.\nIf things go weird and you don't understand why the top right box is empty,\ncheck for missing commas. Also check if you've spelt `refl` correctly: it's REFL\nfor \"reflexivity\"!\n\nFor each level, the idea is to get Lean into this state: with the top right\nbox saying \"Proof complete!\" and the bottom right box empty (i.e. with no errors in).\n\nIf you want to be reminded about the `refl` tactic, you can click on the \"Tactics\" drop\ndown menu on the left. Resize the window if it's too small! \n\nNow click on \"next level\" in the top right of your browser to go onto the second level of\ntutorial world, where we'll learn about the `rw` tactic.\n", "For all natural numbers $x$, $y$ and $z$, we have $xy + z = xy + z$.\n", "\n## Summary\n\n`refl` proves goals of the form `X = X`.\n\n## Details\n\nThe `refl` tactic will close any goal of the form `A = B`\nwhere `A` and `B` are *exactly the same thing*.\n\n### Example:\nIf it looks like this in the top right hand box:\n```\na b c d : mynat\n\u22a2 (a + b) * (c + d) = (a + b) * (c + d)\n```\n\nthen\n\n`refl,`\n\nwill close the goal and solve the level. Don't forget the comma.\n\n", "end mynat -- hide \n", "import mynat.mul -- hide\n", "namespace mynat -- hide\n", "# Tutorial world\n\n## level 2: The rewrite (`rw`) tactic.\n\nThe rewrite tactic is the way to \"substitute in\" the value\nof a variable. In general, if you have a hypothesis of the form `A = B`, and your\ngoal mentions the left hand side `A` somewhere, then\nthe `rewrite` tactic will replace the `A` in your goal with a `B`.\nBelow is a theorem which cannot be\nproved using `refl` -- you need a rewrite first.\n\nDelete the sorry and take a look in the top right box at what we have.\nThe variables $x$ and $y$ are natural numbers, and we have\na proof `h` that $y = x + 7$. Our goal\nis to prove that $2y=2(x+7)$. This goal is obvious -- we just\nsubstitute in $y = x+7$ and we're done. In Lean, we do\nthis substitution using the `rw` tactic. So start your proof with \n\n`rw h,`\n\nand then hit enter. **Don't forget the comma.**\nDid you see what happened to the goal? The goal doesn't close,\nbut it *changes* from `\u22a2 2 * y = 2 * (x + 7)` to `\u22a2 2 * (x + 7) = 2 * (x + 7)`.\nWe can just close this goal with\n\n`refl,`\n\nby writing it on the line after `rw h,`. Don't forget the comma, hit\nenter, and enjoy seeing the \"Proof complete!\" message in the\ntop right window. The other reason you'll know you're\ndone is that the bottom right window (the error window)\nbecomes empty. When you've finished reading the comments below\nthe proof, click \"Next Level\" in the top right to proceed to the next\nlevel in this world.\n\n", "If $x$ and $y$ are natural numbers, \nand $y=x+7$, then $2y=2(x+7)$. \n", "\n## Summary\n\nIf `h` is a proof of `X = Y`, then `rw h,` will change\nall `X`s in the goal to `Y`s. Variants: `rw \u2190 h` (changes\n`Y` to `X`) and\n`rw h at h2` (changes `X` to `Y` in hypothesis `h2` instead\nof the goal).\n\n## Details\n\nThe `rw` tactic is a way to do \"substituting in\". There\nare two distinct situations where use this tactics.\n\n1) If `h : A = B` is a hypothesis (i.e., a proof of `A = B`)\nin your local context (the box in the top right)\nand if your goal contains one or more `A`s, then `rw h`\nwill change them all to `B`'s. \n\n2) The `rw` tactic will also work with proofs of theorems\nwhich are equalities (look for them in the drop down\nmenu on the left, within Theorem Statements).\nFor example, in world 1 level 4\nwe learn about `add_zero x : x + 0 = x`, and `rw add_zero`\nwill change `x + 0` into `x` in your goal (or fail with\nan error if Lean cannot find `x + 0` in the goal).\n\nImportant note: if `h` is not a proof of the form `A = B`\nor `A \u2194 B` (for example if `h` is a function, an implication,\nor perhaps even a proposition itself rather than its proof),\nthen `rw` is not the tactic you want to use. For example,\n`rw (P = Q)` is never correct: `P = Q` is the true-false\nstatement itself, not the proof.\nIf `h : P = Q` is its proof, then `rw h` will work.\n\nPro tip 1: If `h : A = B` and you want to change\n`B`s to `A`s instead, try `rw \u2190h` (get the arrow with `\\l` and\nnote that this is a small letter L, not a number 1).\n\n### Example:\nIf it looks like this in the top right hand box:\n```\nx y : mynat\nh : x = y + y\n\u22a2 succ (x + 0) = succ (y + y)\n```\n\nthen\n\n`rw add_zero,`\n\nwill change the goal into `\u22a2 succ x = succ (y + y)`, and then\n\n`rw h,`\n\nwill change the goal into `\u22a2 succ (y + y) = succ (y + y)`, which\ncan be solved with `refl,`.\n\n### Example: \nYou can use `rw` to change a hypothesis as well. \nFor example, if your local context looks like this:\n```\nx y : mynat\nh1 : x = y + 3\nh2 : 2 * y = x\n\u22a2 y = 3\n```\nthen `rw h1 at h2` will turn `h2` into `h2 : 2 * y = y + 3`.\n", "\n## Exploring your proof.\n\nClick on `refl,` and then use the arrow keys to move\nyour cursor around the proof. Go up and down and note that\nthe goal changes -- indeed you can inspect Lean's \"state\" at each\nline of the proof (the hypotheses, and the goal).\nTry to figure out the exact place where the goal changes.\nThe comma tells Lean \"I've finished writing this tactic now,\nplease process it.\" Lean ignores newlines, but pays great\nattention to commas.\n\n## The tactic index\n\nThe documentation for `rw` just appeared in the list of tactics\nin the box on the left. Play around with the menus on the left\nand see what is there currently. More information will appear as you progress.\n\n## Bewildered?\n\nDoesn't work? Weird error that won't go away? You can check out\nthe \n<a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/SOLUTIONS.md\"\n  target=\"blank\">solutions</a> (github.com, opens in new window).\n  Solutions to every level are here.\n", "end mynat -- hide", "We just restarted Lean behind the scenes,\nso let's re-import the natural numbers, but this time without\naddition and multiplication.\n", "import mynat.definition -- import Peano's definition of the natural numbers {0,1,2,3,4,...}\n", "namespace mynat -- hide\n", "\n# Tutorial world\n\n## Level 3: Peano's axioms.\n\nThe import above gives us the type `mynat` of natural numbers. But it\nalso gives us some other things, which we'll take a look at now:\n\n  * a term `0 : mynat`, interpreted as the number zero.\n  * a function `succ : mynat \u2192 mynat`, with `succ n` interpreted as \"the number after $n$\".\n  * The principle of mathematical induction.\n\nThese axioms are essentially the axioms isolated by Peano which uniquely characterise\nthe natural numbers (we also need recursion, but we can ignore it for now).\nThe first axiom says that $0$ is a natural number. The second says that there\nis a `succ` function which eats a number and spits out the number after it,\nso $\\operatorname{succ}(0)=1$, $\\operatorname{succ}(1)=2$ and so on.\n\nPeano's last axiom is the principle of mathematical induction. This is a deeper\nfact. It says that if we have infinitely many true/false statements $P(0)$, $P(1)$,\n$P(2)$ and so on, and if $P(0)$ is true, and if for every natural number $d$\nwe know that $P(d)$ implies $P(\\operatorname{succ}(d))$, then $P(n)$ must be true for every\nnatural number $n$. It's like saying that if you have a long line of dominoes, and if\nyou knock the first one down, and if you know that if a domino falls down then the one\nafter it will fall down too, then you can deduce that all the dominos will fall down.\nOne can also think of it as saying that every natural number\ncan be built by starting at `0` and then applying `succ` a finite number of times.\n\nPeano's insights were firstly that these axioms completely characterise\nthe natural numbers, and secondly that these axioms alone can be used to build\na whole bunch of other structure on the natural numbers, for example\naddition, multiplication and so on.\n\nThis game is all about seeing how far these axioms of Peano can take us.\n\nLet's practice our use of the `rw` tactic in the following example.\nOur hypothesis `h` is a proof that `succ(a) = b` and we want to prove that\n`succ(succ(a))=succ(b)`. In words, we're going to prove that if\n`b` is the number after `a` then `succ(b)` is the number after `succ(a)`. \nNow here's a tricky question. If our goal is `\u22a2 succ (succ a) = succ b`,\nand our hypothesis is `h : succ a = b`, then what will the goal change\nto when we type\n\n`rw h,`\n\nand hit enter whilst not forgetting the comma? Remember that `rw h` will\nlook for the *left* hand side of `h` in the goal, and will replace it with\nthe *right* hand side. Try and figure out how the goal will change, and\nthen try it.\n\nThe answer: Lean changed `succ a` into `b`, so the goal became `succ b = succ b`.\nThat goal is of the form `X = X`, so you can prove this new goal with\n\n`refl,`\n\non the line after `rw h,`. Don't forget the commas!\n\n**Important note** : the tactic `rw` expects\na proof afterwards (e.g. `rw h1`). But `refl` is just `refl`.\nNote also that the system sometimes drops brackets when they're not\nnecessary, and `succ b` just means `succ(b)`. \n\nYou may be wondering whether we could have just substituted in the definition of `b`\nand proved the goal that way. To do that, we would want to replace the right hand\nside of `h` with the left hand side. You do this in Lean by writing `rw \u2190 h`. You get the\nleft-arrow by typing `\\l` and then a space; note that this is a small letter L,\nnot a number 1. You can just edit your proof and try it. \n\nYou may also be wondering why we keep writing `succ(b)` instead of `b+1`. This\nis because we haven't defined addition yet! On the next level, the final level\nof Tutorial World, we will introduce addition, and then\nwe'll be ready to enter Addition World.\n", "If $\\operatorname{succ}(a) = b$, then\n$$\\operatorname{succ}(\\operatorname{succ}(a)) = \\operatorname{succ}(b).$$\n", "end mynat -- hide\n", "import mynat.add -- definition of addition\n", "namespace mynat -- hide\n", "a + 0 = a\n", "a + succ(b) = succ(a + b)\n", "# Tutorial world\n\n## Level 4: addition\n\nWe have a new import -- the definition of addition.\n\nPeano defined addition `a + b` by induction on `b`, or,\nmore precisely, by *recursion* on `b`. He first explained how to add 0 to a number:\nthis is the base case.\n\n* `add_zero (a : mynat) : a + 0 = a`\n\nWe will call this theorem `add_zero`. More precisely, `add_zero` is the name\nof the *proof* of the theorem. **Note the name of this proof**.\nMathematicians sometimes call it \"Lemma 2.1\" or \"Hypothesis P6\" or something. But\ncomputer scientists call it `add_zero` because it tells you\nwhat the answer to \"$x$ add zero\" is. It's a *much* better name than \"Lemma 2.1\".\nEven better, we can use the rewrite tactic with `add_zero`.\nIf you ever see `x + 0` in your goal, `rw add_zero` should simplify it to `x`.\nThis is because `add_zero` is a proof that `x + 0 = x` (more precisely,\n`add_zero x` is a proof that `x + 0 = x` but Lean can figure out the `x` from the context).\n\nNow here's the inductive step. If you know how to add `d` to `a`, then\nPeano tells you how to add `succ(d)` to `a`. It looks like this:\n\n* `add_succ (a d : mynat) : a + succ(d) = succ (a + d)`\n\nWhat's going on here is that we assume `a + d` is already\ndefined, and we define `a + succ(d)` to be the number after it.\n**Note the name of this proof too** -- `add_succ` tells you\nhow to add a successor to something. If you ever see `... + succ ...`\nin your goal, you should be able to use `rw add_succ,` to make\nprogress. Here is a simple example where we shall see both. Let's prove\nthat $x$ add the number after $0$ is the number after $x$.\n\nDelete `sorry` (don't forget you can widen this box if you can't see the sorry).\nObserve that the goal mentions `... + succ ...`. So type\n\n`rw add_succ,`\n\nand hit enter; see the goal change. **Don't forget the commma**.\nDo you see that the goal now mentions ` ... + 0 ...`? So type\n\n`rw add_zero,`\n\nand then observe that you can close the goal with\n\n`refl,`\n\nand you're done. You have finished tutorial world! There are important things\nwritten below the lemma, including what to do next.\n\n", "For all natural numbers $a$, we have\n$$a + \\operatorname{succ}(0) = \\operatorname{succ}(a).$$\n", "end mynat -- hide\n", "## Examining proofs.\n\nYou might want to review this proof now; at\nthree lines long it is our current record. Click on a line in the proof\nand use the L/R arrow keys to put your cursor as far left as it will go.\nThen use the U/D arrow keys to move your cursor\nup and down from line to line, and you can see what\nLean is thinking on each line of the proof.\n\n## No problems?\n\nWhen you're happy, let's move onto Addition World, and\nlearn about proof by induction. Go back to the main menu and select addition world.\n\n## Problems?\n\nQuestion: why has the top right hand box gone blank?\n\nAnswer: Maybe you tried a tactic which didn't work. Or maybe you're\nin the middle of typing a tactic. Try deleting up to the last\ncomma, *or adding a comma at the end of your code*. Look at the\nerror message. What line is the first error on? Perhaps\nLean thinks you're in the middle of writing a tactic command that you\nthink you finished. If Lean is still attempting to process a tactic\ncommand it won't display anything. You can get it to stop processing by\nadding a comma. \n\nIf the worst comes to the worst, just delete what you wrote. Most people\nwith problems have written random stuff in the proof box. The only thing\nyou're supposed to be writing is lines like\n\n`rw add_zero,`\n`rw h,`\n`refl,`\n\nOne line of code with a comma at the end. Nothing else at all goes in the box.\n\nIf you cannot see what you have done wrong, you can always\n<a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/SOLUTIONS.md\"\n  target=\"blank\">take a look at the solutions</a> (github.com, opens in new window).\n", "Addition world", "import mynat.definition -- Imports the natural numbers.\nimport mynat.add -- imports addition.\n", "namespace mynat -- hide\n", "a + 0 = a\n", "a + succ(b) = succ(a + b)\n", "\n## Summary\n\nif `n : mynat` is in our assumptions, then `induction n with d hd`\nattempts to prove the goal by induction on `n`, with the inductive\nassumption in the `succ` case being `hd`.\n\n## Details\n\nIf you have a natural number `n : mynat` in your context\n(above the `\u22a2`) then `induction n with d hd` turns your\ngoal into two goals, a base case with `n = 0` and\nan inductive step where `hd` is a proof of the `n = d`\ncase and your goal is the `n = succ(d)` case.\n\n### Example:\nIf this is our local context:\n```\nn : mynat\n\u22a2 2 * n = n + n\n```\n\nthen\n\n`induction n with d hd`\n\nwill give us two goals:\n\n```\n\u22a2 2 * 0 = 0 + 0\n```\n\nand\n```\nd : mynat,\nhd : 2 * d = d + d\n\u22a2 2 * succ d = succ d + succ d\n```\n\n", "# Addition World. \n\nWelcome to Addition World. If you've done all four levels in tutorial world\nand know about `rw` and `refl`, then you're in the right place. Here's\na reminder of the things you're now equipped with which we'll need in this world.\n\n## Data:\n\n  * a type called `mynat`\n  * a term `0 : mynat`, interpreted as the number zero.\n  * a function `succ : mynat \u2192 mynat`, with `succ n` interpreted as \"the number after `n`\".\n  * Usual numerical notation 0,1,2 etc (although 2 onwards will be of no use to us until much later ;-) ).\n  * Addition (with notation `a + b`).\n\n## Theorems:\n\n  * `add_zero (a : mynat) : a + 0 = a`. Use with `rw add_zero`.\n  * `add_succ (a b : mynat) : a + succ(b) = succ(a + b)`. Use with `rw add_succ`.\n  * The principle of mathematical induction. Use with `induction` (see below)\n  \n\n## Tactics:\n\n  * `refl` :  proves goals of the form `X = X`\n  * `rw h` : if h is a proof of `A = B`, changes all A's in the goal to B's.\n  * `induction n with d hd` : we're going to learn this right now.\n\n# Important thing: \n\nThis is a *really* good time to check you understand about the box on the left with the drop down\nmenus. All the theorems and all the tactics above are documented there. You can find\nall you need to know about what theorems you have collected in Theorem statements -> Addition world.\nHave a click around and check that you can find statements of the theorems above, and explanations of\nthe tactics above. As we go through the game, these lists will grow. The box on the left\nwill prove invaluable as the number of theorems we prove gets bigger. On the other hand,\nwe only need to learn one more tactic to really start going places, so let's learn about\nthat tactic right now.\n\n## Level 1: the `induction` tactic.\n\nOK so let's see induction in action. We're going to prove\n\n  `zero_add (n : mynat) : 0 + n = n`. \n\nThat is: for all natural numbers $n$, $0+n=n$. Wait $-$ what is going on here?\nDidn't we already prove that adding zero to $n$ gave us $n$?\nNo we didn't! We proved $n + 0 = n$, and that proof was called `add_zero`. We're now\ntrying to establish `zero_add`, the proof that $0 + n = n$. But aren't these two theorems\nthe same? No they're not! It is *true* that `x + y = y + x`, but we haven't\n*proved* it yet, and in fact we will need both `add_zero` and `zero_add` in order\nto prove this. In fact `x + y = y + x` is the boss level for addition world,\nand `induction` is the only other tactic you'll need to beat it.\n\nNow `add_zero` is one of Peano's axioms, so we don't need to prove it, we already have it\n(indeed, if you've opened the Addition World theorem statements on the left, you can even see it).\nTo prove `0 + n = n` we need to use induction on $n$. While we're here,\n  note that `zero_add` is about zero add something, and `add_zero` is about something add zero.\n  The names of the proofs tell you what the theorems are. Anyway, let's prove `0 + n = n`.\n\n  Delete `sorry` and replace it with `induction n with d hd,`\nand **don't forget the comma**. Hit enter, wait for Lean to finish thinking,\nand let's see what we have.\n\nWhen Lean has finished thinking, we see that we now have *two goals*! The\ninduction tactic has generated for us a base case with `n = 0` (the goal at the top)\nand an inductive step (the goal underneath). The golden rule: **Tactics operate on the first goal** --\nthe goal at the top. So let's just worry about that top goal now, the base case `\u22a2 0 + 0 = 0`.\n\nRemember that `add_zero` (the proof we have already) is the proof of `x + 0 = x`\n(for any $x$) so we can try\n\n`rw add_zero,`\n\n. What do you think the goal will\nchange to? Remember to just keep\nfocussing on the top goal, ignore the other one for now, it's not changing\nand we're not working on it. You should be able to solve the top goal yourself\nnow with `refl`.\n\nWhen you solved this base case goal, we are now be back down\nto one goal -- the inductive step. Take a look at the\ntext below the lemma to see an explanation of this goal.\n", "For all natural numbers $n$, we have\n$$0 + n = n.$$\n", "We're in the successor case, and your top right box should look\nsomething like this:\n\n```\ncase mynat.succ\nd : mynat,\nhd : 0 + d = d\n\u22a2 0 + succ d = succ d\n```\n\n*Important:* make sure that you only have one goal at this point. You\nshould have proved `0 + 0 = 0` by now. Tactics only operate on the top goal.\n\nThe first line just reminds us we're doing the inductive step.\nWe have a fixed natural number `d`, and the inductive hypothesis `hd : 0 + d = d`\nsaying that we have a proof of `0 + d = d`.  \nOur goal is to prove `0 + succ d = succ d`. In words, we're showing that\nif the lemma is true for `d`, then it's also true for the number after `d`.\nThat's the inductive step. Once we've proved this inductive step, we will have proved\n`zero_add` by the principle of mathematical induction.\n\nTo prove our goal, we need to use `add_succ`. We know that `add_succ 0 d`\nis the result that `0 + succ d = succ (0 + d)`, so the first thing\nwe need to do is to replace the left hand side `0 + succ d` of our\ngoal with the right hand side. We do this with the `rw` command. You can write\n\n`rw add_succ,`\n\n(or even `rw add_succ 0 d,` if you want to give Lean all the inputs instead of making it\nfigure them out itself). Don't forget the comma though. Hit enter. The goal should change to\n\n`\u22a2 succ (0 + d) = succ d`\n\nNow remember our inductive hypothesis `hd : 0 + d = d`. We need\nto rewrite this too! Type \n\n`rw hd,`\n\n(don't forget the comma). The goal will now change to\n\n`\u22a2 succ d = succ d`\n\nThis goal can be solved with the `refl` tactic. After you apply it,\nLean will inform you that there are no goals left. You are done!\n\n## Now venture off on your own.\n\nThose three tactics -- \n\n* `induction n with d hd,` \n* `rw h,`\n* `refl,`\n\nwill get you quite a long way through this game. Using only these tactics\nyou can beat Addition World level 4 (the boss level of Addition World),\nall of Multiplication World including the boss level `a * b = b * a`,\nand even all of Power World including the fiendish final boss. This route will\ngive you a good grounding in these three basic tactics; after that, if you\nare still interested, there are other worlds to master, where you can learn\nmore tactics.\n\nBut we're getting ahead of ourselves, you still have to beat the rest of Addition World. \nWe're going to stop explaining stuff carefully now. If you get stuck or want\nto know more about Lean (e.g. how to do much harder maths in Lean),\nask in `#new members` at\n<a href=\"https://leanprover.zulipchat.com\" target=\"blank\">the Lean chat</a>\n(login required, real name preferred). Kevin or Mohammad or one of the other\npeople there might be able to help.\n\nGood luck! Click on \"next level\" to solve some levels on your own.\n\n", "end mynat -- hide\n", "import mynat.definition -- hide\n", "import mynat.add -- hide\n", "import game.world2.level1 -- hide\n", "namespace mynat -- hide\n", "# Addition world\n\nDon't forget to use the drop down boxes on the left to see your tactics and\nwhat you have proved so far.\n\n## Level 2: `add_assoc` -- associativity of addition.\n\nIt's well-known that (1 + 2) + 3 = 1 + (2 + 3) -- if we have three numbers\nto add up, it doesn't matter which of the additions we do first. This fact\nis called *associativity of addition* by mathematicians, and it is *not*\nobvious. For example, subtraction really is not associative: $(6 - 2) - 1$\nis really not equal to $6 - (2 - 1)$. We are going to have to prove\nthat addition, as defined the way we've defined it, is associative. \n \nSee if you can prove associativity of addition. Hint: because addition was defined\nby recursion on the right-most variable, use induction on the right-most\nvariable (try other variables at your peril!). Note that when Lean writes `a + b + c`,\nit means `(a + b) + c`. If it wants to talk about `a + (b + c)` it will put the brackets\nin explictly.\n\nReminder: you are done when you see \"Proof complete!\" in the top right, and an empty\nbox (no errors) in the bottom right. You can move between levels and worlds (i.e. you\ncan go back and review old stuff) without losing anything.\n\nOnce you're done with associativity (sub-boss), we can move on to commutativity (boss).\n", "On the set of natural numbers, addition is associative.\nIn other words, for all natural numbers $a, b$ and $c$, we have\n$$ (a + b) + c = a + (b + c). $$\n", "end mynat -- hide \n", "import mynat.definition -- hide\n", "import mynat.add -- hide\n", "import game.world2.level2 -- hide\n", "namespace mynat -- hide\n", "# Addition World\n\n## Level 3: `succ_add`\n\nOh no! On the way to `add_comm`, a wild `succ_add` appears. `succ_add`\nis the proof that `succ(a) + b = succ(a + b)` for `a` and `b` in your\nnatural number type. We need to prove this now, because we will need\nto use this result in our proof that `a + b = b + a` in the next level.\n\nNB: think about why computer scientists called this result `succ_add` .\nThere is a logic to all the names.\n\nNote that if you want to be more precise about exactly where you want\nto rewrite something like `add_succ` (the proof you already have),\nyou can do things like `rw add_succ (succ a)` or\n`rw add_succ (succ a) d`, telling Lean explicitly what to use for\nthe input variables for the function `add_succ`. Indeed, `add_succ`\nis a function -- it takes as input two variables `a` and `b` and outputs a proof\nthat `a + succ(b) = succ(a + b)`. The tactic `rw add_succ` just says to Lean \"guess\nwhat the variables are\". \n", "For all natural numbers $a, b$, we have\n$$ \\operatorname{succ}(a) + b = \\operatorname{succ}(a + b). $$\n", "end mynat -- hide \n", "import mynat.definition -- hide\n", "import mynat.add -- hide\n", "import game.world2.level3 -- hide\n", "namespace mynat -- hide\n", "# Addition World\n\n## Level 4: `add_comm` (boss level)\n\n[boss battle music]\n\nLook in Theorem statements -> Addition world to see the proofs you have.\nThese should be enough.\n", "On the set of natural numbers, addition is commutative.\nIn other words, for all natural numbers $a$ and $b$, we have\n$$ a + b = b + a. $$\n", "\nIf you got this far -- nice! You're nearly ready to make a choice:\nMultiplication World or Function World. But there are just a couple\nmore useful lemmas in Addition World which you should prove first.\nPress on to level 5.\n\n", "end mynat -- hide \n", "import mynat.definition -- hide\n", "import mynat.add -- hide\n", "import game.world2.level4 -- hide\n", "namespace mynat -- hide\n", "1 = succ(0)\n", "\n# Addition World\n\n## Level 5: `succ_eq_add_one`\n\nI've just added `one_eq_succ_zero` (a proof of `1 = succ(0)`) to your list of theorems; this is true\nby definition of $1$, but we didn't need it until now.\n\nLevels 5 and 6 are the two last levels in Addition World.\nLevel 5 involves the number $1$. When you see a $1$ in your goal,\nyou can write `rw one_eq_succ_zero` to get back\nto something which only mentions `0`. This is a good move because $0$ is easier for us to\nmanipulate than $1$ right now, because we have\nsome theorems about $0$ (`zero_add`, `add_zero`), but, other than `1 = succ(0)`,\nno theorems at all which mention $1$. Let's prove one now.\n", "For any natural number $n$, we have\n$$ \\operatorname{succ}(n) = n+1. $$\n", "end mynat -- hide\n", "import mynat.definition -- hide\n", "import mynat.add -- hide\n", "import game.world2.level5 -- hide\n", "import tactic.ring -- hide\n", "namespace mynat -- hide\n", "\n# Addition World\n\n## Level 6: `add_right_comm`\n\nLean sometimes writes `a + b + c`. What does it mean? The convention is\nthat if there are no brackets displayed in an addition formula, the brackets\nare around the left most `+` (Lean's addition is \"left associative\"). \nSo the goal in this level is `(a + b) + c = (a + c) + b`. This isn't\nquite `add_assoc` or `add_comm`, it's something you'll have to prove\nby putting these two theorems together.\n\nIf you hadn't picked up on this already, `rw add_assoc` will\nchange `(x + y) + z` to `x + (y + z)`, but to change it back\nyou will need `rw \u2190 add_assoc`. Get the left arrow by typing `\\l`\nthen the space bar (note that this is L for left, not a number 1).\nSimilarly, if `h : a = b` then `rw h` will change `a`'s to `b`'s\nand `rw \u2190 h` will change `b`'s to `a`'s.\n\nAlso, you can be (and will need to be, in this level) more precise\nabout where to rewrite theorems. `rw add_comm,` will just find the\nfirst `? + ?` it sees and swap it around. You can target more specific\nadditions like this: `rw add_comm a` will swap around\nadditions of the form `a + ?`, and `rw add_comm a b,` will only\nswap additions of the form `a + b`.\n\n## Where next?\n\nThere are thirteen more levels about addition after this one, but before\nyou can attempt them you need to learn some more tactics. So after this\nlevel you have a choice -- either move on to Multiplication World (which you can\nsolve with the tactics you know) or try Function World (and learn some new ones).\nAfter solving this level, click \"Main Menu\" in the top left to take you back\nto the overworld, and make your choice. Other things, perhaps of interest\nto some players, are mentioned below the lemma. \n", "For all natural numbers $a, b$ and $c$, we have\n$$ a + b + c = a + c + b. $$\n", "If you have got this far, then you have become very good at\nmanipulating equalities in Lean. You can also now collect\nfour collectibles (or `instance`s, as Lean calls them)\n\n```\nmynat.add_semigroup -- (after level 2)\nmynat.add_monoid -- (after level 2)\nmynat.add_comm_semigroup mynat (after level 4)\nmynat.add_comm_monoid -- (after level 4)\n```\n\nIn Multiplication World you will be able to collect such\nadvanced collectibles as `mynat.comm_semiring` and\n`mynat.distrib`, and then move on to power world and\nthe famous collectible at the end of it.\n\nOne last thing -- didn't you think that solving this level\n`add_right_comm` was boring? Check out this AI that can do it for us.\n\nFirst we have to get the `add_comm_monoid` collectible,\nwhich we do by saying the magic words which make Lean's type class inference\nsystem give it to us.\n", "instance : add_comm_monoid mynat := by structure_helper\n", "Now the `simp` AI becomes accessible (it's just an advanced\ntactic really), and can nail some really tedious-for-a-human-to-solve\ngoals. For example check out this one-line proof:\n", "example (a b c d e : mynat) :\n(((a+b)+c)+d)+e=(c+((b+e)+a))+d := begin\n  simp\nend \n", "Imagine having to do that one by hand! The AI closes the goal\nbecause it knows how to use associativity and commutativity\nsensibly in a commutative monoid.\n\nYou are now done with addition world. Go back to the main menu (top left)\nand decide whether to press on with multiplication world and power world\n(which can be solved with `rw`, `refl` and `induction`), or to go on\nto Function World where you can learn the tactics needed to prove\ngoals of the form $P\\implies Q$, thus enabling you to solve more\nadvanced addition world levels such as $a+t=b+t\\implies a=b$. Note that\nFunction World is more challenging mathematically; but if you can do Addition\nWorld you can surely do Multiplication World and Power World.\n", "end mynat -- hide\n", "\n## Summary\n\nThe `simp` tactic is a high-level tactic which tries\nto prove equalities using facts in its database (such\nas `add_assoc` and `add_comm`).\n\n## Details\n\nThe `simp` tactic does basic automation. By level 6 of\nAddition World you\nhave proved enough about addition for `simp` to be able\nto solve all equalities whose proofs involve a tedious number\nof rewrites of `add_assoc` and `add_comm`, and by\nlevel 9 of Multiplication World the same is true of `mul_assoc` and `mul_comm`.\n\n### Example:\nIf our goal is this:\n```\n\u22a2 a + b + c + d + e = c + (b + e + a) + d\n```\n\nand you have completed addition world, then you've proved\nenough about addition to solve this level with `simp`. \nNote however that you can't prove `add_assoc` with `simp`,\nbecause `add_assoc` is an ingredient to get `simp` working.\n\n### Example:\nIf our goal is this:\n```\n\u22a2 a * b * c = c * b * a\n```\nthen as long as you've completed Multiplication World, `simp` will close this\ngoal.\n", "Multiplication world", "import game.world2.level6 -- hide\n", "import mynat.mul -- import the definition of multiplication on mynat\n", "a * 0 = 0\n", "a * succ(b) = a * b + a\n", "\n# Multiplication World\n\nA new import! This import gives you the definition of multiplication on your\nnatural numbers. It is defined by recursion, just like addition.\nHere are the two new axioms:\n\n  * `mul_zero (a : mynat) : a * 0 = 0`\n  * `mul_succ (a b : mynat) : a * succ(b) = a * b + a`\n\nIn words, we define multiplication by \"induction on the second variable\",\nwith `a * 0` defined to be `0` and, if we know `a * b`, then `a` times\nthe number after `b` is defined to be `a * b + a`. \n\nYou can keep all the theorems you proved about addition, but \nfor multiplication, those two results above are you've got right now.\nI would recommend that you sort out the bar on the left. Fold up everything,\nand then unfold just Theorem Statements -> Multiplication World. This will\nremind you of your two new theorems, both of which are true by definition.\nIf you want to be reminded of the theorems you have proved about addition,\nyou can just open up the Addition World theorem statements and take a look. \nIf you don't want to keep opening and closing these menus, why not think\na bit about the logic behind the naming of the proofs? After a while you\nmight find that you can guess the name of the proof you want.\n\nAnyway, what's going on in multiplication world? Like addition, we need to go\nfor the proofs that multiplication\nis commutative and associative, but as well as that we will\nneed to prove facts about the relationship between multiplication\nand addition, for example `a * (b + c) = a * b + a * c`, so now\nthere is a lot more to do. Good luck! \n\nWe are given `mul_zero`, and the first thing to prove is `zero_mul`.\nLike `zero_add`, we of course prove it by induction.\n\n## Level 1: `zero_mul`\n", "namespace mynat -- hide\n", "For all natural numbers $m$, we have\n$$ 0 \\times m = 0. $$\n", "end mynat -- hide\n", "import game.world3.level1 -- hide\n", "import mynat.mul -- hide\n", "namespace mynat -- hide\n", "# Multiplication World\n\n## Level 2: `mul_one`\n\nRemember that you can see everything you have proved so far about multiplication in\nthe drop-down box on the left (and that this list will grow as we proceed).\n\nIn this level we'll need to use\n\n* `one_eq_succ_zero : 1 = succ(0)`\n\nwhich was mentioned back in Addition World and\nwhich will be a useful thing to rewrite right now, as we\nbegin to prove a couple of lemmas about how `1` behaves\nwith respect to multiplication.\n", "For any natural number $m$, we have\n$$ m \\times 1 = m. $$\n", "end mynat -- hide\n", "import game.world3.level2 -- hide\n", "import mynat.mul -- hide\n", "namespace mynat -- hide\n", "# Multiplication World\n\n## Level 3: `one_mul`\n\nThese proofs from addition world might be useful here:\n\n* `one_eq_succ_zero : 1 = succ(0)`\n* `succ_eq_add_one a : succ(a) = a + 1` \n\nWe just proved `mul_one`, now let's prove `one_mul`. \nThen we will have proved, in fancy terms,\nthat 1 is a \"left and right identity\"\nfor multiplication (just like we showed that\n0 is a left and right identity for addition\nwith `add_zero` and `zero_add`).\n", "For any natural number $m$, we have\n$$ 1 \\times m = m. $$\n", "end mynat -- hide\n", "import game.world3.level3 -- hide\n", "namespace mynat -- hide\n", "# Multiplication World\n\n## Level 4: `mul_add`\n\nWhere are we going? Well we want to prove `mul_comm`\nand `mul_assoc`, i.e. that `a * b = b * a` and\n`(a * b) * c = a * (b * c)`. But we *also* want to\nestablish the way multiplication interacts with addition,\ni.e. we want to prove that we can \"expand out the brackets\"\nand show `a * (b + c) = (a * b) + (a * c)`.\nThe technical term for this is \"left distributivity of\nmultiplication over addition\" (there is also right distributivity,\nwhich we'll get to later).\n\nNote the name of this proof -- `mul_add`. And note the left\nhand side -- `a * (b + c)`, a multiplication and then an addition.\nI think `mul_add` is much easier to remember than \"left_distrib\",\nan alternative name for the proof of this lemma.\n", "Multiplication is distributive over addition.\nIn other words, for all natural numbers $a$, $b$ and $t$, we have\n$$ t(a + b) = ta + tb. $$\n", "def left_distrib := mul_add -- the \"proper\" name for this lemma\n", "-- I just don't instinctively know what left_distrib means -- hide\n", "end mynat -- hide\n", "import game.world3.level4 -- hide\n", "import mynat.mul -- hide\n", "namespace mynat -- hide\n", "# Multiplication World\n\n## Level 5: `mul_assoc`\n\nWe now have enough to prove that multiplication is associative.\n\n## Random tactic hints\n\n1) Did you know you can do `repeat {rw mul_succ}`?\n\n2) Did you know you can do `rwa [hd, mul_add]`?\nI learnt that trick from Ken Lee. Ken spotted that\n`rwa` will do the rewrites and will then check to\nsee if the goal can be proved by `refl`, and if it\ncan, it will close it! [It will also close goals which\nare exactly equal to hypotheses, which will be helpful later on.]\n", "Multiplication is associative.\nIn other words, for all natural numbers $a$, $b$ and $c$, we have\n$$ (ab)c = a(bc). $$\n", "A mathematician could now remark that you have proved that the natural\nnumbers form a monoid under multiplication.\n", "def collectible_4 : monoid mynat := by structure_helper -- hide\n", "end mynat -- hide\n", "import game.world3.level5 -- hide\n", "import mynat.mul -- hide\n", "namespace mynat -- hide\n", "# Multiplication World\n\n## Level 6: `succ_mul`\n\nWe now begin our journey to `mul_comm`, the proof that `a * b = b * a`. \nWe'll get there in level 8. Until we're there, it is frustrating\nbut true that we cannot assume commutativity. We have `mul_succ`\nbut we're going to need `succ_mul` (guess what it says -- maybe you\nare getting the hang of Lean's naming conventions). \n\nRemember also that we have tools like\n\n* `add_right_comm a b c : a + b + c = a + c + b` \n\nThese things are the tools we need to slowly build up the results\nwhich we will need to do mathematics \"normally\". \nWe also now have access to Lean's `simp` tactic,\nwhich will solve any goal which just needs a bunch\nof rewrites of `add_assoc` and `add_comm`. Use if\nyou're getting lazy!\n", "For all natural numbers $a$ and $b$, we have\n$$ \\operatorname{succ}(a) \\times b = ab + b. $$\n", "end mynat -- hide\n", "import game.world3.level6 -- hide\n", "namespace mynat -- hide\n", "# Multiplication World\n\n## Level 7: `add_mul`\n\nWe proved `mul_add` already, but because we don't have commutativity yet\nwe also need to prove `add_mul`. We have a bunch of tools now, so this won't\nbe too hard. You know what -- you can do this one by induction on any of\nthe variables. Try them all! Which works best? If you can't face\ndoing all the commutativity and associativity, remember the high-powered\n`simp` tactic mentioned at the bottom of Addition World level 6,\nwhich will solve any puzzle which needs only commutativity\nand associativity. If your goal looks like `a+(b+c)=c+b+a` or something,\ndon't mess around doing it explicitly with `add_comm` and `add_assoc`,\njust try `simp`.\n", "Addition is distributive over multiplication.\nIn other words, for all natural numbers $a$, $b$ and $t$, we have\n$$ (a + b) \\times t = at + bt. $$\n", "A mathematician would now say that you have proved that the natural\nnumbers are a semiring. This sounds like a respectable result.\n", "def right_distrib := add_mul -- alternative name\ninstance : semiring mynat := by structure_helper\n", "Lean would add that you have also proved that they are a `distrib`. \nHowever this concept has no mathematical name at all -- this says something\nabout the regard with which mathematicians hold this collectible.\nThis is an artefact of the set-up of collectibles in Lean. You consider politely\ndeclining Lean's offer of a `distrib` collectible.\nYou are dreaming of the big collectible at the end of power world.\n", "instance : distrib mynat := by structure_helper -- \n", "end mynat -- hide\n", "import game.world3.level7 -- hide\n", "namespace mynat -- hide\n", "# Multiplication World\n\n## Level 8: `mul_comm`\n\nFinally, the boss level of multiplication world. But (assuming you\ndidn't cheat) you are well-prepared for it -- you have `zero_mul`\nand `mul_zero`, as well as `succ_mul` and `mul_succ`. After this\nlevel you can of course throw away one of each pair if you like,\nbut I would recommend you hold on to them, sometimes it's convenient\nto have exactly the right tools to do a job.\n", "Multiplication is commutative.\n", "You've now proved that the natural numbers are a commutative semiring!\nThat's the last collectible in Multiplication World. \n", "instance mynat.comm_semiring : comm_semiring mynat := by structure_helper\n", "But don't leave multiplication just yet -- prove `mul_left_comm`, the last\nlevel of the world, and then we can beef up the power of `simp`. \n", "end mynat -- hide\n", "import game.world3.level8 -- hide\n", "import mynat.mul -- hide\n", "namespace mynat -- hide\n", "# Multiplication World\n\n## Level 9: `mul_left_comm`\n\nYou are equipped with\n\n* `mul_assoc (a b c : mynat) : (a * b) * c = a * (b * c)`\n* `mul_comm (a b : mynat) : a * b = b * a`\n\nRe-read the docs for `rw` so you know all the tricks.\nYou can see them in the \"tactics\" drop-down menu on the left.\n", "For all natural numbers $a$ $b$ and $c$, we have\n$$a(bc)=b(ac)$$\n", "And now I whisper a magic incantation\n", "attribute [simp] mul_assoc mul_comm mul_left_comm\n", "and all of a sudden Lean can automatically do levels which are\nvery boring for a human, for example\n", "example (a b c d e : mynat) :\n(((a*b)*c)*d)*e=(c*((b*e)*a))*d :=\nbegin\n  simp,\nend \n", "If you feel like attempting Advanced Multiplication world\nyou'll have to do Function World and the Proposition Worlds first.\nThese worlds assume a certain amount of mathematical maturity\n(perhaps 1st year undergraduate level). \nYour other possibility is Power World, with the \"final boss\".\n", "end mynat -- hide\n", "Power world", "import game.world3.level9 -- hide\n", "import mynat.pow -- new import\n", "namespace mynat -- hide\n", "a ^ 0 = 1\n", "a ^ succ(b) = a ^ b * a\n", "\n# Power World\n\nA new world with seven levels. And a new import!\nThis import gives you the power to make powers of your\nnatural numbers. It is defined by recursion, just like addition and multiplication.\nHere are the two new axioms:\n\n  * `pow_zero (a : mynat) : a ^ 0 = 1`\n  * `pow_succ (a b : mynat) : a ^ succ(b) = a ^ b * a`\n\nThe power function has various relations to addition and multiplication.\nIf you have gone through levels 1--6 of addition world and levels 1--9 of\nmultiplication world, you should have no trouble with this world:\nThe usual tactics `induction`, `rw` and `refl` should see you through.\nYou might want to fiddle with the\ndrop-down menus on the left so you can see which theorems of Power World\nyou have proved at any given time. Addition and multiplication -- we\nhave a solid API for them now, i.e. if you need something about addition\nor multiplication, it's probably already in the library we have built.\nCollectibles are indication that we are proving the right things.\n\nThe levels in this world were designed by Sian Carey, a UROP student\nat Imperial College London, funded by a Mary Lister McCammon Fellowship,\nin the summer of 2019. Thanks Sian!\n\n## Level 1: `zero_pow_zero`\n", "$0 ^ 0 = 1$.\n", "end mynat -- hide\n", "import game.world4.level1 -- hide\n", "namespace mynat -- hide\n", "\n# Power World\n\n## Level 2: `zero_pow_succ`\n", "For all naturals $m$, $0 ^{succ (m)} = 0$.\n", "end mynat -- hide\n", "import game.world4.level2 -- hide\n", "namespace mynat -- hide\n", "\n# Power World\n\n## Level 3: `pow_one`\n", "For all naturals $a$, $a ^ 1 = a$.\n", "end mynat -- hide\n", "import game.world4.level3 -- hide\n", "namespace mynat -- hide\n", "\n# Power World\n\n## Level 4: `one_pow`\n", "For all naturals $m$, $1 ^ m = 1$.\n", "end mynat -- hide\n", "import game.world4.level4 -- hide\n", "namespace mynat -- hide\n", "\n# Power World\n\n## Level 5: `pow_add`\n", "For all naturals $a$, $m$, $n$, we have $a^{m + n} = a ^ m  a ^ n$.\n", "end mynat -- hide\n", "import game.world4.level5 -- hide\n", "namespace mynat -- hide\n", "\n# Power World\n\n## Level 6: `mul_pow`\n\nYou might find the tip at the end of level 9 of Multiplication World\nuseful in this one. You can go to the main menu and pop back into\nMultiplication World and take a look -- you won't lose any of your\nproofs. You'll only lose proofs if you reload the page.\n", "For all naturals $a$, $b$, $n$, we have $(ab) ^ n = a ^ nb ^ n$.\n", "end mynat -- hide\n", "import game.world4.level6 -- hide\n", "namespace mynat -- hide\n", "\n# Power World\n\n## Level 7: `pow_pow`\n", "Boss level! What will the collectible be?\n", "For all naturals $a$, $m$, $n$, we have $(a ^ m) ^ n = a ^ {mn}$.\n", "Apparently Lean can't find a collectible, even though you feel like you\njust finished power world so you must have proved *something*. What should the\ncollectible for this level be called? \n", "But what is this? It's one of those twists where there's another\nboss after the boss you thought was the final boss! Go to the next\nlevel!\n", "end mynat -- hide\n", "import game.world4.level7 -- hide\n", "-- incantation for importing ring into framework -- hide\n", "import tactic.ring -- hide\n", "meta def nat_num_game.interactive.ring := tactic.interactive.ring -- hide\n", "namespace mynat -- hide\n", "def two_eq_succ_one : (2 : mynat) = succ 1 := rfl -- hide\n", "# Power World\n", "## Level 8: `add_squared`\n\n[final boss music] \n\nYou see something written on the stone dungeon wall:\n```\nbegin\n  rw two_eq_succ_one,\n  rw one_eq_succ_zero,\n  repeat {rw pow_succ},\n  ...\n```\n\nand you can't make out the last two lines because there's a kind\nof thing in the way that will magically disappear\nbut only when you've beaten the boss.\n\n", "For all naturals $a$ and $b$, we have\n$$(a+b)^2=a^2+b^2+2ab.$$\n", "As the boss lies smouldering, you notice on the dungeon wall that\n<a href=\"https://twitter.com/XenaProject/status/1190453646904958976?s=20/\" target=\"blank\">\ntwo more lines of code are now visible under the first three...</a> (Twitter.com)\n\nI just beat this level with 27 single rewrites followed by a `refl`. \nCan you do any better? (The current rewrite record is 25 -- see <a href=\"https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/function.20with.20random.20definition/near/179723073\" target=\"blank\">here</a>\n(needs zulip login)).\nIf you beat it then well done! Do you\nfancy doing $(a+b)^3$ now? You might want to read \n<a href=\"https://xenaproject.wordpress.com/2018/06/13/ab3/\" target=\"blank\">\nthis Xena Project blog post</a> before you start though.\n", "If you got this far -- very well done! If you only learnt the three\ntactics `rw`, `induction` and `refl` then there are now more tactics to\nlearn; go back to the main menu and choose Function World. \n\nThe main thing we really want to impress upon people is that we believe\nthat *all of pure mathematics* can be done in this new way.\nA system called Coq (which is very like Lean) has\n<a href=\"https://hal.inria.fr/hal-00816699\" target=\"blank\">\nchecked the proof of the Feit-Thompson theorem</a> (hundreds of pages of\ngroup theory) and Lean has a\n<a href=\"https://leanprover-community.github.io/lean-perfectoid-spaces/\"\n  target=\"blank\">\ndefinition of perfectoid spaces</a> (a very complex modern\nmathematical structure). I believe that these systems will one day\ncause a paradigm shift in the way mathematics is done, but first we need\nto build what we know, or at least build enough to state what we\nmathematicians believe. If you want to get involved, come and join\nus at the <a href=\"https://leanprover.zulipchat.com\" target=\"blank\">Zulip Lean chat</a>.\nThe #new members stream is a great place to start asking questions.\n\nTo come (possibly): the real number game, the group theory game,\nthe integer game, the natural number game 2,... . Alternatively\nsee <a href=\"http://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game/FAQ.html\" target=\"blank\">the FAQ</a>\nfor some more ideas about what to do next.\n\n", "end mynat -- hide\n", "Function world", "\n# Function world. \n\nIf you have beaten Addition World, then you have got\nquite good at manipulating equalities in Lean using the `rw` tactic.\nBut there are plenty of levels later on which will require you\nto manipulate functions, and `rw` is not the tool for you here.\n\nTo manipulate functions effectively, we need to learn about a new collection\nof tactics, namely `exact`, `intro`, `have` and `apply`. These tactics\nare specially designed for dealing with functions. Of course we are\nultimately interested in using these tactics to prove theorems\nabout the natural numbers &ndash; but in this\nworld there is little point in working with specific sets like `mynat`,\neverything works for general sets.\n\nSo our notation for this level is: $P$, $Q$, $R$ and so on denote general sets,\nand $h$, $j$, $k$ and so on denote general\nfunctions between them. What we will learn in this world is how to use functions\nin Lean to push elements from set to set. A word of warning &ndash; \neven though there's no harm at all in thinking of $P$ being a set and $p$\nbeing an element, you will not see Lean using the notation $p\\in P$, because\ninternally Lean stores $P$ as a \"Type\" and $p$ as a \"term\", and it uses `p : P`\nto mean \"$p$ is a term of type $P$\", Lean's way of expressing the idea that $p$\nis an element of the set $P$. You have seen this already &ndash; Lean has\nbeen writing `n : mynat` to mean that $n$ is a natural number.\n\n## A new kind of goal.\n\nAll through addition world, our goals have been theorems,\nand it was our job to find the proofs. \n**The levels in function world aren't theorems**. This is the only world where\nthe levels aren't theorems in fact. In function world the object of a level\nis to create an element of the set in the goal. The goal will look like `\u22a2 X`\nwith $X$ a set and you get rid of the goal by constructing an element of $X$. \nI don't know if you noticed this, but you finished\nessentially every goal of Addition World (and Multiplication World and Power World,\nif you played them) with `refl`.\nThis tactic is no use to us here.\nWe are going to have to learn a new way of solving goals &ndash; the `exact` tactic.\n\nIf you delete the sorry below then your local context will look like this:\n\n```\nP Q : Type,\np : P,\nh : P \u2192 Q\n\u22a2 Q\n```\n\nIn this situation, we have sets $P$ and $Q$ (but Lean calls them types),\nand an element $p$ of $P$ (written `p : P`\nbut meaning $p\\in P$). We also have a function $h$ from $P$ to $Q$,\nand our goal is to construct an\nelement of the set $Q$. It's clear what to do *mathematically* to solve\nthis goal -- we can\nmake an element of $Q$ by applying the function $h$ to\nthe element $p$. But how to do it in Lean? There are at least two ways\nto explain this idea to Lean,\nand here we will learn about one of them, namely the method which\nuses the `exact` tactic.\n\n## The `exact` tactic. \n\nIf you can explicitly see how to make an element of your goal set,\ni.e. you have a formula for it, then you can just write `exact <formula>` \nand this will close the goal. \n\n### Example\n\nIf your local context looks like this\n\n```\nP Q : Type,\np : P,\nh : P \u2192 Q\n\u22a2 Q\n```\n\nthen $h(p)$ is an element of $Q$ so you can just write\n\n`exact h(p),`\n\nto close the goal. \n\n## Important note\n\nNote that `exact h(P),` won't work (with a capital $P$);\nthis is a common error I see from beginners. \n$P$ is not an element of $P$, it's $p$ that is an element of $P$. \n\n## Level 1: the `exact` tactic.\n", "Given an element of $P$ and a function from $P$ to $Q$,\nwe define an element of $Q$.\n", "\n## Summary \n\nIf the goal is `\u22a2 X` then `exact x` will close the goal if\nand only if `x` is a term of type `X`. \n\n## Details\n\nSay $P$, $Q$ and $R$ are types (i.e., what a mathematician\nmight think of as either sets or propositions),\nand the local context looks like this: \n\n```\np : P,\nh : P \u2192 Q,\nj : Q \u2192 R\n\u22a2 R\n```\n\nIf you can spot how to make a term of type `R`, then you\ncan just make it and say you're done using the `exact` tactic\ntogether with the formula you have spotted. For example the\nabove goal could be solved with\n\n`exact j(h(p)),`\n\nbecause $j(h(p))$ is easily checked to be a term of type $R$\n(i.e., an element of the set $R$, or a proof of the proposition $R$).\n\n", "import mynat.add -- + on mynat\nimport mynat.mul -- * on mynat\n", "\n## Summary:\n\n`intro p` will turn a goal `\u22a2 P \u2192 Q` into a hypothesis `p : P`\nand goal `\u22a2 Q`. If `P` and `Q` are sets `intro p` means \"let $p$ be an arbitrary element of $P$\".\nIf `P` and `Q` are propositions then `intro p` says \"assume $P$ is true\". \n\n## Details\n\nIf your goal is a function or an implication `\u22a2 P \u2192 Q` then `intro`\nwill always make progress. `intro p` turns\n\n`\u22a2 P \u2192 Q`\n\ninto \n\n```\np : P\n\u22a2 Q\n```\n\nThe opposite tactic to intro is `revert`; given the situation\njust above, `revert p` turns the goal back into `\u22a2 P \u2192 Q`.\n\nThere are two points of view with `intro` -- the\nfunction point of view (Function World) and the proposition\npoint of view (Proposition World).\n\n## Example (functions)\n\nWhat does it mean to define\na function? Given an arbitrary term of type `P` (or an element\nof the set `P` if you think set-theoretically) you need\nto come up with a term of type `Q`, so your first step is\nto choose `p`, an arbitary element of `P`. \n\n`intro p,` is Lean's way of saying \"let $p\\in P$ be arbitrary\".\nThe tactic `intro p` changes\n\n```\n\u22a2 P \u2192 Q\n```\n\ninto\n\n```\np : P\n\u22a2 Q\n```\n\nSo `p` is an arbitrary element of `P` about which nothing is known,\nand our task is to come up with an element of `Q` (which can of\ncourse depend on `p`).\n\n## Example (propositions)\n\nIf your goal is an implication $P\\implies Q$ then Lean writes\nthis as `\u22a2 P \u2192 Q`, and `intro p,` can be thought of as meaning\n\"let $p$ be a proof of $P$\", or more informally \"let's assume that\n$P$ is true\". The goal changes to `\u22a2 Q` and the hypothesis `p : P`\nappears in the local context.\n", "# Function world. \n\n## Level 2: the `intro` tactic.\n\nLet's make a function. Let's define the function on the natural\nnumbers which sends a natural number $n$ to $3n+2$. If you delete the\n`sorry` you will see that our goal is `mynat \u2192 mynat`. A mathematician\nmight denote this set with some exotic name such as\n$\\operatorname{Hom}(\\mathbb{N},\\mathbb{N})$,\nbut computer scientists use notation `X \u2192 Y` to denote the set of\nfunctions from `X` to `Y` and this name definitely has its merits.\nIn type theory, `X \u2192 Y` is a type (the type of all functions from $X$ to $Y$),\nand `f : X \u2192 Y` means that `f` is a term\nof this type, i.e., $f$ is a function from $X$ to $Y$.\n\nTo define a function $X\\to Y$ we need to choose an arbitrary\nelement $x\\in X$ and then, perhaps using $x$, make an element of $Y$.\nThe Lean tactic for \"let $x\\in X$ be arbitrary\" is `intro x`.\n\n## Rule of thumb: \n\nIf your goal is `P \u2192 Q` then `intro p` will make progress.\n\nTo solve the goal below, you have to come up with a function from `mynat`\nto `mynat`. Start with\n\n`intro n,`\n\n(i.e. \"let $n\\in\\mathbb{N}$ be arbitrary\") and note that our\nlocal context now looks like this:\n\n```\nn : mynat\n\u22a2 mynat\n```\n\nOur job now is to construct a natural number, which is\nallowed to depend on $n$. We can do this using `exact` and\nwriting a formula for the function we want to define. For example\nwe imported addition and multiplication at the top of this file,\nso \n\n`exact 3*n+2,`\n\nwill close the goal, ultimately defining the function $f(n)=3n+2$.\n\n", "We define a function from mynat to mynat.\n", "\n## Summary\n\n`have h : P,` will create a new goal of creating a term of type `P`,\nand will add `h : P` to the hypotheses for the goal you were working on.\n\n## Details\n\nIf you want to name a term of some type (because you want it\nin your local context for some reason), and if you have the\nformula for the term, you can use `have` to give the term a name. \n\n## Example (`have q := ...` or `have q : Q := ...`)\n\nIf the local context contains\n```\nf : P \u2192 Q\np : P\n```\n\nthen the tactic `have q := f(p),` will add `q` to our local context,\nleaving it like this:\n\n```\nf : P \u2192 Q\np : P\nq : Q\n```\n\nIf you think about it, you don't ever really need `q`, because whenever you\nthink you need it you coudl just use `f(p)` instead. But it's good that\nwe can introduce convenient notation like this.\n\n## Example (`have q : Q,`)\n\nA variant of this tactic can be used where you just declare the\ntype of the term you want to have, finish the tactic statement with\na comma and no `:=`, and then Lean just adds it as a new goal.\nThe number of goals goes up by one if you use `have` like this.\n\nFor example if the local context is\n```\nP Q R : Prop/Type,\nf : P \u2192 Q,\ng : Q \u2192 R,\np : P\n\u22a2 R\n```\n\nthen after `have q : Q,`, there will be the new goal\n```\nf : P \u2192 Q,\ng : Q \u2192 R,\np : P,\n\u22a2 Q\n```\n\nand your original goal will have `q : Q` added to the list\nof hypotheses.\n", "# Function world. \n\n## Level 3: the `have` tactic.\n\nSay you have a whole bunch of sets and functions between them,\nand your goal is to build a certain element of a certain set.\nIf it helps, you can build intermediate elements of other sets\nalong the way, using the `have` command. `have` is the Lean analogue\nof saying \"let's define an element $q\\in Q$ by...\" in the middle of a calculation.\nIt is often not logically necessary, but on the other hand\nit is very convenient, for example it can save on notation, or\nit can break proofs or calculations up into smaller steps.\n\nIn the level below, we have an element of $P$ and we want an element\nof $U$; during the proof we will make several intermediate elements\nof some of the other sets involved. The diagram of sets and\nfunctions looks like this pictorially:\n\n![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game_images/function_diag.jpg)\n\nand so it's clear how to make the element of $U$ from the element of $P.$\nIndeed, we could solve this level in one move by typing\n\n`exact l(j(h(p))),`\n\nBut let us instead stroll more lazily through the level.\nWe can start by using the `have` tactic to make an element of $Q$:\n\n`have q := h(p),`\n\nand then we note that $j(q)$ is an element of $T$\n\n`have t : T := j(q),`\n\n(notice how on this occasion we explicitly told Lean what set we thought $t$ was in, with\nthat `: T` thing before the `:=`) and we could even define $u$ to be $l(t)$:\n\n`have u : U := l(t),`\n\nand then finish the level with\n\n`exact u,`\n\n. \n", "Given an element of $P$ we can define an element of $U$.\n", "If you solved the level using `have`, then click on the last line of your proof\n(you do know you can move your cursor around with the arrow keys\nand explore your proof, right?) and note that the local context at that point\nis in something like the following mess:\n\n```\nP Q R S T U : Type,\np : P,\nh : P \u2192 Q,\ni : Q \u2192 R,\nj : Q \u2192 T,\nk : S \u2192 T,\nl : T \u2192 U,\nq : Q,\nt : T,\nu : U\n\u22a2 U\n```\n\nIt was already bad enough to start with, and we added three more\nterms to it. In level 4 we will learn about the `apply` tactic\nwhich solves the level using another technique, without leaving\nso much junk behind.\n", "\n## Summary\n\nIf `h : P \u2192 Q` is a hypothesis, and the goal is `\u22a2 Q` then\n`apply h` changes the goal to `\u22a2 P`. \n\n## Details\n\nIf you have a function `h : P \u2192 Q` and your goal is `\u22a2 Q`\nthen `apply h` changes the goal to `\u22a2 P`. The logic is\nsimple: if you are trying to create a term of type `Q`,\nbut `h` is a function which turns terms of type `P` into\nterms of type `Q`, then it will suffice to construct a\nterm of type `P`. A mathematician might say: \"we need\nto construct an element of $Q$, but we have a function $h:P\\to Q$\nso it suffices to construct an element of $P$\". Or alternatively\n\"we need to prove $Q$, but we have a proof $h$ that $P\\implies Q$\nso it suffices to prove $P$\".\n\n", "\n# Function world. \n\n## Level 4: the `apply` tactic.\n\nLet's do the same level again:\n\n![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game_images/function_diag.jpg)\n\nWe are given $p \\in P$ and our goal is to find an element of $U$, or\nin other words to find a path through the maze that links $P$ to $U$.\nIn level 3 we solved this by using `have`s to move forward, from $P$\nto $Q$ to $T$ to $U$. Using the `apply` tactic we can instead construct\nthe path backwards, moving from $U$ to $T$ to $Q$ to $P$.\n\nOur goal is to construct an element of the set $U$. But $l:T\\to U$ is\na function, so it would suffice to construct an element of $T$. Tell\nLean this by starting the proof below with\n\n`apply l,`\n\nand notice that our assumptions don't change but *the goal changes*\nfrom `\u22a2 U` to `\u22a2 T`. \n\nKeep `apply`ing functions until your goal is `P`, and try not\nto get lost! Now solve this goal\nwith `exact p`. Note: you will need to learn the difference between\n`exact p` (which works) and `exact P` (which doesn't, because $P$ is\nnot an element of $P$).\n", "Given an element of $P$ we can define an element of $U$.\n", "# Function world. \n\n## Level 5: `P \u2192 (Q \u2192 P)`.\n\nIn this level, our goal is to construct a function, like in level 2.\n\n```\n\u22a2 P \u2192 (Q \u2192 P)\n```\n\nSo $P$ and $Q$ are sets, and our goal is to construct a function\nwhich takes an element of $P$ and outputs a function from $Q$ to $P$.\nWe don't know anything at all about the sets $P$ and $Q$, so initially\nthis seems like a bit of a tall order. But let's give it a go. Delete\nthe `sorry` and let's think about how to proceed.\n\nOur goal is `P \u2192 X` for some set $X=\\operatorname{Hom}(Q,P)$, and if our\ngoal is to construct a function then we almost always want to use the\n`intro` tactic from level 2, Lean's version of \"let $p\\in P$ be arbitrary.\"\nSo let's start with\n\n`intro p,`\n\nand we then find ourselves in this state:\n\n```\nP Q : Type,\np : P\n\u22a2 Q \u2192 P\n```\n\nWe now have an arbitrary element $p\\in P$ and we are supposed to be constructing\na function $Q\\to P$. Well, how about the constant function, which sends everything to $p$?\nThis will work. So let $q\\in Q$ be arbitrary:\n\n`intro q,`\n\nand then let's output `p`.\n\n`exact p,`\n", "We define an element of $\\operatorname{Hom}(P,\\operatorname{Hom}(Q,P))$.\n", "A mathematician would treat the set `P \u2192 (Q \u2192 P)` as the same as the set `P \u00d7 Q \u2192 P`,\nbecause to give an element of either function space is just to give a rule which takes\nan element of $P$ and an element of $Q$, and returns an element of $P$. Thinking of the\ngoal as a function from `P \u00d7 Q` to `P` we realise that it's just projection onto the first\nfactor.\n\n## Did you notice?\n\nI wrote `P \u2192 (Q \u2192 P)` but Lean just writes `P \u2192 Q \u2192 P`. This is because\ncomputer scientists adopt the convention that `\u2192` is *right associative*,\nwhich is a fancy way of saying \"when we write `P \u2192 Q \u2192 R`, we mean `P \u2192 (Q \u2192 R)`.\"\nMathematicians use right associativity as a convention for powers: if\na mathematician says $10^{10^{10}}$ they don't mean $(10^{10})^{10}=10^{100}$, they\nmean $10^{(10^{10})}$. So `10 ^ 10 ^ 10` in Lean means `10 ^ (10 ^ 10)` and not `(10 ^ 10) ^ 10`.\nHowever they use left associativity as a convention for subtraction: if\na mathematician writes $6 - 2 - 1$ they mean $(6 - 2) - 1$ and not $6 - (2 - 1)$.\n\n## Pro tip\n\n`intros p q,` is the same as `intro p, intro q,`.\n", "# Function world. \n\n## Level 6: `(P \u2192 (Q \u2192 R)) \u2192 ((P \u2192 Q) \u2192 (P \u2192 R))`.\n\nYou can solve this level completely just using `intro`, `apply` and `exact`,\nbut if you want to argue forwards instead of backwards then don't forget\nthat you can do things like\n\n`have j : Q \u2192 R := f p,`\n\nif `f : P \u2192 (Q \u2192 R)` and `p : P`. Remember the trick with the colon in `have`:\nwe could just write `have j := f p,` but this way we can be sure that `j` is\nwhat we actually expect it to be.\n\nI recommend that you start with `intro f` rather than `intro p`\nbecause even though the goal starts `P \u2192 ...`, the brackets mean that\nthe goal is not a function from `P` to anything, it's a function from\n`P \u2192 (Q \u2192 R)` to something. In fact you can save time by starting\nwith `intros f h p`, which introduces three variables at once, although you'd\nbetter then look at your tactic state to check that you called all those new\nterms sensible things. \n\nAfter all the intros, you find that your your goal is `\u22a2 R`. If you try `have j : Q \u2192 R := f p`\nnow then you can `apply j`. Alternatively you can `apply (f p)` directly.\nWhat happens if you just try `apply f`? Can you figure out what just happened? This is a little\n`apply` easter egg. Why is it mathematically valid?\n", "Whatever the sets $P$ and $Q$ and $R$ are, we\nmake an element of $\\operatorname{Hom}(\\operatorname{Hom}(P,\\operatorname{Hom}(Q,R)),\n\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\\operatorname{Hom}(P,R)))$.\n", "# Function world. \n\n## Level 7: `(P \u2192 Q) \u2192 ((Q \u2192 F) \u2192 (P \u2192 F))` \n\nHave you noticed that, in stark contrast to earlier worlds,\nwe are not amassing a large collection of useful theorems? \nWe really are just constructing abstract levels with sets and\nfunctions, and then solving them and never using the results\never again. Here's another one, which should hopefully be\nvery easy for you now. Advanced mathematician viewers will\nknow it as contravariance of $\\operatorname{Hom}(\\cdot,F)$\nfunctor.\n", "Whatever the sets $P$ and $Q$ and $F$ are, we \nmake an element of $\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\n\\operatorname{Hom}(\\operatorname{Hom}(Q,F),\\operatorname{Hom}(P,F)))$.\n", "# Function world. \n\n## Level 8: `(P \u2192 Q) \u2192 ((Q \u2192 empty) \u2192 (P \u2192 empty))` \n\nLevel 8 is the same as level 7, except we have replaced the\nset $F$ with the empty set $\\emptyset$. The same proof will work (after all, our\nprevious proof worked for all sets, and the empty set is a set).\nBut note that if you start with `intro f, intro h, intro p,`\n(which can incidentally be shortened to `intros f h p`),\nthen the local context looks like this:\n\n```\nP Q : Type,\nf : P \u2192 Q,\nh : Q \u2192 empty,\np : P\n\u22a2 empty\n```\n\nand your job is to construct an element of the empty set!\nThis on the face of it seems hard, but what is going on is that\nour hypotheses (we have an element of $P$, and functions $P\\to Q$\nand $Q\\to\\emptyset$) are themselves contradictory, so\nI guess we are doing some kind of proof by contradiction at this point? However,\nif your next line is `apply h` then all of a sudden the goal\nseems like it might be possible again. If this is confusing, note\nthat the proof of the previous world worked for all sets $F$, so in particular\nit worked for the empty set, you just probably weren't really thinking about\nthis case explicitly beforehand. [Technical note to constructivists: I know\nthat we are not doing a proof by contradiction. But how else do you explain\nto a classical mathematician that their goal is to prove something false\nand this is OK because their hypotheses don't add up?]\n\n", "Whatever the sets $P$ and $Q$ are, we\nmake an element of $\\operatorname{Hom}(\\operatorname{Hom}(P,Q),\n\\operatorname{Hom}(\\operatorname{Hom}(Q,\\emptyset),\\operatorname{Hom}(P,\\emptyset)))$.\n", "# Function world. \n\n## Level 9: a big maze. \n\nI asked around on Zulip and apparently there is not a tactic for this, perhaps because\nthis level is rather artificial. In world 6 we will see a variant of this example\nwhich can be solved by a tactic. It would be an interesting project to make a tactic\nwhich could solve this sort of level in Lean.\n\nYou can of course work both forwards and backwards, or you could crack and draw a picture.\n\n", "Given a bunch of functions, we can define another one.\n", "That's the end of Function World! Next it's Proposition world, and the tactics you've learnt in Function World are enough\nto solve all nine levels! In fact, the levels in Proposition world might look strangely familiar$\\ldots$.\n", "Proposition world", "\n# Proposition world. \n\nA Proposition is a true/false statement, like `2 + 2 = 4` or `2 + 2 = 5`.\nJust like we can have concrete sets in Lean like `mynat`, and abstract\nsets called things like `X`, we can also have concrete propositions like\n`2 + 2 = 5` and abstract propositions called things like `P`. \n\nMathematicians are very good at conflating a theorem with its proof.\nThey might say \"now use theorem 12 and we're done\". What they really\nmean is \"now use the proof of theorem 12...\" (i.e. the fact that we proved\nit already). Particularly problematic is the fact that mathematicians\nuse the word Proposition to mean \"a relatively straightforward statement\nwhich is true\" and computer scientists use it to mean \"a statement of\narbitrary complexity, which might be true or false\". Computer scientists\nare far more careful about distinguishing between a proposition and a proof.\nFor example: `x + 0 = x` is a proposition, and `add_zero x`\nis its proof. The convention we'll use is capital letters for propositions\nand small letters for proofs. \n\nIn this world you will see the local context in the following kind of state:\n\n```\nP : Prop\np : P\n```\n\nHere `P` is the true/false statement (the statement of proposition), and `p` is its proof.\nIt's like `P` being the set and `p` being the element. In fact computer scientists\nsometimes think about the following analogy: propositions are like sets,\nand their proofs are like their elements. \n\n## What's going on in this world? \n\nWe're going to learn about manipulating propositions and proofs.\nFortunately, we don't need to learn a bunch of new tactics -- the\nones we just learnt (`exact`, `intro`, `have`, `apply`) will be perfect.\n\nThe levels in proposition world are \"back to normal\", we're proving\ntheorems, not constructing elements of sets. Or are we?\n\nIf you delete the sorry below then your local context will look like this:\n\n```\nP Q : Prop,\np : P,\nh : P \u2192 Q\n\u22a2 Q\n```\n\nIn this situation, we have true/false statements $P$ and $Q$,\na proof $p$ of $P$, and $h$ is the hypothesis that $P\\implies Q$.\nOur goal is to construct a proof of $Q$. It's clear what to do\n*mathematically* to solve this goal, $P$ is true and $P$ implies $Q$\nso $Q$ is true. But how to do it in Lean?\n\nAdopting a point of view wholly unfamiliar to many mathematicians,\nLean interprets the hypothesis $h$ as a function from proofs\nof $P$ to proofs of $Q$, so the rather surprising approach\n\n`exact h(p),`\n\nworks to close the goal.\n\nNote that `exact h(P),` (with a capital P) won't work;\nthis is a common error I see from beginners. \"We're trying to solve `P`\nso it's exactly `P`\". The goal states the *theorem*, your job is to\nconstruct the *proof*. $P$ is not a proof of $P$, it's $p$ that is a proof of $P$. \n\nIn Lean, Propositions, like sets, are types, and proofs, like elements of sets, are terms.\n\n## Level 1: the `exact` tactic.\n", "If $P$ is true, and $P\\implies Q$ is also true, then $Q$ is true.\n", "# Proposition world. \n\n## Level 2: `intro`.\n\nLet's prove an implication. Let $P$ be a true/false statement,\nand let's prove that $P\\implies P$. If you delete the\n`sorry` you will see that our goal is `P \u2192 P`. Constructing a term\nof type `P \u2192 P` (which is what solving this goal *means*) in this\ncase amounts to proving that $P\\implies P$, and computer scientists\nthink of this as coming up with a function which sends proofs of $P$\nto proofs of $P$.\n\nTo define an implication $P\\implies Q$ we need to choose an arbitrary\nproof $p : P$ of $P$ and then, perhaps using $p$, construct a proof\nof $Q$.  The Lean way to say \"let's assume $P$ is true\" is `intro p`,\ni.e., \"let's assume we have a proof of $P$\".\n\n## Note for worriers.\n\nThose of you who know\nsomething about the subtle differences between truth and provability\ndiscovered by Goedel -- these are not relevant here. Imagine we are\nworking in a fixed model of mathematics, and when I say \"proof\"\nI actually mean \"truth in the model\", or \"proof in the metatheory\".\n\n## Rule of thumb: \n\nIf your goal is to prove `P \u2192 Q` (i.e. that $P\\implies Q$)\nthen `intro p`, meaning \"assume $p$ is a proof of $P$\", will make progress.\n\nTo solve the goal below, you have to come up with a function from\n`P` (thought of as the set of proofs of $P$!) to itself. Start with\n\n`intro p,`\n\n(i.e. \"let $p$ be a proof of $P$\") and note that our\nlocal context now looks like this:\n\n```\nP : Prop,\np : P\n\u22a2 P\n```\n\nOur job now is to construct a proof of $P$. But $p$ is a proof of $P$.\nSo\n\n`exact p,`\n\nwill close the goal. Note that `exact P` will not work -- don't\nconfuse a true/false statement (which could be false!) with a proof.\nWe will stick with the convention of capital letters for propositions\nand small letters for proofs.\n", "If $P$ is a proposition then $P\\implies P$.\n", "# Proposition world. \n\n## Level 3: `have`.\n\nSay you have a whole bunch of propositions and implications between them,\nand your goal is to build a certain proof of a certain proposition.\nIf it helps, you can build intermediate proofs of other propositions\nalong the way, using the `have` command. `have q : Q := ...` is the Lean analogue\nof saying \"We now see that we can prove $Q$, because...\"\nin the middle of a proof.\nIt is often not logically necessary, but on the other hand\nit is very convenient, for example it can save on notation, or\nit can break proofs up into smaller steps.\n\nIn the level below, we have a proof of $P$ and we want a proof\nof $U$; during the proof we will construct proofs of\nof some of the other propositions involved. The diagram of\npropositions and implications looks like this pictorially:\n\n![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game_images/implies_diag.jpg)\n\nand so it's clear how to deduce $U$ from $P$.\nIndeed, we could solve this level in one move by typing\n\n`exact l(j(h(p))),`\n\nBut let us instead stroll more lazily through the level.\nWe can start by using the `have` tactic to make a proof of $Q$:\n\n`have q := h(p),`\n\nand then we note that $j(q)$ is a proof of $T$:\n\n`have t : T := j(q),`\n\n(note how we explicitly told Lean what proposition we thought $t$ was\na proof of, with that `: T` thing before the `:=`) \nand we could even define $u$ to be $l(t)$:\n\n`have u : U := l(t),`\n\nand then finish the level with\n\n`exact u,`\n\n. \n", "In the maze of logical implications above, if $P$ is true then so is $U$.\n", "If you solved the level using `have`, then click on the last line of your proof\n(you do know you can move your cursor around with the arrow keys\nand explore your proof, right?) and note that the local context at that point\nis in something like the following mess:\n\n```\nP Q R S T U : Prop,\np : P,\nh : P \u2192 Q,\ni : Q \u2192 R,\nj : Q \u2192 T,\nk : S \u2192 T,\nl : T \u2192 U,\nq : Q,\nt : T,\nu : U\n\u22a2 U\n```\n\nIt was already bad enough to start with, and we added three more\nterms to it. In level 4 we will learn about the `apply` tactic\nwhich solves the level using another technique, without leaving\nso much junk behind.\n", "\n# Proposition world. \n\n## Level 4: `apply`.\n\nLet's do the same level again:\n\n![diagram](https://wwwf.imperial.ac.uk/~buzzard/xena/natural_number_game_images/implies_diag.jpg)\n\nWe are given a proof $p$ of $P$ and our goal is to find a proof of $U$, or\nin other words to find a path through the maze that links $P$ to $U$.\nIn level 3 we solved this by using `have`s to move forward, from $P$\nto $Q$ to $T$ to $U$. Using the `apply` tactic we can instead construct\nthe path backwards, moving from $U$ to $T$ to $Q$ to $P$.\n\nOur goal is to prove $U$. But $l:T\\implies U$ is\nan implication which we are assuming, so it would suffice to prove $T$.\nTell Lean this by starting the proof below with\n\n`apply l,`\n\nand notice that our assumptions don't change but *the goal changes*\nfrom `\u22a2 U` to `\u22a2 T`. \n\nKeep `apply`ing implications until your goal is `P`, and try not\nto get lost! Now solve this goal\nwith `exact p`. Note: you will need to learn the difference between\n`exact p` (which works) and `exact P` (which doesn't, because $P$ is\nnot a proof of $P$).\n", "We can solve a maze.\n", "# Proposition world. \n\n## Level 5 : `P \u2192 (Q \u2192 P)`.\n\nIn this level, our goal is to construct an implication, like in level 2.\n\n```\n\u22a2 P \u2192 (Q \u2192 P)\n```\n\nSo $P$ and $Q$ are propositions, and our goal is to prove\nthat $P\\implies(Q\\implies P)$.\nWe don't know whether $P$, $Q$ are true or false, so initially\nthis seems like a bit of a tall order. But let's give it a go. Delete\nthe `sorry` and let's think about how to proceed.\n\nOur goal is `P \u2192 X` for some true/false statement $X$, and if our\ngoal is to construct an implication then we almost always want to use the\n`intro` tactic from level 2, Lean's version of \"assume $P$\", or more precisely\n\"assume $p$ is a proof of $P$\". So let's start with\n\n`intro p,`\n\nand we then find ourselves in this state:\n\n```\nP Q : Prop,\np : P\n\u22a2 Q \u2192 P\n```\n\nWe now have a proof $p$ of $P$ and we are supposed to be constructing\na proof of $Q\\implies P$. So let's assume that $Q$ is true and try\nand prove that $P$ is true. We assume $Q$ like this:\n\n`intro q,`\n\nand now we have to prove $P$, but have a proof handy:\n\n`exact p,`\n", "For any propositions $P$ and $Q$, we always have\n$P\\implies(Q\\implies P)$. \n", "A mathematician would treat the proposition $P\\implies(Q\\implies P)$\nas the same as the proposition $P\\land Q\\implies P$,\nbecause to give a proof of either of these is just to give a method which takes\na proof of $P$ and a proof of $Q$, and returns a proof of $P$. Thinking of the\ngoal as $P\\land Q\\implies P$ we see why it is provable.\n\n## Did you notice?\n\nI wrote `P \u2192 (Q \u2192 P)` but Lean just writes `P \u2192 Q \u2192 P`. This is because\ncomputer scientists adopt the convention that `\u2192` is *right associative*,\nwhich is a fancy way of saying \"when we write `P \u2192 Q \u2192 R`, we mean `P \u2192 (Q \u2192 R)`.\nMathematicians would never dream of writing something as ambiguous as\n$P\\implies Q\\implies R$ (they are not really interested in proving abstract\npropositions, they would rather work with concrete ones such as Fermat's Last Theorem),\nso they do not have a convention for where the brackets go. It's important to\nremember Lean's convention though, or else you will get confused. If your goal\nis `P \u2192 Q \u2192 R` then you need to know whether `intro h` will create `h : P` or `h : P \u2192 Q`. \nMake sure you understand which one. \n", "# Proposition world. \n\n## Level 6: `(P \u2192 (Q \u2192 R)) \u2192 ((P \u2192 Q) \u2192 (P \u2192 R))`.\n\nYou can solve this level completely just using `intro`, `apply` and `exact`,\nbut if you want to argue forwards instead of backwards then don't forget\nthat you can do things like `have j : Q \u2192 R := f p` if `f : P \u2192 (Q \u2192 R)`\nand `p : P`. I recommend that you start with `intro f` rather than `intro p`\nbecause even though the goal starts `P \u2192 ...`, the brackets mean that\nthe goal is not the statement that `P` implies anything, it's the statement that\n$P\\implies (Q\\implies R)$ implies something. In fact I'd recommend that you started\nwith `intros f h p`, which introduces three variables at once.\nYou then find that your your goal is `\u22a2 R`. If you try `have j : Q \u2192 R := f p`\nnow then you can `apply j`. Alternatively you can `apply (f p)` directly.\nWhat happens if you just try `apply f`? Can you figure out what just happened? This is a little\n`apply` easter egg. Why is it mathematically valid?\n", "If $P$ and $Q$ and $R$ are true/false statements, then\n$$(P\\implies(Q\\implies R))\\implies((P\\implies Q)\\implies(P\\implies R)).$$\n", "# Function world. \n\n## Level 7: `(P \u2192 Q) \u2192 ((Q \u2192 R) \u2192 (P \u2192 R))` \n\nIf you start with `intro hpq` and then `intro hqr`\nthe dust will clear a bit and the level will look like this:\n```\nP Q R : Prop,\nhpq : P \u2192 Q,\nhqr : Q \u2192 R\n\u22a2 P \u2192 R\n```\nSo this level is really about showing transitivity of $\\implies$,\nif you like that sort of language.\n", "From $P\\implies Q$ and $Q\\implies R$ we can deduce $P\\implies R$.\n", "\u00ac P \u2194 P \u2192 false\n", "lemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n", "# Proposition world. \n\n## Level 8 : `(P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)` \n\nThere is a false proposition `false`, with no proof. It is\neasy to check that $\\lnot Q$ is equivalent to $Q\\implies {\\tt false}$,\nand in the natural number game we call this\n\n`not_iff_imp_false (P : Prop) : \u00ac P \u2194 (P \u2192 false)`\n\nSo you can start the proof of the contrapositive below with\n\n`repeat {rw not_iff_imp_false},`\n\nto get rid of the two occurences of `\u00ac`, and I'm sure you can\ntake it from there (note that we just added `not_iff_imp_false` to the\ntheorem statements in the menu on the left). At some point your goal might be to prove `false`.\nAt that point I guess you must be proving something by contradiction.\nOr are you? \n", "If $P$ and $Q$ are propositions, and $P\\implies Q$, then\n$\\lnot Q\\implies \\lnot P$. \n", "## Technical note\n\n\nAll of that rewriting you did with `rw` in addition world\nwas rewriting hypothesis of the form `h : X = Y`, but\nyou can also `rw h` if `h : P \u2194 Q` (because propositional\nextensionality says that if $P\\iff Q$ then $P=Q$, and\nmathematicians use this whether or not they notice.)\n", "# Proposition world. \n\n## Level 9: a big maze. \n\nLean's \"congruence closure\" tactic `cc` is good at mazes. You might want to try it now.\nPerhaps I should have mentioned it earlier.\n", "There is a way through the following maze.\n", "Now move onto advanced proposition world, where you will see\nhow to prove goals such as `P \u2227 Q` ($P$ and $Q$), `P \u2228 Q` ($P$ or $Q$),\n`P \u2194 Q` ($P\\iff Q$).\nYou will need to learn five more tactics: `split`, `cases`,\n`left`, `right`, and `exfalso`,\nbut they are all straightforward, and furthermore they are\nessentially the last tactics you\nneed to learn in order to complete all the levels of the Natural Number Game,\nincluding all the 17 levels of Inequality World. \n", "\n## Summary:\n\n`cc` will solve certain \"logic\" goals.\n\n## Details\n\n`cc` is a \"congruence closure tactic\". In practice this means that it is\ngood at solving certain logic goals. It's worth trying if you think\nthat the goal could be solved using truth tables.\n", "Advanced Proposition world", "\n# Advanced proposition world. \n\nIn this world we will learn five key tactics needed to solve all the\nlevels of the Natural Number Game, namely `split`, `cases`, `left`, `right`, and `exfalso`.\nThese, and `use` (which we'll get to in Inequality World) are all the\ntactics you will need to beat all the levels of the game.\n\n## Level 1: the `split` tactic.\n\nThe logical symbol `\u2227` means \"and\". If $P$ and $Q$ are propositions, then\n$P\\land Q$ is the proposition \"$P$ and $Q$\". If your *goal* is `P \u2227 Q` then\nyou can make progress with the `split` tactic, which turns one goal `\u22a2 P \u2227 Q`\ninto two goals, namely `\u22a2 P` and `\u22a2 Q`. In the level below, after a `split`,\nyou will be able to finish off the goals with the `exact` tactic.\n", "If $P$ and $Q$ are true, then $P\\land Q$ is true.\n", "\n## Summary:\n\nIf the goal is `P \u2227 Q` or `P \u2194 Q` then `split` will break it into two goals.\n\n## Details\n\nIf `P Q : Prop` and the goal is `\u22a2 P \u2227 Q`, then `split` will change it into\ntwo goals, namely `\u22a2 P` and `\u22a2 Q`. \n\nIf `P Q : Prop` and the goal is `\u22a2 P \u2194 Q`, then `split` will change it into\ntwo goals, namely `\u22a2 P \u2192 Q` and `\u22a2 Q \u2192 P`.  \n\n## Example:\n\nIf your local context (the top right window) looks like this\n```\na b : mynat,\n\u22a2 a = b \u2194 a + 3 = b + 3\n```\n\nthen after\n\n`split,`\n\nit will look like this:\n\n```\n2 goals\na b : mynat\n\u22a2 a = b \u2192 a + 3 = b + 3\n\na b : mynat\n\u22a2 a + 3 = b + 3 \u2192 a = b\n\n", "\n# Advanced proposition world. \n\n## Level 2: the `cases` tactic.\n\nIf `P \u2227 Q` is in the goal, then we can make progress with `split`.\nBut what if `P \u2227 Q` is a hypothesis? In this case, the `cases` tactic will enable\nus to extract proofs of `P` and `Q` from this hypothesis.\n\nThe lemma below asks us to prove `P \u2227 Q \u2192 Q \u2227 P`, that is,\nsymmetry of the \"and\" relation. The obvious first move is\n\n`intro h,`\n\nbecause the goal is an implication and this tactic is guaranteed\nto make progress. Now `h : P \u2227 Q` is a hypothesis, and\n\n`cases h with p q,`\n\nwill change `h`, the proof of `P \u2227 Q`, into two proofs `p : P`\nand `q : Q`. From there, `split` and `exact` will get you home.\n", "If $P$ and $Q$ are true/false statements, then $P\\land Q\\implies Q\\land P$. \n", "\n## Summary:\n\n`cases` is a tactic which works on hypotheses.\nIf `h : P \u2227 Q` or `h : P \u2194 Q` is a hypothesis then `cases h with h1 h2` will remove `h`\nfrom the list of hypotheses and replace it with the \"ingredients\" of `h`,\ni.e. `h1 : P` and `h2 : Q`, or `h1 : P \u2192 Q` and `h2 : Q \u2192 P`. Also\nworks with `h : P \u2228 Q` and `n : mynat`. \n\n## Details\n\nHow does one prove `P \u2227 Q`? The way to do it is to prove `P` and to\nprove `Q`. There are hence two ingredients which go into a proof of\n`P \u2227 Q`, and the `cases` tactic extracts them. \n\nMore precisely, if the local context contains\n```\nh : P \u2227 Q`\n```\n\nthen after the tactic `cases h with p q,` the local context will\nchange to\n```\np : P,\nq : Q\n```\nand `h` will disappear. \n\nSimilarly `h : P \u2194 Q` is proved by proving `P \u2192 Q` and `Q \u2192 P`,\nand `cases h with hpq hqp` will delete our assumption `h` and\nreplace it with\n```\nhpq : P \u2192 Q,\nhqp : Q \u2192 P\n```\n\nBe warned though -- `rw h` works with `h : P \u2194 Q` (`rw` works with\n`=` and `\u2194`), whereas you cannot rewrite with an implication.\n\n`cases` also works with hypotheses of the form `P \u2228 Q` and even\nwith `n : mynat`. Here the situation is different however. \nTo prove `P \u2228 Q` you need to give either a proof of `P` *or* a proof\nof `Q`, so if `h : P \u2228 Q` then `cases h with p q` will change one goal\ninto two, one with `p : P` and the other with `q : Q`. Similarly, each\nnatural is either `0` or `succ(d)` for `d` another natural, so if\n`n : mynat` then `cases n with d` also turns one goal into two,\none with `n = 0` and the other with `d : mynat` and `n = succ(d)`.\n", "\n# Advanced proposition world. \n\n## Level 3: and_trans.\n", "If $P$, $Q$ and $R$ are true/false statements, then $P\\land Q$ and\n$Q\\land R$ together imply $P\\land R$.\n", "\n# Advanced proposition world. \n\n## Level 4: `iff_trans`.\n\nThe mathematical statement $P\\iff Q$ is equivalent to $(P\\implies Q)\\land(Q\\implies P)$. The `cases`\nand `split` tactics work on hypotheses and goals (respectively) of the form `P \u2194 Q`. If you need\nto write an `\u2194` arrow you can do so by typing `\\iff`, but you shouldn't need to. After an initial\n`intro h,` you can type `cases h with hpq hqp` to break `h : P \u2194 Q` into its constituent parts.\n", "If $P$, $Q$ and $R$ are true/false statements, then\n$P\\iff Q$ and $Q\\iff R$ together imply $P\\iff R$.\n", "\n# Advanced proposition world. \n\n## Level 5: `iff_trans` easter eggs.\n\nLet's try `iff_trans` again. Try proving it in other ways.\n\n### A trick.\n\nInstead of using `cases` on `h : P \u2194 Q` you can just access the proofs of `P \u2192 Q` and `Q \u2192 P`\ndirectly with `h.1` and `h.2`. So you can solve this level with\n\n```\nintros hpq hqr, \nsplit,\nintro p,\napply hqr.1,\n...\n```\n\n### Another trick\n\nInstead of using `cases` on `h : P \u2194 Q`, you can just `rw h`, and this will change all `P`s to `Q`s\nin the goal. You can use this to create a much shorter proof. Note that\nthis is an argument for *not* running the `cases` tactic on an iff statement;\nyou cannot rewrite one-way implications, but you can rewrite two-way implications.\n\n### Another trick\n\n`cc` works on this sort of goal too.\n", "If $P$, $Q$ and $R$ are true/false statements, then `P \u2194 Q` and `Q \u2194 R` together imply `P \u2194 R`.\n", "import game.world7.level5 -- hide\n", "# Advanced proposition world. \n\n## Level 6: Or, and the `left` and `right` tactics.\n\n`P \u2228 Q` means \"$P$ or $Q$\". So to prove it, you\nneed to choose one of `P` or `Q`, and prove that one.\nIf `\u22a2 P \u2228 Q` is your goal, then `left` changes this\ngoal to `\u22a2 P`, and `right` changes it to `\u22a2 Q`.\nNote that you can take a wrong turn here. Let's\nstart with trying to prove $Q\\implies (P\\lor Q)$.\nAfter the `intro`, one of `left` and `right` leads\nto an impossible goal, the other to an easy finish.\n", "If $P$ and $Q$ are true/false statements, then\n$$Q\\implies(P\\lor Q).$$ \n", "\n## Summary\n\n`left` and `right` work on the goal, and they change\n`\u22a2 P \u2228 Q` to `\u22a2 P` and `\u22a2 Q` respectively.\n\n## Details\n\nThe tactics `left` and `right` work on a goal which is a type with\ntwo constructors, the classic example being `P \u2228 Q`. \nTo prove `P \u2228 Q` it suffices to either prove `P` or prove `Q`,\nand once you know which one you are going for you can change\nthe goal with `left` or `right` to the appropriate choice.\n", "import game.world7.level6 -- hide\n", "# Advanced proposition world. \n\n## Level 7: `or_symm`\n\nProving that $(P\\lor Q)\\implies(Q\\lor P)$ involves an element of danger.\n`intro h,` is the obvious start. But now,\neven though the goal is an `\u2228` statement, both `left` and `right` put\nyou in a situation with an impossible goal. Fortunately, after `intro h,`\nyou can do `cases h with p q`. Then something new happens: because\nthere are two ways to prove `P \u2228 Q` (namely, proving `P` or proving `Q`),\nthe `cases` tactic turns one goal into two, one for each case. You should\nbe able to make it home from there. \n", "If $P$ and $Q$ are true/false statements, then\n$$P\\lor Q\\implies Q\\lor P.$$ \n", "import tactic.finish game.world7.level7 -- hide\n", "namespace mynat -- hide\n", "# Advanced proposition world. \n\n## Level 8: `and_or_distrib_left`\n\nWe know that `x(y+z)=xy+xz` for numbers, and this\nis called distributivity of multiplication over addition.\nThe same is true for `\u2227` and `\u2228` -- in fact `\u2227` distributes\nover `\u2228` and `\u2228` distributes over `\u2227`. Let's prove one of these.\n", "If $P$. $Q$ and $R$ are true/false statements, then\n$$P\\land(Q\\lor R)\\iff(P\\land Q)\\lor (P\\land R).$$ \n", "## Pro tip\n\nDid you spot the import? What do you think it does?\n\nIf you follow the instructions at\n<a href=\"https://github.com/leanprover-community/mathlib#installation\" target=\"blank\">the mathlib github page</a>\nyou will be able to install Lean and mathlib on your own system, and then you can create a new project\nand experiment with such imports yourself.\n", "end mynat", "import game.world7.level8 -- hide\n", "import game.world6.level8 -- hide\n", "import tactic.tauto -- useful high-powered tactic\n", "local attribute [instance, priority 10] classical.prop_decidable -- hide\n", "# Advanced proposition world. \n\nYou already know enough to embark on advanced addition world. But here are just a couple\nmore things.\n\n## Level 9: `exfalso` and proof by contradiction. \n\nIt's certainly true that $P\\land(\\lnot P)\\implies Q$ for any propositions $P$\nand $Q$, because the left hand side of the implication is false. But how do\nwe prove that `false` implies any proposition $Q$? A cheap way of doing it in\nLean is using the `exfalso` tactic, which changes any goal at all to `false`. \nYou might think this is a step backwards, but if you have a hypothesis `h : \u00ac P`\nthen after `rw not_iff_imp_false at h,` you can `apply h,` to make progress. \nTry solving this level without using `cc` or `tauto`, but using `exfalso` instead.\n\n", "If $P$ and $Q$ are true/false statements, then\n$$(P\\land(\\lnot P))\\implies Q.$$\n", "## Pro tip.\n\n`\u00ac P` is actually `P \u2192 false` *by definition*. Try\ncommenting out `rw not_iff_imp_false at ...` by putting two minus signs `--`\nbefore the `rw`. Does it still compile?\n", "\n## Summary\n\n`exfalso` changes your goal to `false`. \n\n## Details\n\nWe know that `false` implies `P` for any proposition `P`, and so if your goal is `P`\nthen you should be able to `apply` `false \u2192 P` and reduce your goal to `false`. This\nis what the `exfalso` tactic does. The theorem that `false \u2192 P` is called `false.elim`\nso one can achieve the same effect with `apply false.elim`. \n\nThis tactic can be used in a proof by contradiction, where the hypotheses are enough\nto deduce a contradiction and the goal happens to be some random statement (possibly\na false one) which you just want to simplify to `false`.\n", "import game.world7.level9 -- hide\n", "import tactic.tauto \nlocal attribute [instance, priority 10] classical.prop_decidable -- we are mathematicians\n", "# Advanced proposition world.\n\n\n\n## Level 10: the law of the excluded middle.\n\nWe proved earlier that `(P \u2192 Q) \u2192 (\u00ac Q \u2192 \u00ac P)`. The converse,\nthat `(\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q)` is certainly true, but trying to prove\nit using what we've learnt so far is impossible (because it is not provable in\nconstructive logic). For example, after\n\n```\nintro h,\nintro p,\nrepeat {rw not_iff_imp_false at h},\n```\n\nin the below, you are left with\n```\nP Q : Prop,\nh : (Q \u2192 false) \u2192 P \u2192 false\np : P\n\u22a2 Q\n```\n\nThe tools you have are not sufficient to continue. But you can just\nprove this, and any other basic lemmas of this form like `\u00ac \u00ac P \u2192 P`,\nusing the `by_cases` tactic. Instead of starting with all the `intro`s,\ntry this instead:\n\n`by_cases p : P; by_cases q : Q,`\n\n**Note the semicolon**! It means \"do the next tactic to all the goals, not just the top one\".\nAfter it, there are four goals, one for each of the four possibilities PQ=TT, TF, FT, FF.\nYou can see that `p` is a proof of `P` in some of the goals, and a proof of `\u00ac P` in others.\nSimilar comments apply to `q`. \n\n`repeat {cc}` then finishes the job.\n\nThis approach assumed that `P \u2228 \u00ac P` was true; the `by_cases` tactic just does `cases` on\nthis result. This is called the law of the excluded middle, and it cannot be proved just\nusing tactics such as `intro` and `apply`.\n\n", "If $P$ and $Q$ are true/false statements, then\n$$(\\lnot Q\\implies \\lnot P)\\implies(P\\implies Q).$$ \n", "OK that's enough logic -- now perhaps it's time to go on to Advanced Addition World!\nGet to it via the main menu.\n", "## Pro tip\n\nIn fact the tactic `tauto!` just kills this goal (and many other logic goals) immediately.\n", "\n## Summary\n\n`by_cases h : P` does a cases split on whether `P` is true or false.\n\n## Details\n\nSome logic goals cannot be proved with `intro` and `apply` and `exact`.\nThe simplest example is the law of the excluded middle `\u00ac \u00ac P \u2192 P`.\nYou can prove this using truth tables but not with `intro`, `apply` etc.\nTo do a truth table proof, the tactic `by_cases h : P` will turn a goal of\n`\u22a2 \u00ac \u00ac P \u2192 P` into two goals\n\n```\nP : Prop,\nh : P\n\u22a2 \u00ac\u00acP \u2192 P\n\nP : Prop,\nh : \u00acP\n\u22a2 \u00ac\u00acP \u2192 P\n```\n\nEach of these can now be proved using `intro`, `apply`, `exact` and `exfalso`.\nRemember though that in these simple logic cases, high-powered logic\ntactics like `cc` and `tauto!` will just prove everything.\n\n\n\n", "\n## Summary\n\nThe `tauto` tactic (and its variant `tauto!`) will close various logic\ngoals.\n\n## Details\n\n`tauto` is an all-purpose logic tactic which will try to solve goals using pure\nlogical reasoning -- for example it will close the following goal:\n\n```\nP Q : Prop,\nhP : P,\nhQ : Q\n\u22a2 P \u2227 Q\n```\n\n`tauto` is supposed to only use constructive logic, but its big brother `tauto!` uses classical logic\nand hence closes more goals.\n", "Advanced Addition world", "import mynat.definition -- hide\n", "import mynat.add -- hide\n", "import game.world2.level6 -- hide\n", "namespace mynat -- hide\n", "  succ(a) = succ(b) \u2192 a = b\n", "\n# Advanced Addition World\n\n## Level 1: `succ_inj`. A function.\n\nPeano's original collection of axioms for the natural numbers contained two further\nassumptions, which have not yet been mentioned in the game:\n\n```\nsucc_inj {a b : mynat} :\n  succ(a) = succ(b) \u2192 a = b\n\nzero_ne_succ (a : mynat) :\n  zero \u2260 succ(a)\n ```\n\nThe reason they have not been used yet is that they are both implications,\nthat is,\nof the form $P\\implies Q$. This is clear for `succ_inj a b`, which\nsays that for all $a$ and $b$ we have $succ(a)=succ(b)\\implies a=b$.\nFor `zero_ne_succ` the trick is that $X\\ne Y$ is *defined to mean*\n$X = Y\\implies{\\tt false}$. If you have played through Proposition world,\nyou now have the required Lean skills (i.e., you know the required\ntactics) to work with these implications.\nLet's finally learn how to use `succ_inj`. You should know a couple\nof ways to prove the below -- one directly using an `exact`,\nand one which uses an `apply` first. But either way you'll need to use `succ_inj`.\n", "For all naturals $a$ and $b$, if we assume $succ(a)=succ(b)$, then we can\ndeduce $a=b$. \n", "## Important thing.\n\nYou can rewrite proofs of *equalities*. If `h : A = B` then `rw h` changes `A`s to `B`s.\nBut you *cannot rewrite proofs of implications*. `rw succ_inj` will *never work*\nbecause `succ_inj` isn't of the form $A = B$, it's of the form $A\\implies B$. This is one\nof the most common mistakes I see from beginners. $\\implies$ and $=$ are *two different things*\nand you need to be clear about which one you are using.\n", "end mynat -- hide\n", "import mynat.definition -- hide\n", "import mynat.add -- hide\n", "import game.world8.level1 -- hide\n", "namespace mynat -- hide\n", "\n# Advanced Addition World\n\n## Level 2: `succ_succ_inj`.\n", "In the below theorem, we need to apply `succ_inj` twice. Once to prove\n$succ(succ(a))=succ(succ(b))\\implies succ(a)=succ(b)$, and then again\nto prove $succ(a)=succ(b)\\implies a=b$. However `succ(a)=succ(b)` is\nnowhere to be found, it's neither an assumption or a goal when we start\nthis level. You can make it with `have` or you can use `apply`.\n", "For all naturals $a$ and $b$, if we assume $succ(succ(a))=succ(succ(b))$, then we can\ndeduce $a=b$. \n", "## Sample solutions to this level. \n\nMake sure you understand them all. And remember that `rw` should not be used\nwith `succ_inj` -- `rw` works only with equalities or `\u2194` statements,\nnot implications or functions.\n\n", "example {a b : mynat} (h : succ(succ(a)) = succ(succ(b))) :  a = b := \nbegin\n  apply succ_inj,\n  apply succ_inj,\n  exact h\nend \nexample {a b : mynat} (h : succ(succ(a)) = succ(succ(b))) :  a = b := \nbegin\n  apply succ_inj,\n  exact succ_inj(h),\nend \nexample {a b : mynat} (h : succ(succ(a)) = succ(succ(b))) :  a = b := \nbegin\n  exact succ_inj(succ_inj(h)),\nend \n", "end mynat -- hide", "import mynat.definition -- hide\n", "import mynat.add -- hide\n", "import game.world8.level2 -- hide\n", "namespace mynat -- hide\n", "\n# Advanced Addition World\n\n## Level 3: `succ_eq_succ_of_eq`.\n", "We are going to prove something completely obvious: if $a=b$ then\n$succ(a)=succ(b)$. This is *not* `succ_inj`!\nThis is trivial -- we can just rewrite our proof of `a=b`.\nBut how do we get to that proof? Use the `intro` tactic.\n", "For all naturals $a$ and $b$, $a=b\\implies succ(a)=succ(b)$. \n", "end mynat -- hide", "import mynat.definition -- hide\n", "import mynat.add -- hide\n", "import game.world8.level3 -- hide\n", "namespace mynat -- hide\n", "\n# Advanced Addition World\n\n## Level 4: `eq_iff_succ_eq_succ`\n\nHere is an `iff` goal. You can split it into two goals (the implications in both\ndirections) using the `split` tactic, which is how you're going to have to start.\n\n`split,`\n\nNow you have two goals. The first is exactly `succ_inj` so you can close\nit with\n\n`exact succ_inj,`\n\nand the second one you could solve by looking up the name of the theorem\nyou proved in the last level and doing `exact <that name>`, or alternatively\nyou could get some more `intro` practice and seeing if you can prove it\nusing `intro`, `rw` and `refl`.\n", "Two natural numbers are equal if and only if their successors are equal.\n", "end mynat -- hide\n", "import mynat.definition -- hide\n", "import mynat.add -- hide\n", "import game.world8.level4 -- hide\n", "namespace mynat -- hide\n", "\n# Advanced Addition World\n\n## Level 5: `add_right_cancel`\n\nThe theorem `add_right_cancel` is the theorem that you can cancel on the right\nwhen you're doing addition -- if `a + t = b + t` then `a = b`. After `intro h`\nI'd recommend induction on `t`. Don't forget that `rw add_zero at h` can be used\nto do rewriting of hypotheses rather than the goal.\n", "On the set of natural numbers, addition has the right cancellation property.\nIn other words, if there are natural numbers $a, b$ and $c$ such that\n$$ a + t = b + t, $$\nthen we have $a = b$.\n", "end mynat -- hide\n", "import game.world8.level5 -- hide\n", "namespace mynat -- hide\n", "\n# Advanced Addition World\n\n## Level 6: `add_left_cancel`\n\nThe theorem `add_left_cancel` is the theorem that you can cancel on the left\nwhen you're doing addition -- if `t + a = t + b` then `a = b`. \nThere is a three-line proof which ends in `exact add_right_cancel a t b` (or even\n`exact add_right_cancel _ _ _`); this\nstrategy involves changing the goal to the statement of `add_right_cancel` somehow.\n\n\n", "On the set of natural numbers, addition has the left cancellation property.\nIn other words, if there are natural numbers $a, b$ and $t$ such that\n$$ t + a = t + b, $$\nthen we have $a = b$.\n", "end mynat -- hide\n", "import game.world8.level6 -- hide\n", "namespace mynat -- hide\n", "\n# Advanced Addition World\n\n## Level 7: `add_right_cancel_iff`\n\nIt's sometimes convenient to have the \"if and only if\" version\nof theorems like `add_right_cancel`. Remember that you can use `split`\nto split an `\u2194` goal into the `\u2192` goal and the `\u2190` goal.\n\n## Pro tip:\n\n`exact add_right_cancel _ _ _` means \"let Lean figure out the missing inputs\"\n", "For all naturals $a$, $b$ and $t$, \n$$ a + t = b + t\\iff a=b. $$\n", "end mynat -- hide\n", "import game.world8.level7 -- hide\n", "namespace mynat -- hide\n", "\n# Advanced Addition World\n\n## Level 8: `eq_zero_of_add_right_eq_self`\n\nThe lemma you're about to prove will be useful when we want to prove that $\\leq$ is antisymmetric.\nThere are some wrong paths that you can take with this one.\n", "If $a$ and $b$ are natural numbers such that \n$$ a + b = a, $$\nthen $b = 0$.\n", "end mynat -- hide\n", "import mynat.definition -- hide\n", "import mynat.add -- hide\n", "import game.world8.level8 -- hide\n", "namespace mynat -- hide\n", "0 \u2260 succ(a)\n", "\n## Summary\n\n`symmetry` turns goals of the form `\u22a2 A = B` to `\u22a2 B = A`.\nAlso works with `\u2260`. Also works on hypotheses: if `h : a \u2260 b`\nthen `symmetry at h` gives `h : b \u2260 a`.\n\n## Details\n\n`symmetry` works on both goals and hypotheses. By default it\nworks on the goal. It will turn a goal of the form `\u22a2 A = B`\nto `\u22a2 B = A`. More generally it will work with any symmetric\nbinary relation (for example `\u2260`, or more generally any\nbinary relation whose proof of symmetry has been tagged\nwith the `symm` attribute).\n\nTo get `symmetry` working on a hypothesis, use `symmetry at h`.\n\n## Examples\n\nIf the tactic state is\n```\nh : a = b\n\u22a2 c \u2260 d\n```\n\nthen `symmetry` changes the goal to `\u22a2 d \u2260 c` and\n`symmetry at h` changes `h` to `h : b = a`.\n", "\n# Advanced Addition World\n\n## Level 9: `succ_ne_zero`\n\nLevels 9 to 13 introduce the last axiom of Peano, namely\nthat $0\\not=\\operatorname{succ}(a)$. The proof of this is called `zero_ne_succ a`. \n\n`zero_ne_succ (a : mynat) : 0 \u2260 succ(a)`\n\nThe `symmetry` tactic will turn any goal of the form `R x y` into `R y x`,\nif `R` is a symmetric binary relation (for example `=` or `\u2260`).\nIn particular, you can prove `succ_ne_zero` below by first using\n`symmetry` and then `exact zero_ne_succ a`. \n", "Zero is not the successor of any natural number.\n", "end mynat\n", "import game.world8.level9 -- hide\n", "namespace mynat -- hide\n", "# Advanced Addition World\n\n## Level 10: `add_left_eq_zero`\n\n## Important: the definition of `\u2260`\n\nIn Lean, `a \u2260 b` is *defined to mean* `(a = b) \u2192 false`. \nThis means that if you see `a \u2260 b` you can *literally treat\nit as saying* `(a = b) \u2192 false`. Computer scientists would\nsay that these two terms are *definitionally equal*. \n\nThe following lemma, $a+b=0\\implies b=0$, will be useful in inequality world.\nLet me go through the proof, because it introduces several new\nconcepts: \n\n* `cases b`, where `b : mynat`\n* `exfalso`\n* `apply succ_ne_zero`\n\nWe're going to prove $a+b=0\\implies b=0$. Here is the\nstrategy. Each natural number is either `0` or `succ(d)` for\nsome other natural number `d`. So we can start the proof\nwith \n\n`cases b with d,`\n\nand then we have two goals, the case `b = 0` (which you can solve easily)\nand the case `b = succ(d)`, which looks like this:\n\n```\na d : mynat,\nH : a + succ d = 0\n\u22a2 succ d = 0\n```\n\nOur goal is impossible to prove. However our hypothesis `H`\nis also impossible, meaning that we still have a chance!\nFirst let's see why `H` is impossible. We can\n\n`rw add_succ at H,`\n\nto turn `H` into `H : succ (a + d) = 0`. Because\n`succ_ne_zero (a + d)` is a proof that `succ (a + d) \u2260 0`,\nit is also a proof of the implication `succ (a + d) = 0 \u2192 false`.\nHence `succ_ne_zero (a + d) H` is a proof of `false`!\nUnfortunately our goal is not `false`, it's a generic\nfalse statement. \n\nRecall however that the `exfalso` command turns any goal into `false`\n(it's logically OK because `false` implies every proposition, true or false).\nYou can probably take it from here.\n", "If $a$ and $b$ are natural numbers such that \n$$ a + b = 0, $$\nthen $b = 0$.\n", "end mynat -- hide\n", "import mynat.definition -- hide\n", "import mynat.add -- hide\n", "import game.world8.level10 -- hide\n", "namespace mynat -- hide\n", "\n# Advanced Addition World\n\n## Level 11: `add_right_eq_zero`\n\nWe just proved `add_left_eq_zero (a b : mynat) : a + b = 0 \u2192 b = 0`.\nHopefully `add_right_eq_zero` shouldn't be too hard now.\n", "If $a$ and $b$ are natural numbers such that \n$$ a + b = 0, $$\nthen $a = 0$.\n", "end mynat -- hide\n", "import game.world8.level11 -- hide\n", "namespace mynat -- hide\n", "\n# Advanced Addition World\n\n## Level 12: `add_one_eq_succ`\n\nWe have\n\n  * `succ_eq_add_one (n : mynat) : succ n = n + 1`\n\nbut sometimes the other way is also convenient.\n", "For any natural number $d$, we have\n$$ d+1 = \\operatorname{succ}(d). $$\n", "end mynat -- hide\n", "import game.world8.level12 -- hide\n", "namespace mynat -- hide\n", "\n# Advanced Addition World\n\n## Level 13: `ne_succ_self`\n\nThe last level in Advanced Addition World is the statement\nthat $n\\not=\\operatorname{succ}(n)$. When you've done this\nyou've completed Advanced Addition World and can move on\nto Advanced Multiplication World (after first doing\nMultiplication World, if you didn't do it already). \n", "For any natural number $n$, we have\n$$ n \\neq \\operatorname{succ}(n). $$\n", "end mynat -- hide\n", "Advanced Multiplication world", "import game.world8.level13 -- hide\n", "import game.world3.level9\n", "namespace mynat -- hide\n", "# Advanced Multiplication World\n\n## Level 1: `mul_pos`\n\nWelcome to Advanced Multiplication World! Before attempting this\nworld you should have completed seven other worlds, including\nMultiplication World and Advanced Addition World. There are four\nlevels in this world.\n\nRecall that if `b : mynat` is a hypothesis and you do `cases b with n`,\nyour one goal will split into two goals, \nnamely the cases `b = 0` and `b = succ(n)`. So `cases` here is like\na weaker version of induction (you don't get the inductive hypothesis).\n\n## Tricks\n\n1) if your goal is `\u22a2 X \u2260 Y` then `intro h` will give you `h : X = Y` and\na goal of `\u22a2 false`. This is because `X \u2260 Y` *means* `(X = Y) \u2192 false`.\nConversely if your goal is `false` and you have `h : X \u2260 Y` as a hypothesis\nthen `apply h` will turn the goal into `X = Y`.\n\n2) if `hab : succ (3 * x + 2 * y + 1) = 0` is a hypothesis and your goal is `\u22a2 false`,\nthen `exact succ_ne_zero _ hab` will solve the goal, because Lean will figure\nout that `_` is supposed to be `3 * x + 2 * y + 1`.\n\n", "The product of two non-zero natural numbers is non-zero.\n", "end mynat -- hide\n", "import game.world9.level1 -- hide\n", "namespace mynat -- hide\n", "# Advanced Multiplication World\n\n## Level 2: `eq_zero_or_eq_zero_of_mul_eq_zero`\n\nA variant on the previous level.\n", "If $ab = 0$, then at least one of $a$ or $b$ is equal to zero.\n", "end mynat -- hide\n", "import game.world9.level2 -- hide\n", "namespace mynat -- hide\n", "# Advanced Multiplication World\n\n## Level 3: `mul_eq_zero_iff`\n\nNow you have `eq_zero_or_eq_zero_of_mul_eq_zero` this is pretty straightforward.\n", "$ab = 0$, if and only if at least one of $a$ or $b$ is equal to zero.\n", "end mynat -- hide\n", "import game.world9.level3 -- hide\n", "namespace mynat -- hide\n", "# Advanced Multiplication World\n\n## Level 4: `mul_left_cancel`\n\nThis is the last of the bonus multiplication levels.\n`mul_left_cancel` will be useful in inequality world.\n\nPeople find this level hard. I have probably had more questions about this\nlevel than all the other levels put together, in fact. Many levels in this\ngame can just be solved by \"running at it\" -- do induction on one of the\nvariables, keep your head, and you're done. In fact, if you like a challenge,\nit might be instructive if you stop reading after the end of this paragraph and try solving this level now by induction,\nseeing the trouble you run into, and reading the rest of these comments afterwards. This level\nhas a sting in the tail. If you are a competent mathematician, try\nand figure out what is going on. Write down a maths proof of the\ntheorem in this level. Exactly what statement do you want to prove\nby induction? It is subtle.\n\nOk so here are some spoilers. The problem with naively running at it, is that if you try induction on,\nsay, $c$, then you are imagining a and b as fixed, and your inductive\nhypothesis $P(c)$ is $ab=ac \\implies b=c$. So for your inductive step\nyou will be able to assume $ab=ad \\implies b=d$ and your goal will\nbe to show $ab=a(d+1) \\implies b=d+1$. When you also assume $ab=a(d+1)$\nyou will realise that your inductive hypothesis is *useless*, because\n$ab=ad$ is not true! The statement $P(c)$ (with $a$ and $b$ regarded\nas constants) is not provable by induction.\n\nWhat you *can* prove by induction is the following *stronger* statement.\nImagine $a\\not=0$ as fixed, and then prove \"for all $b$, if $ab=ac$ then $b=c$\"\nby induction on $c$. This gives us the extra flexibility we require.\nNote that we are quantifying over all $b$ in the inductive hypothesis -- it\nis essential that $b$ is not fixed. \n\nYou can do this in two ways in Lean -- before you start the induction\nyou can write `revert b,`. The `revert` tactic is the opposite of the `intro`\ntactic; it replaces the `b` in the hypotheses with \"for all $b$\" in the goal.\n\nAlternatively, you can write `induction c with d hd\ngeneralizing b` as the first line of the proof. \n\nIf you do not modify your technique in this way, then this level seems\nto be impossible (judging by the comments I've had about it!)\n", "If $a \\neq 0$, $b$ and $c$ are natural numbers such that\n$ ab = ac, $\nthen $b = c$.\n", "end mynat -- hide\n", "You should now be ready for inequality world.\n", "\n## Summary\n\n`revert x` is the opposite to `intro x`.\n\n## Details\n\nIf the tactic state looks like this\n\n```\nP Q : Prop,\nh : P\n\u22a2 Q\n```\n\nthen `revert h` will change it to\n\n```\nP Q : Prop\n\u22a2 P \u2192 Q\n```\n\n`revert` also works with things like natural numbers: if\nthe tactic state looks like this\n\n```\nm : mynat\n\u22a2 m + 1 = succ m\n```\n\nthen `revert m` will turn it into\n\n```\n\u22a2 \u2200 (m : mynat), m + 1 = mynat.succ m\n```\n\n", "Inequality world", "import mynat.le -- import definition of \u2264\n", "import game.world9.level4 -- hide\n", "import game.world4.level8 -- hide\n", "namespace mynat -- hide\n", "  a \u2264 b \u2194 \u2203 (c : mynat), b = a + c\n", "## Summary\n\n`use` works on the goal. If your goal is `\u22a2 \u2203 c : mynat, 1 + x = x + c`\nthen `use 1` will turn the goal into `\u22a2 1 + x = x + 1`, and the rather\nmore unwise `use 0` will turn it into the impossible-to-prove\n`\u22a2 1 + x = x + 0`.\n\n## Details\n\n`use` is a tactic which works on goals of the form `\u22a2 \u2203 c, P(c)` where\n`P(c)` is some proposition which depends on `c`. With a goal of this\nform, `use 0` will turn the goal into `\u22a2 P(0)`, `use x + y` (assuming\n`x` and `y` are natural numbers in your local context) will turn\nthe goal into `P(x + y)` and so on.\n", "\n# Inequality world. \n\nA new import, giving us a new definition. If `a` and `b` are naturals,\n`a \u2264 b` is *defined* to mean\n\n`\u2203 (c : mynat), b = a + c`\n\nThe upside-down E means \"there exists\". So in words, $a\\le b$\nif and only if there exists a natural $c$ such that $b=a+c$. \n\nIf you really want to change an `a \u2264 b` to `\u2203 c, b = a + c` then\nyou can do so with `rw le_iff_exists_add`:\n\n```\nle_iff_exists_add (a b : mynat) :\n  a \u2264 b \u2194 \u2203 (c : mynat), b = a + c\n```\n\nBut because `a \u2264 b` is *defined as* `\u2203 (c : mynat), b = a + c`, you\ndo not need to `rw le_iff_exists_add`, you can just pretend when you see `a \u2264 b`\nthat it says `\u2203 (c : mynat), b = a + c`. You will see a concrete\nexample of this below.\n\nA new construction like `\u2203` means that we need to learn how to manipulate it.\nThere are two situations. Firstly we need to know how to solve a goal\nof the form `\u22a2 \u2203 c, ...`, and secondly we need to know how to use a hypothesis\nof the form `\u2203 c, ...`. \n\n## Level 1: the `use` tactic.\n\nThe goal below is to prove $x\\le 1+x$ for any natural number $x$. \nFirst let's turn the goal explicitly into an existence problem with\n\n`rw le_iff_exists_add,`\n\nand now the goal has become `\u2203 c : mynat, 1 + x = x + c`. Clearly\nthis statement is true, and the proof is that $c=1$ will work (we also\nneed the fact that addition is commutative, but we proved that a long\ntime ago). How do we make progress with this goal?\n\nThe `use` tactic can be used on goals of the form `\u2203 c, ...`. The idea\nis that we choose which natural number we want to use, and then we use it.\nSo try\n\n`use 1,`\n\nand now the goal becomes `\u22a2 1 + x = x + 1`. You can solve this by\n`exact add_comm 1 x`, or if you are lazy you can just use the `ring` tactic,\nwhich is a powerful AI which will solve any equality in algebra which can\nbe proved using the standard rules of addition and multiplication. Now\nlook at your proof. We're going to remove a line.\n\n## Important\n\nAn important time-saver here is to note that because `a \u2264 b` is *defined*\nas `\u2203 c : mynat, b = a + c`, you *do not need to write* `rw le_iff_exists_add`.\nThe `use` tactic will work directly on a goal of the form `a \u2264 b`. Just\nuse the difference `b - a` (note that we have not defined subtraction so\nthis does not formally make sense, but you can do the calculation in your head).\nIf you have written `rw le_iff_exists_add` below, then just put two minus signs `--`\nbefore it and comment it out. See that the proof still compiles.\n", "If $x$ is a natural number, then $x\\le 1+x$.\n", "end mynat -- hide\n", "import game.world10.level1 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\nHere's a nice easy one.\n\n## Level 2: le_refl \n", "The $\\le$ relation is reflexive. In other words, if $x$ is a natural number,\nthen $x\\le x$.\n", "## Upgrading the `refl` tactic \n\nNow with the following incantation (NB thanks to master wizard Reid Barton\nfor correcting my spell)...\n", "attribute [refl] mynat.le_refl\n", "...we find that the `refl` tactic will close all goals\nof the form `a \u2264 a` as well as all goals of the form `a = a`.\n", "example : (0 : mynat) \u2264 0 := begin\n  refl\nend\n", "## Pro tip\n\nDid you skip `rw le_iff_exists_add` in your proof of `le_refl` above?\nInstead of `rw add_zero` or `ring` or `exact add_zero x` at the end there,\nwhat happens if you just try `refl`? The *definition* of `x + 0` is `x`,\nso you don't need to `rw add_zero` either! The proof\n\n```\nuse 0,\nrefl,\n```\n\nworks.\n\nThe same remarks are true of\n`add_succ`, `mul_zero`, `mul_succ`, `pow_zero` and `pow_succ`. All of those\ntheorems are true *by definition*. The same is *not* true however of `zero_add`; \nthe theorem `0 + x = x` was proved by induction on `x`,\nand in particular it is not true by *definition*.\n\nDefinitional equality is of great importance\nto computer scientists, but mathematicians are much more fluid with their idea\nof a definition -- a concept can simultaneously have three equivalent definitions\nin a maths talk, as long as they're all logically equivalent. In Lean, a definition\nis *one thing*, and definitional equality is a subtle concept which depends on\nexactly which definition you chose. `add_comm` is certainly not true by definition,\nwhich means that if we had decided to define `a \u2264 b` by `\u2203 c, b = c + a` (rather\nthan `a + c`) all the same theorems would be true, but `refl` would work in\ndifferent places. `refl` closes a goal of the form `X = Y` if `X` and `Y` are\ndefinitionally equal.\n", "end mynat -- hide\n", "import game.world10.level2 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\n## Level 3: `le_succ_of_le`\n\nWe have seen how the `use` tactic makes progress on goals of the form `\u22a2 \u2203 c, ...`.\nBut what do we do when we have a *hypothesis* of the form `h : \u2203 c, ...`?\nThe hypothesis claims that there exists some natural number `c` with some\nproperty. How are we going to get to that natural number `c`? It turns out\nthat the `cases` tactic can be used (just like it was used to extract\ninformation from `\u2227` and `\u2228` and `\u2194` hypotheses). Let me talk you through\nthe proof of $a\\le b\\implies a\\le\\operatorname{succ}(b)$.\n\nThe goal is an implication so we clearly want to start with \n\n`intro h,`\n\n. After this, if you *want*, you can do something like\n\n`rw le_iff_exists_add at h \u22a2,`\n\n(get the sideways T with `\\|-` then space). This changes the `\u2264` into\nits `\u2203` form in `h` and the goal -- but if you are happy with just\n*imagining* the `\u2203` whenever you read a `\u2264` then you don't need to do this line.\n\nOur hypothesis `h` is now `\u2203 (c : mynat), b = a + c` (or `a \u2264 b` if you\nelected not to do the definitional rewriting) so\n\n`cases h with c hc,`\n\ngives you the natural number `c` and the hypothesis `hc : b = a + c`.\nNow use `use` wisely and you're home.\n\n", "For all naturals $a$, $b$, if $a\\leq b$ then $a\\leq \\operatorname{succ}(b)$. \n", "\n\nDid you use `succ c` or `c + 1` or `1 + c`? Those numbers are all\nequal, right? So it doesn't matter which one you use, right?\n\nHere's an interesting question. If you copy the proof below into\nthe box above, and then fill in the `???`\nbelow with `succ c`, will this proof compile? (move your cursor to\nafter the final comma to see what Lean thinks). What about if you\n`use 1 + c`? What about if you `use c + 1`? Can you work out\nwhat is going on? Does it help if I tell you that the *definition*\nof `1` is `succ 0`?\n\n```\ntheorem le_succ (a b : mynat) : a \u2264 b \u2192 a \u2264 (succ b) :=\nbegin [nat_num_game]\n  intro h,\n  cases h with c hc,\n  rw hc,\n  use ???,\n  refl,\n\n\nend\n```\n\n", "end mynat -- hide\n", "import game.world10.level3 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\n## Level 4: `zero_le`\n\nAnother easy one. \n", "For all naturals $a$, $0\\leq a$.\n", "end mynat -- hide\n", "import game.world10.level4 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\n## Level 5: `le_trans`\n\nAnother straightforward one. \n", "\u2264 is transitive. In other words, if $a\\leq b$ and $b\\leq c$ then $a\\leq c$. \n", "Congratulations -- you just got a collectible. You proved that the\nnatural numbers are a preorder.\n", "instance : preorder mynat := by structure_helper\n", "end mynat -- hide\n", "import game.world10.level5 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\n## Level 6: `le_antisymm`\n\nIn Advanced Addition World you proved\n\n`eq_zero_of_add_right_eq_self (a b : mynat) : a + b = a \u2192 b = 0`.\n\nThis might be useful in this level.\n\nAnother tip: if you want to create a new hypothesis, you can use the `have` tactic.\nFor example, if you have a hypothesis `hd : a + (c + d) = a` and you want \na hypothesis `h : c + d = 0` then you can write\n\n`have h := eq_zero_of_add_right_eq_self hd,`\n\n", "$\\le$ is antisymmetric. In other words, if $a\\le b$ and $b\\le a$ then $a = b$. \n", "Congratulations -- you just proved that the natural numbers are a partial order!\n", "instance : partial_order mynat := by structure_helper\n", "end mynat -- hide\n", "import game.world10.level6 -- hide\n", "namespace mynat -- hide\n", "# Inequality world \n\n## Level 7: `le_zero`\n\nWe proved `add_right_eq_zero` back in advanced addition world.\nRemember that you can do things like `have h2 := add_right_eq_zero h1`\nif `h1 : a + c = 0`.\n", "For all naturals $a$, if $a\\le 0$ then $a = 0$.\n", "end mynat -- hide\n", "import game.world10.level7 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\n## Level 8: `succ_le_succ`\n\nAnother straightforward one. \n", "For all naturals $a$ and $b$, if $a\\le b$, then $\\operatorname{succ}(a)\\le\\operatorname{succ}(b)$. \n", "end mynat -- hide\n", "import game.world10.level8 -- hide\n", "namespace mynat -- hide\n", "# Inequality world. \n\n## Level 9: `le_total`\n", "For all naturals $a$ and $b$, either $a\\le b$ or $b\\le a$. \n", "-- Another collectible: the naturals are a linear order.\ninstance : linear_order mynat := by structure_helper\n", "end mynat -- hide\n", "import game.world10.level9 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\n## Level 10: `le_succ_self`\n\nCan you find the two-line proof?\n", "For all naturals $a$, $a\\le\\operatorname{succ}(a).$\n", "end mynat -- hide\n", "import game.world10.level10 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\n## Level 11: `add_le_add_right`\n\nIf you're faced with a goal of the form `forall t, ...`, then the next\nline is \"so let $t$ be arbitrary\". The way to do this in Lean is `intro t`.\n", "For all naturals $a$ and $b$, $a\\le b$ implies that for all naturals $t$,\n$a+t\\le b+t$.\n", "end mynat -- hide\n", "import game.world10.level11 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\n## Level 12: `le_of_succ_le_succ`\n\n", "For all naturals $a$ and $b$,\n$\\operatorname{succ}(a)\\le\\operatorname{succ}(b)\\implies a\\le b.$\n", "end mynat -- hide\n", "import game.world10.level12 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\n## Level 13: `not_succ_le_self`\n\nTurns out that `\u00ac P` is *by definition* `P \u2192 false`, so you can just\nstart this one with `intro h` if you like. \n\n## Pro tip:\n\n```\n  conv begin\n    to_lhs,\n    rw hc,\n  end,\n```\n\nis an incantation which rewrites `hc` only on the left hand side of the goal.\nLook carefully at the commas. You don't need to use `conv` to solve this,\nbut it's a helpful trick when `rw` is rewriting too much.\n", "For all naturals $a$, $\\operatorname{succ}(a)$ is not at most $a$.\n", "end mynat -- hide\n", "-- thanks to Filip Szczepa\u0144ski for this proof (nicer than the original; I was doing -- hide\n", "-- induction a before cases h) -- hide", "import game.world10.level13 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\n## Level 14: `add_le_add_left`\n\nI know these are easy and we've done several already, but this is one\nof the axioms for an ordered commutative monoid! The nature of formalising\nis that we should formalise all \"obvious\" lemmas, and then when we're\nactually using $\\le$ in real life, everything will be there. Note also,\nof course, that all of these lemmas are already formalised in Lean's\nmaths library already, for Lean's inbuilt natural numbers. \n", "If $a\\le b$ then for all $t$, $t+a\\le t+b$. \n", "end mynat -- hide\n", "--import mynat.lt -- definition of <\n", "import game.world10.level14 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\n## Level 15: introducing `<`\n\nTo get the remaining collectibles in this world, we need to\ngive a definition of `<`. By default, the definition of `a < b`\nin Lean, once `\u2264` is defined, is this:\n\n`a < b := a \u2264 b \u2227 \u00ac (b \u2264 a)`\n\n. But a much more usable definition would be this:\n\n`a < b := succ(a) \u2264 b`\n\n. Let's prove that these two definitions are the same\n", "For all naturals $a$ and $b$,\n$$a\\le b\\land\\lnot(b\\le a)\\implies\\operatorname{succ}(a)\\le b.$$\n", "end mynat -- hide\n", "import game.world10.level15 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\n## Level 16: equivalence of two definitions of `<`\n\nNow let's go the other way. \n", "For all naturals $a$ and $b$,\n$$\n\\operatorname{succ}(a)\\le b\n\\implies\na\\le b\\land\\lnot(b\\le a).$$\n", "Now for the payoff.\n", "end mynat -- hide\n", "import game.world10.level16 -- hide\n", "namespace mynat -- hide\n", "\n# Inequality world. \n\n## Level 17: definition of `<`\n\nOK so we are going to *define* `a < b` by `a \u2264 b \u2227 \u00ac (b \u2264 a)`,\nand given `lt_aux_one a b` and `lt_aux_two a b` it should now just\nbe a few lines to prove `a < b \u2194 succ(a) \u2264 b`. \n\n", "definition lt (a b : mynat) := a \u2264 b \u2227 \u00ac (b \u2264 a)\n-- incantation so that we can use `<` notation: \ninstance : has_lt mynat := \u27e8lt\u27e9\n", "For all naturals $a$ and $b$,\n$$a<b\\iff\\operatorname{succ}(a)\\le b.$$\n", "For now -- that's it. In the next version of the natural number game we will go on and make\nthe natural numbers into an `ordered_cancel_comm_monoid`, which is the most\nexotic of all the structures defined on the natural numbers in Lean 3.4.2.\n\nInterested in playing levels involving other kinds of mathematics?\nLook <a href=\"https://github.com/ImperialCollegeLondon/natural_number_game/blob/master/WHATS_NEXT.md\"\n  target=\"blank\">here</a> for more ideas about what to do next.\n\nInterested in learning more? Join us on the\n<a href=\"https://leanprover.zulipchat.com/\" target=\"blank\">Zulip Lean chat</a>\nand ask questions in the `#new members` stream. Real names preferred. Be nice.\n", "end mynat -- hide\n"]]}